<!DOCTYPE HTML><html><head>
<link rel=stylesheet href=./style.css >
</head><body></body><script>
var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".json"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    var global = typeof window !== 'undefined' ? window : {};
    var definedProcess = false;
    
    require.define = function (filename, fn) {
        if (!definedProcess && require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
            definedProcess = true;
        }
        
        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;
        
        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };
        
        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process,
                global
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",Function(['require','module','exports','__dirname','__filename','process','global'],"function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\n//@ sourceURL=path"
));

require.define("__browserify_process",Function(['require','module','exports','__dirname','__filename','process','global'],"var process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n        && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    process.cwd = function () { return cwd };\n    process.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\n//@ sourceURL=__browserify_process"
));

require.define("/node_modules/rumours/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./server.js\",\"browserify\":\"./client.js\"}\n//@ sourceURL=/node_modules/rumours/package.json"
));

require.define("/node_modules/rumours/client.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var reconnect = require('reconnect')\nvar reloader  = require('client-reloader')\nvar shasum    = require('shasum')\nvar Remote    = require('level-scuttlebutt/client')\n\n//memoize the connections so that this works nicely inside http://github.com/dominictarr/demonstrate\nvar connections = {}\n\nmodule.exports = function (config) {\n  config = config || {}\n  var udid = require('udid')(config.name || 'rumours')\n\n  //run on local by default for now...\n  //but later, it will be rumours.nearform.com or whatever...\n\n  var host = config.host || window.location.protocol + '//' + window.location.host\n\n  var tmpId = shasum(JSON.stringify([udid, config, host]))\n\n  if(connections[tmpId]) return connections[tmpId]\n\n  config.name = config.name || 'rumours'\n  config.prefix = config.prefix || '/rumours'\n  var schema = config.schema || require('./schema')\n  var remote = Remote(schema, udid)\n\n  var r = reconnect(reloader(function (stream) {\n    //this will load the default schema into the bundle,\n    //should do this a different way, to avoid that when using custom schemas.\n    stream.pipe(remote.createRemoteStream()).pipe(stream)\n  }, config)).connect(host + config.prefix)\n\n  connections[tmpId] = r\n\n  r.open = remote.open\n  r.view = remote.view\n  r._remote = remote\n  r.id = udid\n  return r\n}\n\n\n//@ sourceURL=/node_modules/rumours/client.js"
));

require.define("/node_modules/rumours/node_modules/reconnect/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"browserify\":\"./shoe\"}\n//@ sourceURL=/node_modules/rumours/node_modules/reconnect/package.json"
));

require.define("/node_modules/rumours/node_modules/reconnect/shoe.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar shoe = require('shoe')\n\nmodule.exports = require('./inject')(function (){\n  var args = [].slice.call(arguments)\n  return shoe.apply(null, args)\n})\n\n//@ sourceURL=/node_modules/rumours/node_modules/reconnect/shoe.js"
));

require.define("/node_modules/rumours/node_modules/shoe/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index.js\",\"browserify\":\"browser.js\"}\n//@ sourceURL=/node_modules/rumours/node_modules/shoe/package.json"
));

require.define("/node_modules/rumours/node_modules/shoe/browser.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Stream = require('stream');\nvar sockjs = require('sockjs-client');\n\nmodule.exports = function (uri, cb) {\n    if (/^\\/\\/[^\\/]+\\//.test(uri)) {\n        uri = window.location.protocol + uri;\n    }\n    else if (!/^https?:\\/\\//.test(uri)) {\n        uri = window.location.protocol + '//'\n            + window.location.host\n            + (/^\\//.test(uri) ? uri : '/' + uri)\n        ;\n    }\n    \n    var stream = new Stream;\n    stream.readable = true;\n    stream.writable = true;\n    \n    var ready = false;\n    var buffer = [];\n    \n    var sock = sockjs(uri);\n    stream.sock = sock;\n    \n    stream.write = function (msg) {\n        if (!ready || buffer.length) buffer.push(msg)\n        else sock.send(msg)\n    };\n    stream.end = function (msg) {\n        if (msg !== undefined) stream.write(msg);\n        if (!ready) {\n            stream._ended = true;\n            return;\n        }\n        stream.writable = false;\n        sock.close();\n    };\n\n    stream.destroy = function () {\n        stream._ended = true;\n        stream.writable = stream.readable = false;\n        buffer.length = 0\n        sock.close();\n    }\n    \n    sock.onopen = function () {\n        if (typeof cb === 'function') cb();\n        ready = true;\n        buffer.forEach(function (msg) {\n            sock.send(msg);\n        });\n        buffer = [];\n        stream.emit('connect')\n        if (stream._ended) stream.end();\n    };\n    sock.onmessage = function (e) {\n        stream.emit('data', e.data);\n    };\n    sock.onclose = function () {\n        stream.emit('end');\n        stream.writable = false;\n        stream.readable = false;\n    };\n    \n    return stream;\n};\n\n//@ sourceURL=/node_modules/rumours/node_modules/shoe/browser.js"
));

require.define("stream",Function(['require','module','exports','__dirname','__filename','process','global'],"var events = require('events');\nvar util = require('util');\n\nfunction Stream() {\n  events.EventEmitter.call(this);\n}\nutil.inherits(Stream, events.EventEmitter);\nmodule.exports = Stream;\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once, and\n  // only when all sources have ended.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    dest._pipeCount = dest._pipeCount || 0;\n    dest._pipeCount++;\n\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest._pipeCount--;\n\n    // remove the listeners\n    cleanup();\n\n    if (dest._pipeCount > 0) {\n      // waiting for other incoming streams to end.\n      return;\n    }\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest._pipeCount--;\n\n    // remove the listeners\n    cleanup();\n\n    if (dest._pipeCount > 0) {\n      // waiting for other incoming streams to end.\n      return;\n    }\n\n    dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (this.listeners('error').length === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('end', cleanup);\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('end', cleanup);\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n//@ sourceURL=stream"
));

require.define("events",Function(['require','module','exports','__dirname','__filename','process','global'],"if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === 'function'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]'\n    }\n;\nfunction indexOf (xs, x) {\n    if (xs.indexOf) return xs.indexOf(x);\n    for (var i = 0; i < xs.length; i++) {\n        if (x === xs[i]) return i;\n    }\n    return -1;\n}\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == 'function') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('addListener only takes instances of Function');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == \"newListeners\"! Before\n  // adding it to the listeners, first emit \"newListeners\".\n  this.emit('newListener', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('removeListener only takes instances of Function');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = indexOf(list, listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\n//@ sourceURL=events"
));

require.define("util",Function(['require','module','exports','__dirname','__filename','process','global'],"var events = require('events');\n\nexports.isArray = isArray;\nexports.isDate = function(obj){return Object.prototype.toString.call(obj) === '[object Date]'};\nexports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === '[object RegExp]'};\n\n\nexports.print = function () {};\nexports.puts = function () {};\nexports.debug = function() {};\n\nexports.inspect = function(obj, showHidden, depth, colors) {\n  var seen = [];\n\n  var stylize = function(str, styleType) {\n    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n    var styles =\n        { 'bold' : [1, 22],\n          'italic' : [3, 23],\n          'underline' : [4, 24],\n          'inverse' : [7, 27],\n          'white' : [37, 39],\n          'grey' : [90, 39],\n          'black' : [30, 39],\n          'blue' : [34, 39],\n          'cyan' : [36, 39],\n          'green' : [32, 39],\n          'magenta' : [35, 39],\n          'red' : [31, 39],\n          'yellow' : [33, 39] };\n\n    var style =\n        { 'special': 'cyan',\n          'number': 'blue',\n          'boolean': 'yellow',\n          'undefined': 'grey',\n          'null': 'bold',\n          'string': 'green',\n          'date': 'magenta',\n          // \"name\": intentionally not styling\n          'regexp': 'red' }[styleType];\n\n    if (style) {\n      return '\\033[' + styles[style][0] + 'm' + str +\n             '\\033[' + styles[style][1] + 'm';\n    } else {\n      return str;\n    }\n  };\n  if (! colors) {\n    stylize = function(str, styleType) { return str; };\n  }\n\n  function format(value, recurseTimes) {\n    // Provide a hook for user-specified inspect functions.\n    // Check that value is an object with an inspect function on it\n    if (value && typeof value.inspect === 'function' &&\n        // Filter out the util module, it's inspect function is special\n        value !== exports &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      return value.inspect(recurseTimes);\n    }\n\n    // Primitive types cannot have properties\n    switch (typeof value) {\n      case 'undefined':\n        return stylize('undefined', 'undefined');\n\n      case 'string':\n        var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                                 .replace(/'/g, \"\\\\'\")\n                                                 .replace(/\\\\\"/g, '\"') + '\\'';\n        return stylize(simple, 'string');\n\n      case 'number':\n        return stylize('' + value, 'number');\n\n      case 'boolean':\n        return stylize('' + value, 'boolean');\n    }\n    // For some reason typeof null is \"object\", so special case here.\n    if (value === null) {\n      return stylize('null', 'null');\n    }\n\n    // Look up the keys of the object.\n    var visible_keys = Object_keys(value);\n    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;\n\n    // Functions without properties can be shortcutted.\n    if (typeof value === 'function' && keys.length === 0) {\n      if (isRegExp(value)) {\n        return stylize('' + value, 'regexp');\n      } else {\n        var name = value.name ? ': ' + value.name : '';\n        return stylize('[Function' + name + ']', 'special');\n      }\n    }\n\n    // Dates without properties can be shortcutted\n    if (isDate(value) && keys.length === 0) {\n      return stylize(value.toUTCString(), 'date');\n    }\n\n    var base, type, braces;\n    // Determine the object type\n    if (isArray(value)) {\n      type = 'Array';\n      braces = ['[', ']'];\n    } else {\n      type = 'Object';\n      braces = ['{', '}'];\n    }\n\n    // Make functions say that they are functions\n    if (typeof value === 'function') {\n      var n = value.name ? ': ' + value.name : '';\n      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';\n    } else {\n      base = '';\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n      base = ' ' + value.toUTCString();\n    }\n\n    if (keys.length === 0) {\n      return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n      if (isRegExp(value)) {\n        return stylize('' + value, 'regexp');\n      } else {\n        return stylize('[Object]', 'special');\n      }\n    }\n\n    seen.push(value);\n\n    var output = keys.map(function(key) {\n      var name, str;\n      if (value.__lookupGetter__) {\n        if (value.__lookupGetter__(key)) {\n          if (value.__lookupSetter__(key)) {\n            str = stylize('[Getter/Setter]', 'special');\n          } else {\n            str = stylize('[Getter]', 'special');\n          }\n        } else {\n          if (value.__lookupSetter__(key)) {\n            str = stylize('[Setter]', 'special');\n          }\n        }\n      }\n      if (visible_keys.indexOf(key) < 0) {\n        name = '[' + key + ']';\n      }\n      if (!str) {\n        if (seen.indexOf(value[key]) < 0) {\n          if (recurseTimes === null) {\n            str = format(value[key]);\n          } else {\n            str = format(value[key], recurseTimes - 1);\n          }\n          if (str.indexOf('\\n') > -1) {\n            if (isArray(value)) {\n              str = str.split('\\n').map(function(line) {\n                return '  ' + line;\n              }).join('\\n').substr(2);\n            } else {\n              str = '\\n' + str.split('\\n').map(function(line) {\n                return '   ' + line;\n              }).join('\\n');\n            }\n          }\n        } else {\n          str = stylize('[Circular]', 'special');\n        }\n      }\n      if (typeof name === 'undefined') {\n        if (type === 'Array' && key.match(/^\\d+$/)) {\n          return str;\n        }\n        name = JSON.stringify('' + key);\n        if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n          name = name.substr(1, name.length - 2);\n          name = stylize(name, 'name');\n        } else {\n          name = name.replace(/'/g, \"\\\\'\")\n                     .replace(/\\\\\"/g, '\"')\n                     .replace(/(^\"|\"$)/g, \"'\");\n          name = stylize(name, 'string');\n        }\n      }\n\n      return name + ': ' + str;\n    });\n\n    seen.pop();\n\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n      numLinesEst++;\n      if (cur.indexOf('\\n') >= 0) numLinesEst++;\n      return prev + cur.length + 1;\n    }, 0);\n\n    if (length > 50) {\n      output = braces[0] +\n               (base === '' ? '' : base + '\\n ') +\n               ' ' +\n               output.join(',\\n  ') +\n               ' ' +\n               braces[1];\n\n    } else {\n      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n    }\n\n    return output;\n  }\n  return format(obj, (typeof depth === 'undefined' ? 2 : depth));\n};\n\n\nfunction isArray(ar) {\n  return ar instanceof Array ||\n         Array.isArray(ar) ||\n         (ar && ar !== Object.prototype && isArray(ar.__proto__));\n}\n\n\nfunction isRegExp(re) {\n  return re instanceof RegExp ||\n    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');\n}\n\n\nfunction isDate(d) {\n  if (d instanceof Date) return true;\n  if (typeof d !== 'object') return false;\n  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);\n  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);\n  return JSON.stringify(proto) === JSON.stringify(properties);\n}\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\nexports.log = function (msg) {};\n\nexports.pump = null;\n\nvar Object_keys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) res.push(key);\n    return res;\n};\n\nvar Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {\n    var res = [];\n    for (var key in obj) {\n        if (Object.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n};\n\nvar Object_create = Object.create || function (prototype, properties) {\n    // from es5-shim\n    var object;\n    if (prototype === null) {\n        object = { '__proto__' : null };\n    }\n    else {\n        if (typeof prototype !== 'object') {\n            throw new TypeError(\n                'typeof prototype[' + (typeof prototype) + '] != \\'object\\''\n            );\n        }\n        var Type = function () {};\n        Type.prototype = prototype;\n        object = new Type();\n        object.__proto__ = prototype;\n    }\n    if (typeof properties !== 'undefined' && Object.defineProperties) {\n        Object.defineProperties(object, properties);\n    }\n    return object;\n};\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object_create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (typeof f !== 'string') {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(exports.inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j': return JSON.stringify(args[i++]);\n      default:\n        return x;\n    }\n  });\n  for(var x = args[i]; i < len; x = args[++i]){\n    if (x === null || typeof x !== 'object') {\n      str += ' ' + x;\n    } else {\n      str += ' ' + exports.inspect(x);\n    }\n  }\n  return str;\n};\n\n//@ sourceURL=util"
));

require.define("/node_modules/rumours/node_modules/shoe/node_modules/sockjs-client/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"sockjs.js\"}\n//@ sourceURL=/node_modules/rumours/node_modules/shoe/node_modules/sockjs-client/package.json"
));

require.define("/node_modules/rumours/node_modules/shoe/node_modules/sockjs-client/sockjs.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/* SockJS client, version 0.3.1.7.ga67f.dirty, http://sockjs.org, MIT License\n\nCopyright (c) 2011-2012 VMware, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n// JSON2 by Douglas Crockford (minified).\nvar JSON;JSON||(JSON={}),function(){function str(a,b){var c,d,e,f,g=gap,h,i=b[a];i&&typeof i==\"object\"&&typeof i.toJSON==\"function\"&&(i=i.toJSON(a)),typeof rep==\"function\"&&(i=rep.call(b,a,i));switch(typeof i){case\"string\":return quote(i);case\"number\":return isFinite(i)?String(i):\"null\";case\"boolean\":case\"null\":return String(i);case\"object\":if(!i)return\"null\";gap+=indent,h=[];if(Object.prototype.toString.apply(i)===\"[object Array]\"){f=i.length;for(c=0;c<f;c+=1)h[c]=str(c,i)||\"null\";e=h.length===0?\"[]\":gap?\"[\\n\"+gap+h.join(\",\\n\"+gap)+\"\\n\"+g+\"]\":\"[\"+h.join(\",\")+\"]\",gap=g;return e}if(rep&&typeof rep==\"object\"){f=rep.length;for(c=0;c<f;c+=1)typeof rep[c]==\"string\"&&(d=rep[c],e=str(d,i),e&&h.push(quote(d)+(gap?\": \":\":\")+e))}else for(d in i)Object.prototype.hasOwnProperty.call(i,d)&&(e=str(d,i),e&&h.push(quote(d)+(gap?\": \":\":\")+e));e=h.length===0?\"{}\":gap?\"{\\n\"+gap+h.join(\",\\n\"+gap)+\"\\n\"+g+\"}\":\"{\"+h.join(\",\")+\"}\",gap=g;return e}}function quote(a){escapable.lastIndex=0;return escapable.test(a)?'\"'+a.replace(escapable,function(a){var b=meta[a];return typeof b==\"string\"?b:\"\\\\u\"+(\"0000\"+a.charCodeAt(0).toString(16)).slice(-4)})+'\"':'\"'+a+'\"'}function f(a){return a<10?\"0\"+a:a}\"use strict\",typeof Date.prototype.toJSON!=\"function\"&&(Date.prototype.toJSON=function(a){return isFinite(this.valueOf())?this.getUTCFullYear()+\"-\"+f(this.getUTCMonth()+1)+\"-\"+f(this.getUTCDate())+\"T\"+f(this.getUTCHours())+\":\"+f(this.getUTCMinutes())+\":\"+f(this.getUTCSeconds())+\"Z\":null},String.prototype.toJSON=Number.prototype.toJSON=Boolean.prototype.toJSON=function(a){return this.valueOf()});var cx=/[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,escapable=/[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,gap,indent,meta={\"\\b\":\"\\\\b\",\"\\t\":\"\\\\t\",\"\\n\":\"\\\\n\",\"\\f\":\"\\\\f\",\"\\r\":\"\\\\r\",'\"':'\\\\\"',\"\\\\\":\"\\\\\\\\\"},rep;typeof JSON.stringify!=\"function\"&&(JSON.stringify=function(a,b,c){var d;gap=\"\",indent=\"\";if(typeof c==\"number\")for(d=0;d<c;d+=1)indent+=\" \";else typeof c==\"string\"&&(indent=c);rep=b;if(!b||typeof b==\"function\"||typeof b==\"object\"&&typeof b.length==\"number\")return str(\"\",{\"\":a});throw new Error(\"JSON.stringify\")}),typeof JSON.parse!=\"function\"&&(JSON.parse=function(text,reviver){function walk(a,b){var c,d,e=a[b];if(e&&typeof e==\"object\")for(c in e)Object.prototype.hasOwnProperty.call(e,c)&&(d=walk(e,c),d!==undefined?e[c]=d:delete e[c]);return reviver.call(a,b,e)}var j;text=String(text),cx.lastIndex=0,cx.test(text)&&(text=text.replace(cx,function(a){return\"\\\\u\"+(\"0000\"+a.charCodeAt(0).toString(16)).slice(-4)}));if(/^[\\],:{}\\s]*$/.test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g,\"@\").replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g,\"]\").replace(/(?:^|:|,)(?:\\s*\\[)+/g,\"\"))){j=eval(\"(\"+text+\")\");return typeof reviver==\"function\"?walk({\"\":j},\"\"):j}throw new SyntaxError(\"JSON.parse\")})}()\n\n\n//     [*] Including lib/index.js\n// Public object\nvar SockJS = (function(){\n              var _document = document;\n              var _window = window;\n              var utils = {};\n\n\n//         [*] Including lib/reventtarget.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n/* Simplified implementation of DOM2 EventTarget.\n *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget\n */\nvar REventTarget = function() {};\nREventTarget.prototype.addEventListener = function (eventType, listener) {\n    if(!this._listeners) {\n         this._listeners = {};\n    }\n    if(!(eventType in this._listeners)) {\n        this._listeners[eventType] = [];\n    }\n    var arr = this._listeners[eventType];\n    if(utils.arrIndexOf(arr, listener) === -1) {\n        arr.push(listener);\n    }\n    return;\n};\n\nREventTarget.prototype.removeEventListener = function (eventType, listener) {\n    if(!(this._listeners && (eventType in this._listeners))) {\n        return;\n    }\n    var arr = this._listeners[eventType];\n    var idx = utils.arrIndexOf(arr, listener);\n    if (idx !== -1) {\n        if(arr.length > 1) {\n            this._listeners[eventType] = arr.slice(0, idx).concat( arr.slice(idx+1) );\n        } else {\n            delete this._listeners[eventType];\n        }\n        return;\n    }\n    return;\n};\n\nREventTarget.prototype.dispatchEvent = function (event) {\n    var t = event.type;\n    var args = Array.prototype.slice.call(arguments, 0);\n    if (this['on'+t]) {\n        this['on'+t].apply(this, args);\n    }\n    if (this._listeners && t in this._listeners) {\n        for(var i=0; i < this._listeners[t].length; i++) {\n            this._listeners[t][i].apply(this, args);\n        }\n    }\n};\n//         [*] End of lib/reventtarget.js\n\n\n//         [*] Including lib/simpleevent.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar SimpleEvent = function(type, obj) {\n    this.type = type;\n    if (typeof obj !== 'undefined') {\n        for(var k in obj) {\n            if (!obj.hasOwnProperty(k)) continue;\n            this[k] = obj[k];\n        }\n    }\n};\n\nSimpleEvent.prototype.toString = function() {\n    var r = [];\n    for(var k in this) {\n        if (!this.hasOwnProperty(k)) continue;\n        var v = this[k];\n        if (typeof v === 'function') v = '[function]';\n        r.push(k + '=' + v);\n    }\n    return 'SimpleEvent(' + r.join(', ') + ')';\n};\n//         [*] End of lib/simpleevent.js\n\n\n//         [*] Including lib/eventemitter.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar EventEmitter = function(events) {\n    this.events = events || [];\n};\nEventEmitter.prototype.emit = function(type) {\n    var that = this;\n    var args = Array.prototype.slice.call(arguments, 1);\n    if (!that.nuked && that['on'+type]) {\n        that['on'+type].apply(that, args);\n    }\n    if (utils.arrIndexOf(that.events, type) === -1) {\n        utils.log('Event ' + JSON.stringify(type) +\n                  ' not listed ' + JSON.stringify(that.events) +\n                  ' in ' + that);\n    }\n};\n\nEventEmitter.prototype.nuke = function(type) {\n    var that = this;\n    that.nuked = true;\n    for(var i=0; i<that.events.length; i++) {\n        delete that[that.events[i]];\n    }\n};\n//         [*] End of lib/eventemitter.js\n\n\n//         [*] Including lib/utils.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar random_string_chars = 'abcdefghijklmnopqrstuvwxyz0123456789_';\nutils.random_string = function(length, max) {\n    max = max || random_string_chars.length;\n    var i, ret = [];\n    for(i=0; i < length; i++) {\n        ret.push( random_string_chars.substr(Math.floor(Math.random() * max),1) );\n    }\n    return ret.join('');\n};\nutils.random_number = function(max) {\n    return Math.floor(Math.random() * max);\n};\nutils.random_number_string = function(max) {\n    var t = (''+(max - 1)).length;\n    var p = Array(t+1).join('0');\n    return (p + utils.random_number(max)).slice(-t);\n};\n\n// Assuming that url looks like: http://asdasd:111/asd\nutils.getOrigin = function(url) {\n    url += '/';\n    var parts = url.split('/').slice(0, 3);\n    return parts.join('/');\n};\n\nutils.isSameOriginUrl = function(url_a, url_b) {\n    // location.origin would do, but it's not always available.\n    if (!url_b) url_b = _window.location.href;\n\n    return (url_a.split('/').slice(0,3).join('/')\n                ===\n            url_b.split('/').slice(0,3).join('/'));\n};\n\nutils.getParentDomain = function(url) {\n    // ipv4 ip address\n    if (/^[0-9.]*$/.test(url)) return url;\n    // ipv6 ip address\n    if (/^\\[/.test(url)) return url;\n    // no dots\n    if (!(/[.]/.test(url))) return url;\n\n    var parts = url.split('.').slice(1);\n    return parts.join('.');\n};\n\nutils.objectExtend = function(dst, src) {\n    for(var k in src) {\n        if (src.hasOwnProperty(k)) {\n            dst[k] = src[k];\n        }\n    }\n    return dst;\n};\n\nvar WPrefix = '_jp';\n\nutils.polluteGlobalNamespace = function() {\n    if (!(WPrefix in _window)) {\n        _window[WPrefix] = {};\n    }\n};\n\nutils.closeFrame = function (code, reason) {\n    return 'c'+JSON.stringify([code, reason]);\n};\n\nutils.userSetCode = function (code) {\n    return code === 1000 || (code >= 3000 && code <= 4999);\n};\n\n// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/\n// and RFC 2988.\nutils.countRTO = function (rtt) {\n    var rto;\n    if (rtt > 100) {\n        rto = 3 * rtt; // rto > 300msec\n    } else {\n        rto = rtt + 200; // 200msec < rto <= 300msec\n    }\n    return rto;\n}\n\nutils.log = function() {\n    if (_window.console && console.log && console.log.apply) {\n        console.log.apply(console, arguments);\n    }\n};\n\nutils.bind = function(fun, that) {\n    if (fun.bind) {\n        return fun.bind(that);\n    } else {\n        return function() {\n            return fun.apply(that, arguments);\n        };\n    }\n};\n\nutils.flatUrl = function(url) {\n    return url.indexOf('?') === -1 && url.indexOf('#') === -1;\n};\n\nutils.amendUrl = function(url) {\n    var dl = _document.location;\n    if (!url) {\n        throw new Error('Wrong url for SockJS');\n    }\n    if (!utils.flatUrl(url)) {\n        throw new Error('Only basic urls are supported in SockJS');\n    }\n\n    //  '//abc' --> 'http://abc'\n    if (url.indexOf('//') === 0) {\n        url = dl.protocol + url;\n    }\n    // '/abc' --> 'http://localhost:80/abc'\n    if (url.indexOf('/') === 0) {\n        url = dl.protocol + '//' + dl.host + url;\n    }\n    // strip trailing slashes\n    url = url.replace(/[/]+$/,'');\n    return url;\n};\n\n// IE doesn't support [].indexOf.\nutils.arrIndexOf = function(arr, obj){\n    for(var i=0; i < arr.length; i++){\n        if(arr[i] === obj){\n            return i;\n        }\n    }\n    return -1;\n};\n\nutils.arrSkip = function(arr, obj) {\n    var idx = utils.arrIndexOf(arr, obj);\n    if (idx === -1) {\n        return arr.slice();\n    } else {\n        var dst = arr.slice(0, idx);\n        return dst.concat(arr.slice(idx+1));\n    }\n};\n\n// Via: https://gist.github.com/1133122/2121c601c5549155483f50be3da5305e83b8c5df\nutils.isArray = Array.isArray || function(value) {\n    return {}.toString.call(value).indexOf('Array') >= 0\n};\n\nutils.delay = function(t, fun) {\n    if(typeof t === 'function') {\n        fun = t;\n        t = 0;\n    }\n    return setTimeout(fun, t);\n};\n\n\n// Chars worth escaping, as defined by Douglas Crockford:\n//   https://github.com/douglascrockford/JSON-js/blob/47a9882cddeb1e8529e07af9736218075372b8ac/json2.js#L196\nvar json_escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    json_lookup = {\n\"\\u0000\":\"\\\\u0000\",\"\\u0001\":\"\\\\u0001\",\"\\u0002\":\"\\\\u0002\",\"\\u0003\":\"\\\\u0003\",\n\"\\u0004\":\"\\\\u0004\",\"\\u0005\":\"\\\\u0005\",\"\\u0006\":\"\\\\u0006\",\"\\u0007\":\"\\\\u0007\",\n\"\\b\":\"\\\\b\",\"\\t\":\"\\\\t\",\"\\n\":\"\\\\n\",\"\\u000b\":\"\\\\u000b\",\"\\f\":\"\\\\f\",\"\\r\":\"\\\\r\",\n\"\\u000e\":\"\\\\u000e\",\"\\u000f\":\"\\\\u000f\",\"\\u0010\":\"\\\\u0010\",\"\\u0011\":\"\\\\u0011\",\n\"\\u0012\":\"\\\\u0012\",\"\\u0013\":\"\\\\u0013\",\"\\u0014\":\"\\\\u0014\",\"\\u0015\":\"\\\\u0015\",\n\"\\u0016\":\"\\\\u0016\",\"\\u0017\":\"\\\\u0017\",\"\\u0018\":\"\\\\u0018\",\"\\u0019\":\"\\\\u0019\",\n\"\\u001a\":\"\\\\u001a\",\"\\u001b\":\"\\\\u001b\",\"\\u001c\":\"\\\\u001c\",\"\\u001d\":\"\\\\u001d\",\n\"\\u001e\":\"\\\\u001e\",\"\\u001f\":\"\\\\u001f\",\"\\\"\":\"\\\\\\\"\",\"\\\\\":\"\\\\\\\\\",\n\"\\u007f\":\"\\\\u007f\",\"\\u0080\":\"\\\\u0080\",\"\\u0081\":\"\\\\u0081\",\"\\u0082\":\"\\\\u0082\",\n\"\\u0083\":\"\\\\u0083\",\"\\u0084\":\"\\\\u0084\",\"\\u0085\":\"\\\\u0085\",\"\\u0086\":\"\\\\u0086\",\n\"\\u0087\":\"\\\\u0087\",\"\\u0088\":\"\\\\u0088\",\"\\u0089\":\"\\\\u0089\",\"\\u008a\":\"\\\\u008a\",\n\"\\u008b\":\"\\\\u008b\",\"\\u008c\":\"\\\\u008c\",\"\\u008d\":\"\\\\u008d\",\"\\u008e\":\"\\\\u008e\",\n\"\\u008f\":\"\\\\u008f\",\"\\u0090\":\"\\\\u0090\",\"\\u0091\":\"\\\\u0091\",\"\\u0092\":\"\\\\u0092\",\n\"\\u0093\":\"\\\\u0093\",\"\\u0094\":\"\\\\u0094\",\"\\u0095\":\"\\\\u0095\",\"\\u0096\":\"\\\\u0096\",\n\"\\u0097\":\"\\\\u0097\",\"\\u0098\":\"\\\\u0098\",\"\\u0099\":\"\\\\u0099\",\"\\u009a\":\"\\\\u009a\",\n\"\\u009b\":\"\\\\u009b\",\"\\u009c\":\"\\\\u009c\",\"\\u009d\":\"\\\\u009d\",\"\\u009e\":\"\\\\u009e\",\n\"\\u009f\":\"\\\\u009f\",\"\\u00ad\":\"\\\\u00ad\",\"\\u0600\":\"\\\\u0600\",\"\\u0601\":\"\\\\u0601\",\n\"\\u0602\":\"\\\\u0602\",\"\\u0603\":\"\\\\u0603\",\"\\u0604\":\"\\\\u0604\",\"\\u070f\":\"\\\\u070f\",\n\"\\u17b4\":\"\\\\u17b4\",\"\\u17b5\":\"\\\\u17b5\",\"\\u200c\":\"\\\\u200c\",\"\\u200d\":\"\\\\u200d\",\n\"\\u200e\":\"\\\\u200e\",\"\\u200f\":\"\\\\u200f\",\"\\u2028\":\"\\\\u2028\",\"\\u2029\":\"\\\\u2029\",\n\"\\u202a\":\"\\\\u202a\",\"\\u202b\":\"\\\\u202b\",\"\\u202c\":\"\\\\u202c\",\"\\u202d\":\"\\\\u202d\",\n\"\\u202e\":\"\\\\u202e\",\"\\u202f\":\"\\\\u202f\",\"\\u2060\":\"\\\\u2060\",\"\\u2061\":\"\\\\u2061\",\n\"\\u2062\":\"\\\\u2062\",\"\\u2063\":\"\\\\u2063\",\"\\u2064\":\"\\\\u2064\",\"\\u2065\":\"\\\\u2065\",\n\"\\u2066\":\"\\\\u2066\",\"\\u2067\":\"\\\\u2067\",\"\\u2068\":\"\\\\u2068\",\"\\u2069\":\"\\\\u2069\",\n\"\\u206a\":\"\\\\u206a\",\"\\u206b\":\"\\\\u206b\",\"\\u206c\":\"\\\\u206c\",\"\\u206d\":\"\\\\u206d\",\n\"\\u206e\":\"\\\\u206e\",\"\\u206f\":\"\\\\u206f\",\"\\ufeff\":\"\\\\ufeff\",\"\\ufff0\":\"\\\\ufff0\",\n\"\\ufff1\":\"\\\\ufff1\",\"\\ufff2\":\"\\\\ufff2\",\"\\ufff3\":\"\\\\ufff3\",\"\\ufff4\":\"\\\\ufff4\",\n\"\\ufff5\":\"\\\\ufff5\",\"\\ufff6\":\"\\\\ufff6\",\"\\ufff7\":\"\\\\ufff7\",\"\\ufff8\":\"\\\\ufff8\",\n\"\\ufff9\":\"\\\\ufff9\",\"\\ufffa\":\"\\\\ufffa\",\"\\ufffb\":\"\\\\ufffb\",\"\\ufffc\":\"\\\\ufffc\",\n\"\\ufffd\":\"\\\\ufffd\",\"\\ufffe\":\"\\\\ufffe\",\"\\uffff\":\"\\\\uffff\"};\n\n// Some extra characters that Chrome gets wrong, and substitutes with\n// something else on the wire.\nvar extra_escapable = /[\\x00-\\x1f\\ud800-\\udfff\\ufffe\\uffff\\u0300-\\u0333\\u033d-\\u0346\\u034a-\\u034c\\u0350-\\u0352\\u0357-\\u0358\\u035c-\\u0362\\u0374\\u037e\\u0387\\u0591-\\u05af\\u05c4\\u0610-\\u0617\\u0653-\\u0654\\u0657-\\u065b\\u065d-\\u065e\\u06df-\\u06e2\\u06eb-\\u06ec\\u0730\\u0732-\\u0733\\u0735-\\u0736\\u073a\\u073d\\u073f-\\u0741\\u0743\\u0745\\u0747\\u07eb-\\u07f1\\u0951\\u0958-\\u095f\\u09dc-\\u09dd\\u09df\\u0a33\\u0a36\\u0a59-\\u0a5b\\u0a5e\\u0b5c-\\u0b5d\\u0e38-\\u0e39\\u0f43\\u0f4d\\u0f52\\u0f57\\u0f5c\\u0f69\\u0f72-\\u0f76\\u0f78\\u0f80-\\u0f83\\u0f93\\u0f9d\\u0fa2\\u0fa7\\u0fac\\u0fb9\\u1939-\\u193a\\u1a17\\u1b6b\\u1cda-\\u1cdb\\u1dc0-\\u1dcf\\u1dfc\\u1dfe\\u1f71\\u1f73\\u1f75\\u1f77\\u1f79\\u1f7b\\u1f7d\\u1fbb\\u1fbe\\u1fc9\\u1fcb\\u1fd3\\u1fdb\\u1fe3\\u1feb\\u1fee-\\u1fef\\u1ff9\\u1ffb\\u1ffd\\u2000-\\u2001\\u20d0-\\u20d1\\u20d4-\\u20d7\\u20e7-\\u20e9\\u2126\\u212a-\\u212b\\u2329-\\u232a\\u2adc\\u302b-\\u302c\\uaab2-\\uaab3\\uf900-\\ufa0d\\ufa10\\ufa12\\ufa15-\\ufa1e\\ufa20\\ufa22\\ufa25-\\ufa26\\ufa2a-\\ufa2d\\ufa30-\\ufa6d\\ufa70-\\ufad9\\ufb1d\\ufb1f\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufb4e\\ufff0-\\uffff]/g,\n    extra_lookup;\n\n// JSON Quote string. Use native implementation when possible.\nvar JSONQuote = (JSON && JSON.stringify) || function(string) {\n    json_escapable.lastIndex = 0;\n    if (json_escapable.test(string)) {\n        string = string.replace(json_escapable, function(a) {\n            return json_lookup[a];\n        });\n    }\n    return '\"' + string + '\"';\n};\n\n// This may be quite slow, so let's delay until user actually uses bad\n// characters.\nvar unroll_lookup = function(escapable) {\n    var i;\n    var unrolled = {}\n    var c = []\n    for(i=0; i<65536; i++) {\n        c.push( String.fromCharCode(i) );\n    }\n    escapable.lastIndex = 0;\n    c.join('').replace(escapable, function (a) {\n        unrolled[ a ] = '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n        return '';\n    });\n    escapable.lastIndex = 0;\n    return unrolled;\n};\n\n// Quote string, also taking care of unicode characters that browsers\n// often break. Especially, take care of unicode surrogates:\n//    http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates\nutils.quote = function(string) {\n    var quoted = JSONQuote(string);\n\n    // In most cases this should be very fast and good enough.\n    extra_escapable.lastIndex = 0;\n    if(!extra_escapable.test(quoted)) {\n        return quoted;\n    }\n\n    if(!extra_lookup) extra_lookup = unroll_lookup(extra_escapable);\n\n    return quoted.replace(extra_escapable, function(a) {\n        return extra_lookup[a];\n    });\n}\n\nvar _all_protocols = ['websocket',\n                      'xdr-streaming',\n                      'xhr-streaming',\n                      'iframe-eventsource',\n                      'iframe-htmlfile',\n                      'xdr-polling',\n                      'xhr-polling',\n                      'iframe-xhr-polling',\n                      'jsonp-polling'];\n\nutils.probeProtocols = function() {\n    var probed = {};\n    for(var i=0; i<_all_protocols.length; i++) {\n        var protocol = _all_protocols[i];\n        // User can have a typo in protocol name.\n        probed[protocol] = SockJS[protocol] &&\n                           SockJS[protocol].enabled();\n    }\n    return probed;\n};\n\nutils.detectProtocols = function(probed, protocols_whitelist, info) {\n    var pe = {},\n        protocols = [];\n    if (!protocols_whitelist) protocols_whitelist = _all_protocols;\n    for(var i=0; i<protocols_whitelist.length; i++) {\n        var protocol = protocols_whitelist[i];\n        pe[protocol] = probed[protocol];\n    }\n    var maybe_push = function(protos) {\n        var proto = protos.shift();\n        if (pe[proto]) {\n            protocols.push(proto);\n        } else {\n            if (protos.length > 0) {\n                maybe_push(protos);\n            }\n        }\n    }\n\n    // 1. Websocket\n    if (info.websocket !== false) {\n        maybe_push(['websocket']);\n    }\n\n    // 2. Streaming\n    if (pe['xhr-streaming'] && !info.null_origin) {\n        protocols.push('xhr-streaming');\n    } else {\n        if (pe['xdr-streaming'] && !info.cookie_needed && !info.null_origin) {\n            protocols.push('xdr-streaming');\n        } else {\n            maybe_push(['iframe-eventsource',\n                        'iframe-htmlfile']);\n        }\n    }\n\n    // 3. Polling\n    if (pe['xhr-polling'] && !info.null_origin) {\n        protocols.push('xhr-polling');\n    } else {\n        if (pe['xdr-polling'] && !info.cookie_needed && !info.null_origin) {\n            protocols.push('xdr-polling');\n        } else {\n            maybe_push(['iframe-xhr-polling',\n                        'jsonp-polling']);\n        }\n    }\n    return protocols;\n}\n//         [*] End of lib/utils.js\n\n\n//         [*] Including lib/dom.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n// May be used by htmlfile jsonp and transports.\nvar MPrefix = '_sockjs_global';\nutils.createHook = function() {\n    var window_id = 'a' + utils.random_string(8);\n    if (!(MPrefix in _window)) {\n        var map = {};\n        _window[MPrefix] = function(window_id) {\n            if (!(window_id in map)) {\n                map[window_id] = {\n                    id: window_id,\n                    del: function() {delete map[window_id];}\n                };\n            }\n            return map[window_id];\n        }\n    }\n    return _window[MPrefix](window_id);\n};\n\n\n\nutils.attachMessage = function(listener) {\n    utils.attachEvent('message', listener);\n};\nutils.attachEvent = function(event, listener) {\n    if (typeof _window.addEventListener !== 'undefined') {\n        _window.addEventListener(event, listener, false);\n    } else {\n        // IE quirks.\n        // According to: http://stevesouders.com/misc/test-postmessage.php\n        // the message gets delivered only to 'document', not 'window'.\n        _document.attachEvent(\"on\" + event, listener);\n        // I get 'window' for ie8.\n        _window.attachEvent(\"on\" + event, listener);\n    }\n};\n\nutils.detachMessage = function(listener) {\n    utils.detachEvent('message', listener);\n};\nutils.detachEvent = function(event, listener) {\n    if (typeof _window.addEventListener !== 'undefined') {\n        _window.removeEventListener(event, listener, false);\n    } else {\n        _document.detachEvent(\"on\" + event, listener);\n        _window.detachEvent(\"on\" + event, listener);\n    }\n};\n\n\nvar on_unload = {};\n// Things registered after beforeunload are to be called immediately.\nvar after_unload = false;\n\nvar trigger_unload_callbacks = function() {\n    for(var ref in on_unload) {\n        on_unload[ref]();\n        delete on_unload[ref];\n    };\n};\n\nvar unload_triggered = function() {\n    if(after_unload) return;\n    after_unload = true;\n    trigger_unload_callbacks();\n};\n\n// Onbeforeunload alone is not reliable. We could use only 'unload'\n// but it's not working in opera within an iframe. Let's use both.\nutils.attachEvent('beforeunload', unload_triggered);\nutils.attachEvent('unload', unload_triggered);\n\nutils.unload_add = function(listener) {\n    var ref = utils.random_string(8);\n    on_unload[ref] = listener;\n    if (after_unload) {\n        utils.delay(trigger_unload_callbacks);\n    }\n    return ref;\n};\nutils.unload_del = function(ref) {\n    if (ref in on_unload)\n        delete on_unload[ref];\n};\n\n\nutils.createIframe = function (iframe_url, error_callback) {\n    var iframe = _document.createElement('iframe');\n    var tref, unload_ref;\n    var unattach = function() {\n        clearTimeout(tref);\n        // Explorer had problems with that.\n        try {iframe.onload = null;} catch (x) {}\n        iframe.onerror = null;\n    };\n    var cleanup = function() {\n        if (iframe) {\n            unattach();\n            // This timeout makes chrome fire onbeforeunload event\n            // within iframe. Without the timeout it goes straight to\n            // onunload.\n            setTimeout(function() {\n                if(iframe) {\n                    iframe.parentNode.removeChild(iframe);\n                }\n                iframe = null;\n            }, 0);\n            utils.unload_del(unload_ref);\n        }\n    };\n    var onerror = function(r) {\n        if (iframe) {\n            cleanup();\n            error_callback(r);\n        }\n    };\n    var post = function(msg, origin) {\n        try {\n            // When the iframe is not loaded, IE raises an exception\n            // on 'contentWindow'.\n            if (iframe && iframe.contentWindow) {\n                iframe.contentWindow.postMessage(msg, origin);\n            }\n        } catch (x) {};\n    };\n\n    iframe.src = iframe_url;\n    iframe.style.display = 'none';\n    iframe.style.position = 'absolute';\n    iframe.onerror = function(){onerror('onerror');};\n    iframe.onload = function() {\n        // `onload` is triggered before scripts on the iframe are\n        // executed. Give it few seconds to actually load stuff.\n        clearTimeout(tref);\n        tref = setTimeout(function(){onerror('onload timeout');}, 2000);\n    };\n    _document.body.appendChild(iframe);\n    tref = setTimeout(function(){onerror('timeout');}, 15000);\n    unload_ref = utils.unload_add(cleanup);\n    return {\n        post: post,\n        cleanup: cleanup,\n        loaded: unattach\n    };\n};\n\nutils.createHtmlfile = function (iframe_url, error_callback) {\n    var doc = new ActiveXObject('htmlfile');\n    var tref, unload_ref;\n    var iframe;\n    var unattach = function() {\n        clearTimeout(tref);\n    };\n    var cleanup = function() {\n        if (doc) {\n            unattach();\n            utils.unload_del(unload_ref);\n            iframe.parentNode.removeChild(iframe);\n            iframe = doc = null;\n            CollectGarbage();\n        }\n    };\n    var onerror = function(r)  {\n        if (doc) {\n            cleanup();\n            error_callback(r);\n        }\n    };\n    var post = function(msg, origin) {\n        try {\n            // When the iframe is not loaded, IE raises an exception\n            // on 'contentWindow'.\n            if (iframe && iframe.contentWindow) {\n                iframe.contentWindow.postMessage(msg, origin);\n            }\n        } catch (x) {};\n    };\n\n    doc.open();\n    doc.write('<html><s' + 'cript>' +\n              'document.domain=\"' + document.domain + '\";' +\n              '</s' + 'cript></html>');\n    doc.close();\n    doc.parentWindow[WPrefix] = _window[WPrefix];\n    var c = doc.createElement('div');\n    doc.body.appendChild(c);\n    iframe = doc.createElement('iframe');\n    c.appendChild(iframe);\n    iframe.src = iframe_url;\n    tref = setTimeout(function(){onerror('timeout');}, 15000);\n    unload_ref = utils.unload_add(cleanup);\n    return {\n        post: post,\n        cleanup: cleanup,\n        loaded: unattach\n    };\n};\n//         [*] End of lib/dom.js\n\n\n//         [*] Including lib/dom2.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar AbstractXHRObject = function(){};\nAbstractXHRObject.prototype = new EventEmitter(['chunk', 'finish']);\n\nAbstractXHRObject.prototype._start = function(method, url, payload, opts) {\n    var that = this;\n\n    try {\n        that.xhr = new XMLHttpRequest();\n    } catch(x) {};\n\n    if (!that.xhr) {\n        try {\n            that.xhr = new _window.ActiveXObject('Microsoft.XMLHTTP');\n        } catch(x) {};\n    }\n    if (_window.ActiveXObject || _window.XDomainRequest) {\n        // IE8 caches even POSTs\n        url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);\n    }\n\n    // Explorer tends to keep connection open, even after the\n    // tab gets closed: http://bugs.jquery.com/ticket/5280\n    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});\n    try {\n        that.xhr.open(method, url, true);\n    } catch(e) {\n        // IE raises an exception on wrong port.\n        that.emit('finish', 0, '');\n        that._cleanup();\n        return;\n    };\n\n    if (!opts || !opts.no_credentials) {\n        // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :\n        // \"This never affects same-site requests.\"\n        that.xhr.withCredentials = 'true';\n    }\n    if (opts && opts.headers) {\n        for(var key in opts.headers) {\n            that.xhr.setRequestHeader(key, opts.headers[key]);\n        }\n    }\n\n    that.xhr.onreadystatechange = function() {\n        if (that.xhr) {\n            var x = that.xhr;\n            switch (x.readyState) {\n            case 3:\n                // IE doesn't like peeking into responseText or status\n                // on Microsoft.XMLHTTP and readystate=3\n                try {\n                    var status = x.status;\n                    var text = x.responseText;\n                } catch (x) {};\n                // IE does return readystate == 3 for 404 answers.\n                if (text && text.length > 0) {\n                    that.emit('chunk', status, text);\n                }\n                break;\n            case 4:\n                that.emit('finish', x.status, x.responseText);\n                that._cleanup(false);\n                break;\n            }\n        }\n    };\n    that.xhr.send(payload);\n};\n\nAbstractXHRObject.prototype._cleanup = function(abort) {\n    var that = this;\n    if (!that.xhr) return;\n    utils.unload_del(that.unload_ref);\n\n    // IE needs this field to be a function\n    that.xhr.onreadystatechange = function(){};\n\n    if (abort) {\n        try {\n            that.xhr.abort();\n        } catch(x) {};\n    }\n    that.unload_ref = that.xhr = null;\n};\n\nAbstractXHRObject.prototype.close = function() {\n    var that = this;\n    that.nuke();\n    that._cleanup(true);\n};\n\nvar XHRCorsObject = utils.XHRCorsObject = function() {\n    var that = this, args = arguments;\n    utils.delay(function(){that._start.apply(that, args);});\n};\nXHRCorsObject.prototype = new AbstractXHRObject();\n\nvar XHRLocalObject = utils.XHRLocalObject = function(method, url, payload) {\n    var that = this;\n    utils.delay(function(){\n        that._start(method, url, payload, {\n            no_credentials: true\n        });\n    });\n};\nXHRLocalObject.prototype = new AbstractXHRObject();\n\n\n\n// References:\n//   http://ajaxian.com/archives/100-line-ajax-wrapper\n//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx\nvar XDRObject = utils.XDRObject = function(method, url, payload) {\n    var that = this;\n    utils.delay(function(){that._start(method, url, payload);});\n};\nXDRObject.prototype = new EventEmitter(['chunk', 'finish']);\nXDRObject.prototype._start = function(method, url, payload) {\n    var that = this;\n    var xdr = new XDomainRequest();\n    // IE caches even POSTs\n    url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);\n\n    var onerror = xdr.ontimeout = xdr.onerror = function() {\n        that.emit('finish', 0, '');\n        that._cleanup(false);\n    };\n    xdr.onprogress = function() {\n        that.emit('chunk', 200, xdr.responseText);\n    };\n    xdr.onload = function() {\n        that.emit('finish', 200, xdr.responseText);\n        that._cleanup(false);\n    };\n    that.xdr = xdr;\n    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});\n    try {\n        // Fails with AccessDenied if port number is bogus\n        that.xdr.open(method, url);\n        that.xdr.send(payload);\n    } catch(x) {\n        onerror();\n    }\n};\n\nXDRObject.prototype._cleanup = function(abort) {\n    var that = this;\n    if (!that.xdr) return;\n    utils.unload_del(that.unload_ref);\n\n    that.xdr.ontimeout = that.xdr.onerror = that.xdr.onprogress =\n        that.xdr.onload = null;\n    if (abort) {\n        try {\n            that.xdr.abort();\n        } catch(x) {};\n    }\n    that.unload_ref = that.xdr = null;\n};\n\nXDRObject.prototype.close = function() {\n    var that = this;\n    that.nuke();\n    that._cleanup(true);\n};\n\n// 1. Is natively via XHR\n// 2. Is natively via XDR\n// 3. Nope, but postMessage is there so it should work via the Iframe.\n// 4. Nope, sorry.\nutils.isXHRCorsCapable = function() {\n    if (_window.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest()) {\n        return 1;\n    }\n    // XDomainRequest doesn't work if page is served from file://\n    if (_window.XDomainRequest && _document.domain) {\n        return 2;\n    }\n    if (IframeTransport.enabled()) {\n        return 3;\n    }\n    return 4;\n};\n//         [*] End of lib/dom2.js\n\n\n//         [*] Including lib/sockjs.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar SockJS = function(url, dep_protocols_whitelist, options) {\n    if (this === window) {\n        // makes `new` optional\n        return new SockJS(url, dep_protocols_whitelist, options);\n    }\n    \n    var that = this, protocols_whitelist;\n    that._options = {devel: false, debug: false, protocols_whitelist: [],\n                     info: undefined, rtt: undefined};\n    if (options) {\n        utils.objectExtend(that._options, options);\n    }\n    that._base_url = utils.amendUrl(url);\n    that._server = that._options.server || utils.random_number_string(1000);\n    if (that._options.protocols_whitelist &&\n        that._options.protocols_whitelist.length) {\n        protocols_whitelist = that._options.protocols_whitelist;\n    } else {\n        // Deprecated API\n        if (typeof dep_protocols_whitelist === 'string' &&\n            dep_protocols_whitelist.length > 0) {\n            protocols_whitelist = [dep_protocols_whitelist];\n        } else if (utils.isArray(dep_protocols_whitelist)) {\n            protocols_whitelist = dep_protocols_whitelist\n        } else {\n            protocols_whitelist = null;\n        }\n        if (protocols_whitelist) {\n            that._debug('Deprecated API: Use \"protocols_whitelist\" option ' +\n                        'instead of supplying protocol list as a second ' +\n                        'parameter to SockJS constructor.');\n        }\n    }\n    that._protocols = [];\n    that.protocol = null;\n    that.readyState = SockJS.CONNECTING;\n    that._ir = createInfoReceiver(that._base_url);\n    that._ir.onfinish = function(info, rtt) {\n        that._ir = null;\n        if (info) {\n            if (that._options.info) {\n                // Override if user supplies the option\n                info = utils.objectExtend(info, that._options.info);\n            }\n            if (that._options.rtt) {\n                rtt = that._options.rtt;\n            }\n            that._applyInfo(info, rtt, protocols_whitelist);\n            that._didClose();\n        } else {\n            that._didClose(1002, 'Can\\'t connect to server', true);\n        }\n    };\n};\n// Inheritance\nSockJS.prototype = new REventTarget();\n\nSockJS.version = \"0.3.1.7.ga67f.dirty\";\n\nSockJS.CONNECTING = 0;\nSockJS.OPEN = 1;\nSockJS.CLOSING = 2;\nSockJS.CLOSED = 3;\n\nSockJS.prototype._debug = function() {\n    if (this._options.debug)\n        utils.log.apply(utils, arguments);\n};\n\nSockJS.prototype._dispatchOpen = function() {\n    var that = this;\n    if (that.readyState === SockJS.CONNECTING) {\n        if (that._transport_tref) {\n            clearTimeout(that._transport_tref);\n            that._transport_tref = null;\n        }\n        that.readyState = SockJS.OPEN;\n        that.dispatchEvent(new SimpleEvent(\"open\"));\n    } else {\n        // The server might have been restarted, and lost track of our\n        // connection.\n        that._didClose(1006, \"Server lost session\");\n    }\n};\n\nSockJS.prototype._dispatchMessage = function(data) {\n    var that = this;\n    if (that.readyState !== SockJS.OPEN)\n            return;\n    that.dispatchEvent(new SimpleEvent(\"message\", {data: data}));\n};\n\nSockJS.prototype._dispatchHeartbeat = function(data) {\n    var that = this;\n    if (that.readyState !== SockJS.OPEN)\n        return;\n    that.dispatchEvent(new SimpleEvent('heartbeat', {}));\n};\n\nSockJS.prototype._didClose = function(code, reason, force) {\n    var that = this;\n    if (that.readyState !== SockJS.CONNECTING &&\n        that.readyState !== SockJS.OPEN &&\n        that.readyState !== SockJS.CLOSING)\n            throw new Error('INVALID_STATE_ERR');\n    if (that._ir) {\n        that._ir.nuke();\n        that._ir = null;\n    }\n\n    if (that._transport) {\n        that._transport.doCleanup();\n        that._transport = null;\n    }\n\n    var close_event = new SimpleEvent(\"close\", {\n        code: code,\n        reason: reason,\n        wasClean: utils.userSetCode(code)});\n\n    if (!utils.userSetCode(code) &&\n        that.readyState === SockJS.CONNECTING && !force) {\n        if (that._try_next_protocol(close_event)) {\n            return;\n        }\n        close_event = new SimpleEvent(\"close\", {code: 2000,\n                                                reason: \"All transports failed\",\n                                                wasClean: false,\n                                                last_event: close_event});\n    }\n    that.readyState = SockJS.CLOSED;\n\n    utils.delay(function() {\n                   that.dispatchEvent(close_event);\n                });\n};\n\nSockJS.prototype._didMessage = function(data) {\n    var that = this;\n    var type = data.slice(0, 1);\n    switch(type) {\n    case 'o':\n        that._dispatchOpen();\n        break;\n    case 'a':\n        var payload = JSON.parse(data.slice(1) || '[]');\n        for(var i=0; i < payload.length; i++){\n            that._dispatchMessage(payload[i]);\n        }\n        break;\n    case 'm':\n        var payload = JSON.parse(data.slice(1) || 'null');\n        that._dispatchMessage(payload);\n        break;\n    case 'c':\n        var payload = JSON.parse(data.slice(1) || '[]');\n        that._didClose(payload[0], payload[1]);\n        break;\n    case 'h':\n        that._dispatchHeartbeat();\n        break;\n    }\n};\n\nSockJS.prototype._try_next_protocol = function(close_event) {\n    var that = this;\n    if (that.protocol) {\n        that._debug('Closed transport:', that.protocol, ''+close_event);\n        that.protocol = null;\n    }\n    if (that._transport_tref) {\n        clearTimeout(that._transport_tref);\n        that._transport_tref = null;\n    }\n\n    while(1) {\n        var protocol = that.protocol = that._protocols.shift();\n        if (!protocol) {\n            return false;\n        }\n        // Some protocols require access to `body`, what if were in\n        // the `head`?\n        if (SockJS[protocol] &&\n            SockJS[protocol].need_body === true &&\n            (!_document.body ||\n             (typeof _document.readyState !== 'undefined'\n              && _document.readyState !== 'complete'))) {\n            that._protocols.unshift(protocol);\n            that.protocol = 'waiting-for-load';\n            utils.attachEvent('load', function(){\n                that._try_next_protocol();\n            });\n            return true;\n        }\n\n        if (!SockJS[protocol] ||\n              !SockJS[protocol].enabled(that._options)) {\n            that._debug('Skipping transport:', protocol);\n        } else {\n            var roundTrips = SockJS[protocol].roundTrips || 1;\n            var to = ((that._options.rto || 0) * roundTrips) || 5000;\n            that._transport_tref = utils.delay(to, function() {\n                if (that.readyState === SockJS.CONNECTING) {\n                    // I can't understand how it is possible to run\n                    // this timer, when the state is CLOSED, but\n                    // apparently in IE everythin is possible.\n                    that._didClose(2007, \"Transport timeouted\");\n                }\n            });\n\n            var connid = utils.random_string(8);\n            var trans_url = that._base_url + '/' + that._server + '/' + connid;\n            that._debug('Opening transport:', protocol, ' url:'+trans_url,\n                        ' RTO:'+that._options.rto);\n            that._transport = new SockJS[protocol](that, trans_url,\n                                                   that._base_url);\n            return true;\n        }\n    }\n};\n\nSockJS.prototype.close = function(code, reason) {\n    var that = this;\n    if (code && !utils.userSetCode(code))\n        throw new Error(\"INVALID_ACCESS_ERR\");\n    if(that.readyState !== SockJS.CONNECTING &&\n       that.readyState !== SockJS.OPEN) {\n        return false;\n    }\n    that.readyState = SockJS.CLOSING;\n    that._didClose(code || 1000, reason || \"Normal closure\");\n    return true;\n};\n\nSockJS.prototype.send = function(data) {\n    var that = this;\n    if (that.readyState === SockJS.CONNECTING)\n        throw new Error('INVALID_STATE_ERR');\n    if (that.readyState === SockJS.OPEN) {\n        that._transport.doSend(utils.quote('' + data));\n    }\n    return true;\n};\n\nSockJS.prototype._applyInfo = function(info, rtt, protocols_whitelist) {\n    var that = this;\n    that._options.info = info;\n    that._options.rtt = rtt;\n    that._options.rto = utils.countRTO(rtt);\n    that._options.info.null_origin = !_document.domain;\n    var probed = utils.probeProtocols();\n    that._protocols = utils.detectProtocols(probed, protocols_whitelist, info);\n};\n//         [*] End of lib/sockjs.js\n\n\n//         [*] Including lib/trans-websocket.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar WebSocketTransport = SockJS.websocket = function(ri, trans_url) {\n    var that = this;\n    var url = trans_url + '/websocket';\n    if (url.slice(0, 5) === 'https') {\n        url = 'wss' + url.slice(5);\n    } else {\n        url = 'ws' + url.slice(4);\n    }\n    that.ri = ri;\n    that.url = url;\n    var Constructor = _window.WebSocket || _window.MozWebSocket;\n\n    that.ws = new Constructor(that.url);\n    that.ws.onmessage = function(e) {\n        that.ri._didMessage(e.data);\n    };\n    // Firefox has an interesting bug. If a websocket connection is\n    // created after onbeforeunload, it stays alive even when user\n    // navigates away from the page. In such situation let's lie -\n    // let's not open the ws connection at all. See:\n    // https://github.com/sockjs/sockjs-client/issues/28\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=696085\n    that.unload_ref = utils.unload_add(function(){that.ws.close()});\n    that.ws.onclose = function() {\n        that.ri._didMessage(utils.closeFrame(1006, \"WebSocket connection broken\"));\n    };\n};\n\nWebSocketTransport.prototype.doSend = function(data) {\n    this.ws.send('[' + data + ']');\n};\n\nWebSocketTransport.prototype.doCleanup = function() {\n    var that = this;\n    var ws = that.ws;\n    if (ws) {\n        ws.onmessage = ws.onclose = null;\n        ws.close();\n        utils.unload_del(that.unload_ref);\n        that.unload_ref = that.ri = that.ws = null;\n    }\n};\n\nWebSocketTransport.enabled = function() {\n    return !!(_window.WebSocket || _window.MozWebSocket);\n};\n\n// In theory, ws should require 1 round trip. But in chrome, this is\n// not very stable over SSL. Most likely a ws connection requires a\n// separate SSL connection, in which case 2 round trips are an\n// absolute minumum.\nWebSocketTransport.roundTrips = 2;\n//         [*] End of lib/trans-websocket.js\n\n\n//         [*] Including lib/trans-sender.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar BufferedSender = function() {};\nBufferedSender.prototype.send_constructor = function(sender) {\n    var that = this;\n    that.send_buffer = [];\n    that.sender = sender;\n};\nBufferedSender.prototype.doSend = function(message) {\n    var that = this;\n    that.send_buffer.push(message);\n    if (!that.send_stop) {\n        that.send_schedule();\n    }\n};\n\n// For polling transports in a situation when in the message callback,\n// new message is being send. If the sending connection was started\n// before receiving one, it is possible to saturate the network and\n// timeout due to the lack of receiving socket. To avoid that we delay\n// sending messages by some small time, in order to let receiving\n// connection be started beforehand. This is only a halfmeasure and\n// does not fix the big problem, but it does make the tests go more\n// stable on slow networks.\nBufferedSender.prototype.send_schedule_wait = function() {\n    var that = this;\n    var tref;\n    that.send_stop = function() {\n        that.send_stop = null;\n        clearTimeout(tref);\n    };\n    tref = utils.delay(25, function() {\n        that.send_stop = null;\n        that.send_schedule();\n    });\n};\n\nBufferedSender.prototype.send_schedule = function() {\n    var that = this;\n    if (that.send_buffer.length > 0) {\n        var payload = '[' + that.send_buffer.join(',') + ']';\n        that.send_stop = that.sender(that.trans_url,\n                                     payload,\n                                     function() {\n                                         that.send_stop = null;\n                                         that.send_schedule_wait();\n                                     });\n        that.send_buffer = [];\n    }\n};\n\nBufferedSender.prototype.send_destructor = function() {\n    var that = this;\n    if (that._send_stop) {\n        that._send_stop();\n    }\n    that._send_stop = null;\n};\n\nvar jsonPGenericSender = function(url, payload, callback) {\n    var that = this;\n\n    if (!('_send_form' in that)) {\n        var form = that._send_form = _document.createElement('form');\n        var area = that._send_area = _document.createElement('textarea');\n        area.name = 'd';\n        form.style.display = 'none';\n        form.style.position = 'absolute';\n        form.method = 'POST';\n        form.enctype = 'application/x-www-form-urlencoded';\n        form.acceptCharset = \"UTF-8\";\n        form.appendChild(area);\n        _document.body.appendChild(form);\n    }\n    var form = that._send_form;\n    var area = that._send_area;\n    var id = 'a' + utils.random_string(8);\n    form.target = id;\n    form.action = url + '/jsonp_send?i=' + id;\n\n    var iframe;\n    try {\n        // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n        iframe = _document.createElement('<iframe name=\"'+ id +'\">');\n    } catch(x) {\n        iframe = _document.createElement('iframe');\n        iframe.name = id;\n    }\n    iframe.id = id;\n    form.appendChild(iframe);\n    iframe.style.display = 'none';\n\n    try {\n        area.value = payload;\n    } catch(e) {\n        utils.log('Your browser is seriously broken. Go home! ' + e.message);\n    }\n    form.submit();\n\n    var completed = function(e) {\n        if (!iframe.onerror) return;\n        iframe.onreadystatechange = iframe.onerror = iframe.onload = null;\n        // Opera mini doesn't like if we GC iframe\n        // immediately, thus this timeout.\n        utils.delay(500, function() {\n                       iframe.parentNode.removeChild(iframe);\n                       iframe = null;\n                   });\n        area.value = '';\n        callback();\n    };\n    iframe.onerror = iframe.onload = completed;\n    iframe.onreadystatechange = function(e) {\n        if (iframe.readyState == 'complete') completed();\n    };\n    return completed;\n};\n\nvar createAjaxSender = function(AjaxObject) {\n    return function(url, payload, callback) {\n        var xo = new AjaxObject('POST', url + '/xhr_send', payload);\n        xo.onfinish = function(status, text) {\n            callback(status);\n        };\n        return function(abort_reason) {\n            callback(0, abort_reason);\n        };\n    };\n};\n//         [*] End of lib/trans-sender.js\n\n\n//         [*] Including lib/trans-jsonp-receiver.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n// Parts derived from Socket.io:\n//    https://github.com/LearnBoost/socket.io/blob/0.6.17/lib/socket.io/transports/jsonp-polling.js\n// and jQuery-JSONP:\n//    https://code.google.com/p/jquery-jsonp/source/browse/trunk/core/jquery.jsonp.js\nvar jsonPGenericReceiver = function(url, callback) {\n    var tref;\n    var script = _document.createElement('script');\n    var script2;  // Opera synchronous load trick.\n    var close_script = function(frame) {\n        if (script2) {\n            script2.parentNode.removeChild(script2);\n            script2 = null;\n        }\n        if (script) {\n            clearTimeout(tref);\n            script.parentNode.removeChild(script);\n            script.onreadystatechange = script.onerror =\n                script.onload = script.onclick = null;\n            script = null;\n            callback(frame);\n            callback = null;\n        }\n    };\n\n    // IE9 fires 'error' event after orsc or before, in random order.\n    var loaded_okay = false;\n    var error_timer = null;\n\n    script.id = 'a' + utils.random_string(8);\n    script.src = url;\n    script.type = 'text/javascript';\n    script.charset = 'UTF-8';\n    script.onerror = function(e) {\n        if (!error_timer) {\n            // Delay firing close_script.\n            error_timer = setTimeout(function() {\n                if (!loaded_okay) {\n                    close_script(utils.closeFrame(\n                        1006,\n                        \"JSONP script loaded abnormally (onerror)\"));\n                }\n            }, 1000);\n        }\n    };\n    script.onload = function(e) {\n        close_script(utils.closeFrame(1006, \"JSONP script loaded abnormally (onload)\"));\n    };\n\n    script.onreadystatechange = function(e) {\n        if (/loaded|closed/.test(script.readyState)) {\n            if (script && script.htmlFor && script.onclick) {\n                loaded_okay = true;\n                try {\n                    // In IE, actually execute the script.\n                    script.onclick();\n                } catch (x) {}\n            }\n            if (script) {\n                close_script(utils.closeFrame(1006, \"JSONP script loaded abnormally (onreadystatechange)\"));\n            }\n        }\n    };\n    // IE: event/htmlFor/onclick trick.\n    // One can't rely on proper order for onreadystatechange. In order to\n    // make sure, set a 'htmlFor' and 'event' properties, so that\n    // script code will be installed as 'onclick' handler for the\n    // script object. Later, onreadystatechange, manually execute this\n    // code. FF and Chrome doesn't work with 'event' and 'htmlFor'\n    // set. For reference see:\n    //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html\n    // Also, read on that about script ordering:\n    //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order\n    if (typeof script.async === 'undefined' && _document.attachEvent) {\n        // According to mozilla docs, in recent browsers script.async defaults\n        // to 'true', so we may use it to detect a good browser:\n        // https://developer.mozilla.org/en/HTML/Element/script\n        if (!/opera/i.test(navigator.userAgent)) {\n            // Naively assume we're in IE\n            try {\n                script.htmlFor = script.id;\n                script.event = \"onclick\";\n            } catch (x) {}\n            script.async = true;\n        } else {\n            // Opera, second sync script hack\n            script2 = _document.createElement('script');\n            script2.text = \"try{var a = document.getElementById('\"+script.id+\"'); if(a)a.onerror();}catch(x){};\";\n            script.async = script2.async = false;\n        }\n    }\n    if (typeof script.async !== 'undefined') {\n        script.async = true;\n    }\n\n    // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.\n    tref = setTimeout(function() {\n                          close_script(utils.closeFrame(1006, \"JSONP script loaded abnormally (timeout)\"));\n                      }, 35000);\n\n    var head = _document.getElementsByTagName('head')[0];\n    head.insertBefore(script, head.firstChild);\n    if (script2) {\n        head.insertBefore(script2, head.firstChild);\n    }\n    return close_script;\n};\n//         [*] End of lib/trans-jsonp-receiver.js\n\n\n//         [*] Including lib/trans-jsonp-polling.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n// The simplest and most robust transport, using the well-know cross\n// domain hack - JSONP. This transport is quite inefficient - one\n// mssage could use up to one http request. But at least it works almost\n// everywhere.\n// Known limitations:\n//   o you will get a spinning cursor\n//   o for Konqueror a dumb timer is needed to detect errors\n\n\nvar JsonPTransport = SockJS['jsonp-polling'] = function(ri, trans_url) {\n    utils.polluteGlobalNamespace();\n    var that = this;\n    that.ri = ri;\n    that.trans_url = trans_url;\n    that.send_constructor(jsonPGenericSender);\n    that._schedule_recv();\n};\n\n// Inheritnace\nJsonPTransport.prototype = new BufferedSender();\n\nJsonPTransport.prototype._schedule_recv = function() {\n    var that = this;\n    var callback = function(data) {\n        that._recv_stop = null;\n        if (data) {\n            // no data - heartbeat;\n            if (!that._is_closing) {\n                that.ri._didMessage(data);\n            }\n        }\n        // The message can be a close message, and change is_closing state.\n        if (!that._is_closing) {\n            that._schedule_recv();\n        }\n    };\n    that._recv_stop = jsonPReceiverWrapper(that.trans_url + '/jsonp',\n                                           jsonPGenericReceiver, callback);\n};\n\nJsonPTransport.enabled = function() {\n    return true;\n};\n\nJsonPTransport.need_body = true;\n\n\nJsonPTransport.prototype.doCleanup = function() {\n    var that = this;\n    that._is_closing = true;\n    if (that._recv_stop) {\n        that._recv_stop();\n    }\n    that.ri = that._recv_stop = null;\n    that.send_destructor();\n};\n\n\n// Abstract away code that handles global namespace pollution.\nvar jsonPReceiverWrapper = function(url, constructReceiver, user_callback) {\n    var id = 'a' + utils.random_string(6);\n    var url_id = url + '?c=' + escape(WPrefix + '.' + id);\n    // Callback will be called exactly once.\n    var callback = function(frame) {\n        delete _window[WPrefix][id];\n        user_callback(frame);\n    };\n\n    var close_script = constructReceiver(url_id, callback);\n    _window[WPrefix][id] = close_script;\n    var stop = function() {\n        if (_window[WPrefix][id]) {\n            _window[WPrefix][id](utils.closeFrame(1000, \"JSONP user aborted read\"));\n        }\n    };\n    return stop;\n};\n//         [*] End of lib/trans-jsonp-polling.js\n\n\n//         [*] Including lib/trans-xhr.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar AjaxBasedTransport = function() {};\nAjaxBasedTransport.prototype = new BufferedSender();\n\nAjaxBasedTransport.prototype.run = function(ri, trans_url,\n                                            url_suffix, Receiver, AjaxObject) {\n    var that = this;\n    that.ri = ri;\n    that.trans_url = trans_url;\n    that.send_constructor(createAjaxSender(AjaxObject));\n    that.poll = new Polling(ri, Receiver,\n                            trans_url + url_suffix, AjaxObject);\n};\n\nAjaxBasedTransport.prototype.doCleanup = function() {\n    var that = this;\n    if (that.poll) {\n        that.poll.abort();\n        that.poll = null;\n    }\n};\n\n// xhr-streaming\nvar XhrStreamingTransport = SockJS['xhr-streaming'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XHRCorsObject);\n};\n\nXhrStreamingTransport.prototype = new AjaxBasedTransport();\n\nXhrStreamingTransport.enabled = function() {\n    // Support for CORS Ajax aka Ajax2? Opera 12 claims CORS but\n    // doesn't do streaming.\n    return (_window.XMLHttpRequest &&\n            'withCredentials' in new XMLHttpRequest() &&\n            (!/opera/i.test(navigator.userAgent)));\n};\nXhrStreamingTransport.roundTrips = 2; // preflight, ajax\n\n// Safari gets confused when a streaming ajax request is started\n// before onload. This causes the load indicator to spin indefinetely.\nXhrStreamingTransport.need_body = true;\n\n\n// According to:\n//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests\n//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/\n\n\n// xdr-streaming\nvar XdrStreamingTransport = SockJS['xdr-streaming'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XDRObject);\n};\n\nXdrStreamingTransport.prototype = new AjaxBasedTransport();\n\nXdrStreamingTransport.enabled = function() {\n    return !!_window.XDomainRequest;\n};\nXdrStreamingTransport.roundTrips = 2; // preflight, ajax\n\n\n\n// xhr-polling\nvar XhrPollingTransport = SockJS['xhr-polling'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRCorsObject);\n};\n\nXhrPollingTransport.prototype = new AjaxBasedTransport();\n\nXhrPollingTransport.enabled = XhrStreamingTransport.enabled;\nXhrPollingTransport.roundTrips = 2; // preflight, ajax\n\n\n// xdr-polling\nvar XdrPollingTransport = SockJS['xdr-polling'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XDRObject);\n};\n\nXdrPollingTransport.prototype = new AjaxBasedTransport();\n\nXdrPollingTransport.enabled = XdrStreamingTransport.enabled;\nXdrPollingTransport.roundTrips = 2; // preflight, ajax\n//         [*] End of lib/trans-xhr.js\n\n\n//         [*] Including lib/trans-iframe.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n// Few cool transports do work only for same-origin. In order to make\n// them working cross-domain we shall use iframe, served form the\n// remote domain. New browsers, have capabilities to communicate with\n// cross domain iframe, using postMessage(). In IE it was implemented\n// from IE 8+, but of course, IE got some details wrong:\n//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx\n//    http://stevesouders.com/misc/test-postmessage.php\n\nvar IframeTransport = function() {};\n\nIframeTransport.prototype.i_constructor = function(ri, trans_url, base_url) {\n    var that = this;\n    that.ri = ri;\n    that.origin = utils.getOrigin(base_url);\n    that.base_url = base_url;\n    that.trans_url = trans_url;\n\n    var iframe_url = base_url + '/iframe.html';\n    if (that.ri._options.devel) {\n        iframe_url += '?t=' + (+new Date);\n    }\n    that.window_id = utils.random_string(8);\n    iframe_url += '#' + that.window_id;\n\n    that.iframeObj = utils.createIframe(iframe_url, function(r) {\n                                            that.ri._didClose(1006, \"Unable to load an iframe (\" + r + \")\");\n                                        });\n\n    that.onmessage_cb = utils.bind(that.onmessage, that);\n    utils.attachMessage(that.onmessage_cb);\n};\n\nIframeTransport.prototype.doCleanup = function() {\n    var that = this;\n    if (that.iframeObj) {\n        utils.detachMessage(that.onmessage_cb);\n        try {\n            // When the iframe is not loaded, IE raises an exception\n            // on 'contentWindow'.\n            if (that.iframeObj.iframe.contentWindow) {\n                that.postMessage('c');\n            }\n        } catch (x) {}\n        that.iframeObj.cleanup();\n        that.iframeObj = null;\n        that.onmessage_cb = that.iframeObj = null;\n    }\n};\n\nIframeTransport.prototype.onmessage = function(e) {\n    var that = this;\n    if (e.origin !== that.origin) return;\n    var window_id = e.data.slice(0, 8);\n    var type = e.data.slice(8, 9);\n    var data = e.data.slice(9);\n\n    if (window_id !== that.window_id) return;\n\n    switch(type) {\n    case 's':\n        that.iframeObj.loaded();\n        that.postMessage('s', JSON.stringify([SockJS.version, that.protocol, that.trans_url, that.base_url]));\n        break;\n    case 't':\n        that.ri._didMessage(data);\n        break;\n    }\n};\n\nIframeTransport.prototype.postMessage = function(type, data) {\n    var that = this;\n    that.iframeObj.post(that.window_id + type + (data || ''), that.origin);\n};\n\nIframeTransport.prototype.doSend = function (message) {\n    this.postMessage('m', message);\n};\n\nIframeTransport.enabled = function() {\n    // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with\n    // huge delay, or not at all.\n    var konqueror = navigator && navigator.userAgent && navigator.userAgent.indexOf('Konqueror') !== -1;\n    return ((typeof _window.postMessage === 'function' ||\n            typeof _window.postMessage === 'object') && (!konqueror));\n};\n//         [*] End of lib/trans-iframe.js\n\n\n//         [*] Including lib/trans-iframe-within.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar curr_window_id;\n\nvar postMessage = function (type, data) {\n    if(parent !== _window) {\n        parent.postMessage(curr_window_id + type + (data || ''), '*');\n    } else {\n        utils.log(\"Can't postMessage, no parent window.\", type, data);\n    }\n};\n\nvar FacadeJS = function() {};\nFacadeJS.prototype._didClose = function (code, reason) {\n    postMessage('t', utils.closeFrame(code, reason));\n};\nFacadeJS.prototype._didMessage = function (frame) {\n    postMessage('t', frame);\n};\nFacadeJS.prototype._doSend = function (data) {\n    this._transport.doSend(data);\n};\nFacadeJS.prototype._doCleanup = function () {\n    this._transport.doCleanup();\n};\n\nutils.parent_origin = undefined;\n\nSockJS.bootstrap_iframe = function() {\n    var facade;\n    curr_window_id = _document.location.hash.slice(1);\n    var onMessage = function(e) {\n        if(e.source !== parent) return;\n        if(typeof utils.parent_origin === 'undefined')\n            utils.parent_origin = e.origin;\n        if (e.origin !== utils.parent_origin) return;\n\n        var window_id = e.data.slice(0, 8);\n        var type = e.data.slice(8, 9);\n        var data = e.data.slice(9);\n        if (window_id !== curr_window_id) return;\n        switch(type) {\n        case 's':\n            var p = JSON.parse(data);\n            var version = p[0];\n            var protocol = p[1];\n            var trans_url = p[2];\n            var base_url = p[3];\n            if (version !== SockJS.version) {\n                utils.log(\"Incompatibile SockJS! Main site uses:\" +\n                          \" \\\"\" + version + \"\\\", the iframe:\" +\n                          \" \\\"\" + SockJS.version + \"\\\".\");\n            }\n            if (!utils.flatUrl(trans_url) || !utils.flatUrl(base_url)) {\n                utils.log(\"Only basic urls are supported in SockJS\");\n                return;\n            }\n\n            if (!utils.isSameOriginUrl(trans_url) ||\n                !utils.isSameOriginUrl(base_url)) {\n                utils.log(\"Can't connect to different domain from within an \" +\n                          \"iframe. (\" + JSON.stringify([_window.location.href, trans_url, base_url]) +\n                          \")\");\n                return;\n            }\n            facade = new FacadeJS();\n            facade._transport = new FacadeJS[protocol](facade, trans_url, base_url);\n            break;\n        case 'm':\n            facade._doSend(data);\n            break;\n        case 'c':\n            if (facade)\n                facade._doCleanup();\n            facade = null;\n            break;\n        }\n    };\n\n    // alert('test ticker');\n    // facade = new FacadeJS();\n    // facade._transport = new FacadeJS['w-iframe-xhr-polling'](facade, 'http://host.com:9999/ticker/12/basd');\n\n    utils.attachMessage(onMessage);\n\n    // Start\n    postMessage('s');\n};\n//         [*] End of lib/trans-iframe-within.js\n\n\n//         [*] Including lib/info.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar InfoReceiver = function(base_url, AjaxObject) {\n    var that = this;\n    utils.delay(function(){that.doXhr(base_url, AjaxObject);});\n};\n\nInfoReceiver.prototype = new EventEmitter(['finish']);\n\nInfoReceiver.prototype.doXhr = function(base_url, AjaxObject) {\n    var that = this;\n    var t0 = (new Date()).getTime();\n    var xo = new AjaxObject('GET', base_url + '/info');\n\n    var tref = utils.delay(8000,\n                           function(){xo.ontimeout();});\n\n    xo.onfinish = function(status, text) {\n        clearTimeout(tref);\n        tref = null;\n        if (status === 200) {\n            var rtt = (new Date()).getTime() - t0;\n            var info = JSON.parse(text);\n            if (typeof info !== 'object') info = {};\n            that.emit('finish', info, rtt);\n        } else {\n            that.emit('finish');\n        }\n    };\n    xo.ontimeout = function() {\n        xo.close();\n        that.emit('finish');\n    };\n};\n\nvar InfoReceiverIframe = function(base_url) {\n    var that = this;\n    var go = function() {\n        var ifr = new IframeTransport();\n        ifr.protocol = 'w-iframe-info-receiver';\n        var fun = function(r) {\n            if (typeof r === 'string' && r.substr(0,1) === 'm') {\n                var d = JSON.parse(r.substr(1));\n                var info = d[0], rtt = d[1];\n                that.emit('finish', info, rtt);\n            } else {\n                that.emit('finish');\n            }\n            ifr.doCleanup();\n            ifr = null;\n        };\n        var mock_ri = {\n            _options: {},\n            _didClose: fun,\n            _didMessage: fun\n        };\n        ifr.i_constructor(mock_ri, base_url, base_url);\n    }\n    if(!_document.body) {\n        utils.attachEvent('load', go);\n    } else {\n        go();\n    }\n};\nInfoReceiverIframe.prototype = new EventEmitter(['finish']);\n\n\nvar InfoReceiverFake = function() {\n    // It may not be possible to do cross domain AJAX to get the info\n    // data, for example for IE7. But we want to run JSONP, so let's\n    // fake the response, with rtt=2s (rto=6s).\n    var that = this;\n    utils.delay(function() {\n        that.emit('finish', {}, 2000);\n    });\n};\nInfoReceiverFake.prototype = new EventEmitter(['finish']);\n\nvar createInfoReceiver = function(base_url) {\n    if (utils.isSameOriginUrl(base_url)) {\n        // If, for some reason, we have SockJS locally - there's no\n        // need to start up the complex machinery. Just use ajax.\n        return new InfoReceiver(base_url, utils.XHRLocalObject);\n    }\n    switch (utils.isXHRCorsCapable()) {\n    case 1:\n        return new InfoReceiver(base_url, utils.XHRCorsObject);\n    case 2:\n        return new InfoReceiver(base_url, utils.XDRObject);\n    case 3:\n        // Opera\n        return new InfoReceiverIframe(base_url);\n    default:\n        // IE 7\n        return new InfoReceiverFake();\n    };\n};\n\n\nvar WInfoReceiverIframe = FacadeJS['w-iframe-info-receiver'] = function(ri, _trans_url, base_url) {\n    var ir = new InfoReceiver(base_url, utils.XHRLocalObject);\n    ir.onfinish = function(info, rtt) {\n        ri._didMessage('m'+JSON.stringify([info, rtt]));\n        ri._didClose();\n    }\n};\nWInfoReceiverIframe.prototype.doCleanup = function() {};\n//         [*] End of lib/info.js\n\n\n//         [*] Including lib/trans-iframe-eventsource.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar EventSourceIframeTransport = SockJS['iframe-eventsource'] = function () {\n    var that = this;\n    that.protocol = 'w-iframe-eventsource';\n    that.i_constructor.apply(that, arguments);\n};\n\nEventSourceIframeTransport.prototype = new IframeTransport();\n\nEventSourceIframeTransport.enabled = function () {\n    return ('EventSource' in _window) && IframeTransport.enabled();\n};\n\nEventSourceIframeTransport.need_body = true;\nEventSourceIframeTransport.roundTrips = 3; // html, javascript, eventsource\n\n\n// w-iframe-eventsource\nvar EventSourceTransport = FacadeJS['w-iframe-eventsource'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/eventsource', EventSourceReceiver, utils.XHRLocalObject);\n}\nEventSourceTransport.prototype = new AjaxBasedTransport();\n//         [*] End of lib/trans-iframe-eventsource.js\n\n\n//         [*] Including lib/trans-iframe-xhr-polling.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar XhrPollingIframeTransport = SockJS['iframe-xhr-polling'] = function () {\n    var that = this;\n    that.protocol = 'w-iframe-xhr-polling';\n    that.i_constructor.apply(that, arguments);\n};\n\nXhrPollingIframeTransport.prototype = new IframeTransport();\n\nXhrPollingIframeTransport.enabled = function () {\n    return _window.XMLHttpRequest && IframeTransport.enabled();\n};\n\nXhrPollingIframeTransport.need_body = true;\nXhrPollingIframeTransport.roundTrips = 3; // html, javascript, xhr\n\n\n// w-iframe-xhr-polling\nvar XhrPollingITransport = FacadeJS['w-iframe-xhr-polling'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRLocalObject);\n};\n\nXhrPollingITransport.prototype = new AjaxBasedTransport();\n//         [*] End of lib/trans-iframe-xhr-polling.js\n\n\n//         [*] Including lib/trans-iframe-htmlfile.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n// This transport generally works in any browser, but will cause a\n// spinning cursor to appear in any browser other than IE.\n// We may test this transport in all browsers - why not, but in\n// production it should be only run in IE.\n\nvar HtmlFileIframeTransport = SockJS['iframe-htmlfile'] = function () {\n    var that = this;\n    that.protocol = 'w-iframe-htmlfile';\n    that.i_constructor.apply(that, arguments);\n};\n\n// Inheritance.\nHtmlFileIframeTransport.prototype = new IframeTransport();\n\nHtmlFileIframeTransport.enabled = function() {\n    return IframeTransport.enabled();\n};\n\nHtmlFileIframeTransport.need_body = true;\nHtmlFileIframeTransport.roundTrips = 3; // html, javascript, htmlfile\n\n\n// w-iframe-htmlfile\nvar HtmlFileTransport = FacadeJS['w-iframe-htmlfile'] = function(ri, trans_url) {\n    this.run(ri, trans_url, '/htmlfile', HtmlfileReceiver, utils.XHRLocalObject);\n};\nHtmlFileTransport.prototype = new AjaxBasedTransport();\n//         [*] End of lib/trans-iframe-htmlfile.js\n\n\n//         [*] Including lib/trans-polling.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar Polling = function(ri, Receiver, recv_url, AjaxObject) {\n    var that = this;\n    that.ri = ri;\n    that.Receiver = Receiver;\n    that.recv_url = recv_url;\n    that.AjaxObject = AjaxObject;\n    that._scheduleRecv();\n};\n\nPolling.prototype._scheduleRecv = function() {\n    var that = this;\n    var poll = that.poll = new that.Receiver(that.recv_url, that.AjaxObject);\n    var msg_counter = 0;\n    poll.onmessage = function(e) {\n        msg_counter += 1;\n        that.ri._didMessage(e.data);\n    };\n    poll.onclose = function(e) {\n        that.poll = poll = poll.onmessage = poll.onclose = null;\n        if (!that.poll_is_closing) {\n            if (e.reason === 'permanent') {\n                that.ri._didClose(1006, 'Polling error (' + e.reason + ')');\n            } else {\n                that._scheduleRecv();\n            }\n        }\n    };\n};\n\nPolling.prototype.abort = function() {\n    var that = this;\n    that.poll_is_closing = true;\n    if (that.poll) {\n        that.poll.abort();\n    }\n};\n//         [*] End of lib/trans-polling.js\n\n\n//         [*] Including lib/trans-receiver-eventsource.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar EventSourceReceiver = function(url) {\n    var that = this;\n    var es = new EventSource(url);\n    es.onmessage = function(e) {\n        that.dispatchEvent(new SimpleEvent('message',\n                                           {'data': unescape(e.data)}));\n    };\n    that.es_close = es.onerror = function(e, abort_reason) {\n        // ES on reconnection has readyState = 0 or 1.\n        // on network error it's CLOSED = 2\n        var reason = abort_reason ? 'user' :\n            (es.readyState !== 2 ? 'network' : 'permanent');\n        that.es_close = es.onmessage = es.onerror = null;\n        // EventSource reconnects automatically.\n        es.close();\n        es = null;\n        // Safari and chrome < 15 crash if we close window before\n        // waiting for ES cleanup. See:\n        //   https://code.google.com/p/chromium/issues/detail?id=89155\n        utils.delay(200, function() {\n                        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));\n                    });\n    };\n};\n\nEventSourceReceiver.prototype = new REventTarget();\n\nEventSourceReceiver.prototype.abort = function() {\n    var that = this;\n    if (that.es_close) {\n        that.es_close({}, true);\n    }\n};\n//         [*] End of lib/trans-receiver-eventsource.js\n\n\n//         [*] Including lib/trans-receiver-htmlfile.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar _is_ie_htmlfile_capable;\nvar isIeHtmlfileCapable = function() {\n    if (_is_ie_htmlfile_capable === undefined) {\n        if ('ActiveXObject' in _window) {\n            try {\n                _is_ie_htmlfile_capable = !!new ActiveXObject('htmlfile');\n            } catch (x) {}\n        } else {\n            _is_ie_htmlfile_capable = false;\n        }\n    }\n    return _is_ie_htmlfile_capable;\n};\n\n\nvar HtmlfileReceiver = function(url) {\n    var that = this;\n    utils.polluteGlobalNamespace();\n\n    that.id = 'a' + utils.random_string(6, 26);\n    url += ((url.indexOf('?') === -1) ? '?' : '&') +\n        'c=' + escape(WPrefix + '.' + that.id);\n\n    var constructor = isIeHtmlfileCapable() ?\n        utils.createHtmlfile : utils.createIframe;\n\n    var iframeObj;\n    _window[WPrefix][that.id] = {\n        start: function () {\n            iframeObj.loaded();\n        },\n        message: function (data) {\n            that.dispatchEvent(new SimpleEvent('message', {'data': data}));\n        },\n        stop: function () {\n            that.iframe_close({}, 'network');\n        }\n    };\n    that.iframe_close = function(e, abort_reason) {\n        iframeObj.cleanup();\n        that.iframe_close = iframeObj = null;\n        delete _window[WPrefix][that.id];\n        that.dispatchEvent(new SimpleEvent('close', {reason: abort_reason}));\n    };\n    iframeObj = constructor(url, function(e) {\n                                that.iframe_close({}, 'permanent');\n                            });\n};\n\nHtmlfileReceiver.prototype = new REventTarget();\n\nHtmlfileReceiver.prototype.abort = function() {\n    var that = this;\n    if (that.iframe_close) {\n        that.iframe_close({}, 'user');\n    }\n};\n//         [*] End of lib/trans-receiver-htmlfile.js\n\n\n//         [*] Including lib/trans-receiver-xhr.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\nvar XhrReceiver = function(url, AjaxObject) {\n    var that = this;\n    var buf_pos = 0;\n\n    that.xo = new AjaxObject('POST', url, null);\n    that.xo.onchunk = function(status, text) {\n        if (status !== 200) return;\n        while (1) {\n            var buf = text.slice(buf_pos);\n            var p = buf.indexOf('\\n');\n            if (p === -1) break;\n            buf_pos += p+1;\n            var msg = buf.slice(0, p);\n            that.dispatchEvent(new SimpleEvent('message', {data: msg}));\n        }\n    };\n    that.xo.onfinish = function(status, text) {\n        that.xo.onchunk(status, text);\n        that.xo = null;\n        var reason = status === 200 ? 'network' : 'permanent';\n        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));\n    }\n};\n\nXhrReceiver.prototype = new REventTarget();\n\nXhrReceiver.prototype.abort = function() {\n    var that = this;\n    if (that.xo) {\n        that.xo.close();\n        that.dispatchEvent(new SimpleEvent('close', {reason: 'user'}));\n        that.xo = null;\n    }\n};\n//         [*] End of lib/trans-receiver-xhr.js\n\n\n//         [*] Including lib/test-hooks.js\n/*\n * ***** BEGIN LICENSE BLOCK *****\n * Copyright (c) 2011-2012 VMware, Inc.\n *\n * For the license see COPYING.\n * ***** END LICENSE BLOCK *****\n */\n\n// For testing\nSockJS.getUtils = function(){\n    return utils;\n};\n\nSockJS.getIframeTransport = function(){\n    return IframeTransport;\n};\n//         [*] End of lib/test-hooks.js\n\n                  return SockJS;\n          })();\nif ('_sockjs_onload' in window) setTimeout(_sockjs_onload, 1);\n\n// AMD compliance\nif (typeof define === 'function' && define.amd) {\n    define('sockjs', [], function(){return SockJS;});\n}\n\nif (typeof module === 'object' && module && module.exports) {\n    module.exports = SockJS;\n}\n//     [*] End of lib/index.js\n\n// [*] End of lib/all.js\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/shoe/node_modules/sockjs-client/sockjs.js"
));

require.define("/node_modules/rumours/node_modules/reconnect/inject.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var EventEmitter = require('events').EventEmitter\nvar backoff = require('backoff')\n\nmodule.exports =\nfunction (createConnection) {\n  return function (opts, onConnect) {\n    onConnect = 'function' == typeof opts ? opts : onConnect\n    opts = opts || {initialDelay: 1e3, maxDelay: 30e3}\n    if(!onConnect)\n      onConnect = opts.onConnect\n\n    var emitter = new EventEmitter()\n    emitter.connected = false\n    emitter.reconnect = true\n\n    if(onConnect)\n      emitter.on('connect', onConnect)\n\n    var backoffMethod = (backoff[opts.type] || backoff.fibonacci) (opts)\n\n    backoffMethod.on('backoff', function (n, d) {\n      emitter.emit('backoff', n, d)\n    })\n\n    var args\n    function attempt (n, delay) {\n      if(emitter.connected) return\n      if(!emitter.reconnect) return\n\n      emitter.emit('reconnect', n, delay)\n      var con = createConnection.apply(null, args)\n      emitter._connection = con\n      \n      function onDisconnect () {\n        emitter.connected = false\n        con.removeListener('error', onDisconnect)\n        con.removeListener('close', onDisconnect)\n        con.removeListener('end'  , onDisconnect)\n\n        //hack to make http not crash.\n        //HTTP IS THE WORST PROTOCOL.\n        if(con.constructor.name == 'Request')\n          con.on('error', function () {})\n\n        //emit disconnect before checking reconnect, so user has a chance to decide not to.\n        emitter.emit('disconnect', con)\n\n        if(!emitter.reconnect) return\n        backoffMethod.backoff()\n      }\n\n      con\n        .on('error', onDisconnect)\n        .on('close', onDisconnect)\n        .on('end'  , onDisconnect)\n\n      if(con.constructor.name == 'Request') {\n        emitter.connected = true\n        emitter.emit('connect', con)\n        con.once('data', function () {\n          //this is the only way to know for sure that data is coming...\n          backoffMethod.reset()\n        })\n      } else {\n        con\n          .on('connect', function () {\n            backoffMethod.reset()\n            emitter.connected = true\n            con.removeListener('connect', onConnect)\n            emitter.emit('connect', con)\n          })\n      }\n    }\n\n    emitter.connect =\n    emitter.listen = function () {\n      this.reconnect = true\n      if(emitter.connected) return\n      backoffMethod.reset()\n      backoffMethod.on('ready', attempt)\n      args = [].slice.call(arguments)\n      attempt(0, 0)\n      return emitter\n    }\n\n    //force reconnection\n    emitter.reconnect = function () {\n      if(this.connected)\n        return emitter.disconnect()\n      \n      backoffMethod.reset()\n      attempt(0, 0)\n      return emitter\n    }\n\n    emitter.disconnect = function () {\n      this.reconnect = false\n      if(!emitter.connected) return emitter\n      \n      else if(emitter._connection)\n        emitter._connection.destroy()\n\n      emitter.emit('disconnect')\n      return emitter\n    }\n\n    var widget\n    emitter.widget = function () {\n      if(!widget)\n        widget = require('./widget')(emitter)\n      return widget\n    }\n\n    return emitter\n  }\n\n}\n\n//@ sourceURL=/node_modules/rumours/node_modules/reconnect/inject.js"
));

require.define("/node_modules/rumours/node_modules/reconnect/node_modules/backoff/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/reconnect/node_modules/backoff/package.json"
));

require.define("/node_modules/rumours/node_modules/reconnect/node_modules/backoff/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * Copyright (c) 2012 Mathieu Turcotte\n * Licensed under the MIT license.\n */\n\nvar Backoff = require('./lib/backoff'),\n    FibonacciBackoffStrategy = require('./lib/strategy/fibonacci'),\n    ExponentialBackoffStrategy = require('./lib/strategy/exponential');\n\nmodule.exports.Backoff = Backoff;\nmodule.exports.FibonacciStrategy = FibonacciBackoffStrategy;\nmodule.exports.ExponentialStrategy = ExponentialBackoffStrategy;\n\n/**\n * Constructs a Fibonacci backoff.\n * @param options Fibonacci backoff strategy arguments.\n * @see FibonacciBackoffStrategy\n */\nmodule.exports.fibonacci = function(options) {\n    return new Backoff(new FibonacciBackoffStrategy(options));\n};\n\n/**\n * Constructs an exponential backoff.\n * @param options Exponential strategy arguments.\n * @see ExponentialBackoffStrategy\n */\nmodule.exports.exponential = function(options) {\n    return new Backoff(new ExponentialBackoffStrategy(options));\n};\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/reconnect/node_modules/backoff/index.js"
));

require.define("/node_modules/rumours/node_modules/reconnect/node_modules/backoff/lib/backoff.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * Copyright (c) 2012 Mathieu Turcotte\n * Licensed under the MIT license.\n */\n\nvar events = require('events'),\n    util = require('util');\n\n/**\n * Backoff driver.\n * @param backoffStrategy Backoff delay generator/strategy.\n * @constructor\n */\nfunction Backoff(backoffStrategy) {\n    events.EventEmitter.call(this);\n\n    this.backoffStrategy_ = backoffStrategy;\n    this.backoffNumber_ = 0;\n    this.backoffDelay_ = 0;\n    this.timeoutID_ = -1;\n\n    this.handlers = {\n        backoff: this.onBackoff_.bind(this)\n    };\n}\nutil.inherits(Backoff, events.EventEmitter);\n\n/**\n * Starts a backoff operation.\n */\nBackoff.prototype.backoff = function() {\n    if (this.timeoutID_ !== -1) {\n        throw new Error('Backoff in progress.');\n    }\n\n    this.backoffDelay_ = this.backoffStrategy_.next();\n    this.timeoutID_ = setTimeout(this.handlers.backoff, this.backoffDelay_);\n    this.emit('backoff', this.backoffNumber_, this.backoffDelay_);\n};\n\n/**\n * Backoff completion handler.\n * @private\n */\nBackoff.prototype.onBackoff_ = function() {\n    this.timeoutID_ = -1;\n    this.emit('ready', this.backoffNumber_++, this.backoffDelay_);\n};\n\n/**\n * Stops any backoff operation and resets the backoff\n * delay to its inital value.\n */\nBackoff.prototype.reset = function() {\n    this.backoffNumber_ = 0;\n    this.backoffStrategy_.reset();\n    clearTimeout(this.timeoutID_);\n    this.timeoutID_ = -1;\n};\n\nmodule.exports = Backoff;\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/reconnect/node_modules/backoff/lib/backoff.js"
));

require.define("/node_modules/rumours/node_modules/reconnect/node_modules/backoff/lib/strategy/fibonacci.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * Copyright (c) 2012 Mathieu Turcotte\n * Licensed under the MIT license.\n */\n\nvar util = require('util');\n\nvar BackoffStrategy = require('./strategy');\n\n/**\n * Fibonacci backoff strategy.\n * @extends BackoffStrategy\n */\nfunction FibonacciBackoffStrategy(options) {\n    BackoffStrategy.call(this, options);\n    this.backoffDelay_ = 0;\n    this.nextBackoffDelay_ = this.getInitialDelay();\n}\nutil.inherits(FibonacciBackoffStrategy, BackoffStrategy);\n\n/** @inheritDoc */\nFibonacciBackoffStrategy.prototype.next_ = function() {\n    var backoffDelay = Math.min(this.nextBackoffDelay_, this.getMaxDelay());\n    this.nextBackoffDelay_ += this.backoffDelay_;\n    this.backoffDelay_ = backoffDelay;\n    return backoffDelay;\n};\n\n/** @inheritDoc */\nFibonacciBackoffStrategy.prototype.reset_ = function() {\n    this.nextBackoffDelay_ = this.getInitialDelay();\n    this.backoffDelay_ = 0;\n};\n\nmodule.exports = FibonacciBackoffStrategy;\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/reconnect/node_modules/backoff/lib/strategy/fibonacci.js"
));

require.define("/node_modules/rumours/node_modules/reconnect/node_modules/backoff/lib/strategy/strategy.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * Copyright (c) 2012 Mathieu Turcotte\n * Licensed under the MIT license.\n */\n\nvar events = require('events'),\n    util = require('util');\n\nfunction isDef(value) {\n    return value !== undefined && value !== null;\n}\n\n/**\n * Abstract class defining the skeleton for all backoff strategies.\n * @param options Backoff strategy options.\n * @param options.randomisationFactor The randomisation factor, must be between\n * 0 and 1.\n * @param options.initialDelay The backoff initial delay, in milliseconds.\n * @param options.maxDelay The backoff maximal delay, in milliseconds.\n * @constructor\n */\nfunction BackoffStrategy(options) {\n    options = options || {};\n\n    if (isDef(options.initialDelay) && options.initialDelay < 1) {\n        throw new Error('The initial timeout must be greater than 0.');\n    } else if (isDef(options.maxDelay) && options.maxDelay < 1) {\n        throw new Error('The maximal timeout must be greater than 0.');\n    }\n\n    this.initialDelay_ = options.initialDelay || 100;\n    this.maxDelay_ = options.maxDelay || 10000;\n\n    if (this.maxDelay_ <= this.initialDelay_) {\n        throw new Error('The maximal backoff delay must be ' +\n                        'greater than the initial backoff delay.');\n    }\n\n    if (isDef(options.randomisationFactor) &&\n        (options.randomisationFactor < 0 || options.randomisationFactor > 1)) {\n        throw new Error('The randomisation factor must be between 0 and 1.');\n    }\n\n    this.randomisationFactor_ = options.randomisationFactor || 0;\n}\n\n/**\n * Retrieves the maximal backoff delay.\n * @return The maximal backoff delay.\n */\nBackoffStrategy.prototype.getMaxDelay = function() {\n    return this.maxDelay_;\n};\n\n/**\n * Retrieves the initial backoff delay.\n * @return The initial backoff delay.\n */\nBackoffStrategy.prototype.getInitialDelay = function() {\n    return this.initialDelay_;\n};\n\n/**\n * Template method that computes the next backoff delay.\n * @return The backoff delay, in milliseconds.\n */\nBackoffStrategy.prototype.next = function() {\n    var backoffDelay = this.next_();\n    var randomisationMultiple = 1 + Math.random() * this.randomisationFactor_;\n    var randomizedDelay = Math.round(backoffDelay * randomisationMultiple);\n    return randomizedDelay;\n};\n\n/**\n * Computes the next backoff delay.\n * @return The backoff delay, in milliseconds.\n */\nBackoffStrategy.prototype.next_ = function() {\n    throw new Error('BackoffStrategy.next_() unimplemented.');\n};\n\n/**\n * Template method that resets the backoff delay to its initial value.\n */\nBackoffStrategy.prototype.reset = function() {\n    this.reset_();\n};\n\n/**\n * Resets the backoff delay to its initial value.\n */\nBackoffStrategy.prototype.reset_ = function() {\n    throw new Error('BackoffStrategy.reset_() unimplemented.');\n};\n\nmodule.exports = BackoffStrategy;\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/reconnect/node_modules/backoff/lib/strategy/strategy.js"
));

require.define("/node_modules/rumours/node_modules/reconnect/node_modules/backoff/lib/strategy/exponential.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * Copyright (c) 2012 Mathieu Turcotte\n * Licensed under the MIT license.\n */\n\nvar util = require('util');\n\nvar BackoffStrategy = require('./strategy');\n\n/**\n * Exponential backoff strategy.\n * @extends BackoffStrategy\n */\nfunction ExponentialBackoffStrategy(options) {\n    BackoffStrategy.call(this, options);\n    this.backoffDelay_ = 0;\n    this.nextBackoffDelay_ = this.getInitialDelay();\n}\nutil.inherits(ExponentialBackoffStrategy, BackoffStrategy);\n\n/** @inheritDoc */\nExponentialBackoffStrategy.prototype.next_ = function() {\n    this.backoffDelay_ = Math.min(this.nextBackoffDelay_, this.getMaxDelay());\n    this.nextBackoffDelay_ = this.backoffDelay_ * 2;\n    return this.backoffDelay_;\n};\n\n/** @inheritDoc */\nExponentialBackoffStrategy.prototype.reset_ = function() {\n    this.backoffDelay_ = 0;\n    this.nextBackoffDelay_ = this.getInitialDelay();\n};\n\nmodule.exports = ExponentialBackoffStrategy;\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/reconnect/node_modules/backoff/lib/strategy/exponential.js"
));

require.define("/node_modules/rumours/node_modules/reconnect/widget.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar h = require('hyperscript')\n\nmodule.exports = function (emitter) {\n  var style = {}\n  var el = h('a', {\n    href: '#', \n    style: style, \n    onclick: function () {\n      emitter.connected \n        ? emitter.disconnect()\n        : emitter.reconnect()\n    }\n  }, 'connecting...')\n  var int\n  emitter.on('reconnect', function (n, d) {\n    var delay = Math.round(d / 1000) + 1\n    console.log(n, d)\n    el.innerText = 'reconnect in ' + delay\n    clearInterval(int)\n    int = setInterval(function () {\n      el.innerText = delay ? 'reconnect in ' + --delay : 'reconnecting...'\n    }, 1e3)\n  })\n  emitter.on('connect',   function () {\n    el.innerText = 'connected'\n    clearInterval(int)\n  })\n  return el\n}\n\n//@ sourceURL=/node_modules/rumours/node_modules/reconnect/widget.js"
));

require.define("/node_modules/hyperscript/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/hyperscript/package.json"
));

require.define("/node_modules/hyperscript/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],";(function () {\n\nfunction h() {\n  var args = [].slice.call(arguments), e = null\n  function item (l) {\n    var r\n    function parseClass (string) {\n      var m = string.split(/([\\.#]?[a-zA-Z0-9_-]+)/)\n      m.forEach(function (v) {\n        var s = v.substring(1,v.length)\n        if(!v) return \n        if(!e)\n          e = document.createElement(v)\n        else if (v[0] === '.')\n          e.classList.add(s)\n        else if (v[0] === '#')\n          e.setAttribute('id', s)\n      })\n    }\n\n    if(l == null)\n      ;\n    else if('string' === typeof l) {\n      if(!e)\n        parseClass(l)\n      else\n        e.appendChild(r = document.createTextNode(l))\n    }\n    else if('number' === typeof l \n      || 'boolean' === typeof l\n      || l instanceof Date \n      || l instanceof RegExp ) {\n        e.appendChild(r = document.createTextNode(l.toString()))\n    }\n    //there might be a better way to handle this...\n    else if (Array.isArray(l))\n      l.forEach(item)\n    else if(l instanceof Node)\n      e.appendChild(r = l)\n    else if(l instanceof Text)\n      e.appendChild(r = l)\n    else if ('object' === typeof l) {\n      for (var k in l) {\n        if('function' === typeof l[k]) {\n          if(/^on\\w+/.test(k)) {\n            e.addEventListener(k.substring(2), l[k])\n          } else {\n            e[k] = l[k]()\n            l[k](function (v) {\n              e[k] = v\n            })\n          }\n        }\n        else if(k === 'style') {\n          for (var s in l[k]) (function(s, v) {\n            if('function' === typeof v) {\n              e.style.setProperty(s, v())\n              v(function (val) {\n                e.style.setProperty(s, val)\n              })\n            } else\n              e.style.setProperty(s, l[k][s])\n          })(s, l[k][s])\n        } else\n          e[k] = l[k]\n      }\n    } else if ('function' === typeof l) {\n      //assume it's an observable!\n      var v = l()\n      e.appendChild(r = v instanceof Node ? v : document.createTextNode(v))\n\n      l(function (v) {\n        if(v instanceof Node && r.parentElement)\n          r.parentElement.replaceChild(v, r), r = v\n        else\n          r.textContent = v\n      })\n      \n    }\n\n    return r\n  }\n  while(args.length)\n    item(args.shift())\n\n  return e\n}\n\nif(typeof module === 'object')\n module.exports = h\nelse\n  this.hyperscript = h\n})()\n\n//@ sourceURL=/node_modules/hyperscript/index.js"
));

require.define("/node_modules/rumours/node_modules/client-reloader/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"browserify\":\"./browser.js\"}\n//@ sourceURL=/node_modules/rumours/node_modules/client-reloader/package.json"
));

require.define("/node_modules/rumours/node_modules/client-reloader/browser.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar header = require('header-stream')\n\nvar version = 0\n/**\nTODO\nmore sophisticated reloading, \npass in a package and a semver range...\n**/\nmodule.exports = function (handler, init) {\n  init = init || {}\n  init.version = version || 0\n    \n  return function (stream) {\n    var args = [].slice.call(arguments)\n\n    header(stream)\n      .setHeader(init)\n      .writeHead()\n\n    stream.on('header', function (meta) {\n      if(!init.version)\n        init.version = meta.version\n      else if(meta.version !== init.version && init.version) {\n        stream.emit('reload', meta.version, init.version)\n        stream.end()\n\n        return window.location.reload(true)\n      }\n\n      handler.apply(this, args)\n    })\n  }\n\n}\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/client-reloader/browser.js"
));

require.define("/node_modules/rumours/node_modules/client-reloader/node_modules/header-stream/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/client-reloader/node_modules/header-stream/package.json"
));

require.define("/node_modules/rumours/node_modules/client-reloader/node_modules/header-stream/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\n//the first line is header, in JSON format, with no whitespace.\n\nfunction merge (a, b) {\n  for (var k in b)\n    a[k] = a[k] || b[k]\n}\n\nmodule.exports = \nfunction header (stream) {\n\n  var emit = stream.emit\n  var write = stream.write\n  var soFar = ''\n\n  stream.emit = function (event, data) {\n    if(event !== 'data')\n      return emit.apply(stream, arguments)\n\n    soFar += data\n    var m\n    if(!(m = /\\n/.exec(soFar))) return\n    var meta = JSON.parse(soFar.substring(0, m.index))\n    //+ 1 to get past the newline\n    soFar = soFar.substring(m.index + 1)\n    stream.emit = emit\n    stream.meta = meta\n    stream.emit('header', meta)\n    //check that the stream is still readable,\n    //it may have been ended during the 'header'\n    //event.\n    if('' !== soFar  && stream.readable)\n      stream.emit('data', soFar)\n  }\n\n  var meta = {}\n\n  stream.setHeader = function (key, val) {\n    if('string' === typeof key)\n      meta[key] = val\n    else\n      merge(meta, key)\n    return stream\n  }\n\n  stream.writeHead = function (_meta) {\n    if(_meta) merge(meta, _meta)\n    stream.write = write\n    stream.write(JSON.stringify(meta)+'\\n')    \n  }\n\n  stream.write = function (data) {\n    stream.writeHead()\n    return stream.write(data)\n  }\n\n  return stream\n}\n\n//@ sourceURL=/node_modules/rumours/node_modules/client-reloader/node_modules/header-stream/index.js"
));

require.define("/node_modules/rumours/node_modules/shasum/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/shasum/package.json"
));

require.define("/node_modules/rumours/node_modules/shasum/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar createHash = require('crypto').createHash \nvar Buffer = require('buffer').Buffer\nmodule.exports = function hash (str, alg, format) {\n  str = 'string' === typeof str ? str\n    : Buffer.isBuffer(str) ? str\n    : JSON.stringify(str)\n  return createHash(alg || 'sha1').update(str).digest(format || 'hex')\n}\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/shasum/index.js"
));

require.define("crypto",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = require(\"crypto-browserify\")\n//@ sourceURL=crypto"
));

require.define("/node_modules/crypto-browserify/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/crypto-browserify/package.json"
));

require.define("/node_modules/crypto-browserify/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var sha = require('./sha')\nvar rng = require('./rng')\n\nvar algorithms = {\n  sha1: {\n    hex: sha.hex_sha1,\n    binary: sha.b64_sha1,\n    ascii: sha.str_sha1\n  }\n}\n\nfunction error () {\n  var m = [].slice.call(arguments).join(' ')\n  throw new Error([\n    m,\n    'we accept pull requests',\n    'http://github.com/dominictarr/crypto-browserify'\n    ].join('\\n'))\n}\n\nexports.createHash = function (alg) {\n  alg = alg || 'sha1'\n  if(!algorithms[alg])\n    error('algorithm:', alg, 'is not yet supported')\n  var s = ''\n  var _alg = algorithms[alg]\n  return {\n    update: function (data) {\n      s += data\n      return this\n    },\n    digest: function (enc) {\n      enc = enc || 'binary'\n      var fn\n      if(!(fn = _alg[enc]))\n        error('encoding:', enc , 'is not yet supported for algorithm', alg)\n      var r = fn(s)\n      s = null //not meant to use the hash after you've called digest.\n      return r\n    }\n  }\n}\n\nexports.randomBytes = function(size, callback) {\n  if (callback && callback.call) {\n    try {\n      callback.call(this, undefined, rng(size));\n    } catch (err) { callback(err); }\n  } else {\n    return rng(size);\n  }\n}\n\n// the least I can do is make error messages for the rest of the node.js/crypto api.\n;['createCredentials'\n, 'createHmac'\n, 'createCypher'\n, 'createCypheriv'\n, 'createDecipher'\n, 'createDecipheriv'\n, 'createSign'\n, 'createVerify'\n, 'createDeffieHellman'\n, 'pbkdf2'].forEach(function (name) {\n  exports[name] = function () {\n    error('sorry,', name, 'is not implemented yet')\n  }\n})\n\n//@ sourceURL=/node_modules/crypto-browserify/index.js"
));

require.define("/node_modules/crypto-browserify/sha.js",Function(['require','module','exports','__dirname','__filename','process','global'],"/*\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\n * in FIPS PUB 180-1\n * Version 2.1a Copyright Paul Johnston 2000 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for details.\n */\n\nexports.hex_sha1 = hex_sha1;\nexports.b64_sha1 = b64_sha1;\nexports.str_sha1 = str_sha1;\nexports.hex_hmac_sha1 = hex_hmac_sha1;\nexports.b64_hmac_sha1 = b64_hmac_sha1;\nexports.str_hmac_sha1 = str_hmac_sha1;\n\n/*\n * Configurable variables. You may need to tweak these to be compatible with\n * the server-side, but the defaults work in most cases.\n */\nvar hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */\nvar b64pad  = \"\"; /* base-64 pad character. \"=\" for strict RFC compliance   */\nvar chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */\n\n/*\n * These are the functions you'll usually want to call\n * They take string arguments and return either hex or base-64 encoded strings\n */\nfunction hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}\nfunction b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}\nfunction str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}\nfunction hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}\nfunction b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}\nfunction str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}\n\n/*\n * Perform a simple self-test to see if the VM is working\n */\nfunction sha1_vm_test()\n{\n  return hex_sha1(\"abc\") == \"a9993e364706816aba3e25717850c26c9cd0d89d\";\n}\n\n/*\n * Calculate the SHA-1 of an array of big-endian words, and a bit length\n */\nfunction core_sha1(x, len)\n{\n  /* append padding */\n  x[len >> 5] |= 0x80 << (24 - len % 32);\n  x[((len + 64 >> 9) << 4) + 15] = len;\n\n  var w = Array(80);\n  var a =  1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d =  271733878;\n  var e = -1009589776;\n\n  for(var i = 0; i < x.length; i += 16)\n  {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n    var olde = e;\n\n    for(var j = 0; j < 80; j++)\n    {\n      if(j < 16) w[j] = x[i + j];\n      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);\n      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),\n                       safe_add(safe_add(e, w[j]), sha1_kt(j)));\n      e = d;\n      d = c;\n      c = rol(b, 30);\n      b = a;\n      a = t;\n    }\n\n    a = safe_add(a, olda);\n    b = safe_add(b, oldb);\n    c = safe_add(c, oldc);\n    d = safe_add(d, oldd);\n    e = safe_add(e, olde);\n  }\n  return Array(a, b, c, d, e);\n\n}\n\n/*\n * Perform the appropriate triplet combination function for the current\n * iteration\n */\nfunction sha1_ft(t, b, c, d)\n{\n  if(t < 20) return (b & c) | ((~b) & d);\n  if(t < 40) return b ^ c ^ d;\n  if(t < 60) return (b & c) | (b & d) | (c & d);\n  return b ^ c ^ d;\n}\n\n/*\n * Determine the appropriate additive constant for the current iteration\n */\nfunction sha1_kt(t)\n{\n  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :\n         (t < 60) ? -1894007588 : -899497514;\n}\n\n/*\n * Calculate the HMAC-SHA1 of a key and some data\n */\nfunction core_hmac_sha1(key, data)\n{\n  var bkey = str2binb(key);\n  if(bkey.length > 16) bkey = core_sha1(bkey, key.length * chrsz);\n\n  var ipad = Array(16), opad = Array(16);\n  for(var i = 0; i < 16; i++)\n  {\n    ipad[i] = bkey[i] ^ 0x36363636;\n    opad[i] = bkey[i] ^ 0x5C5C5C5C;\n  }\n\n  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);\n  return core_sha1(opad.concat(hash), 512 + 160);\n}\n\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\nfunction safe_add(x, y)\n{\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xFFFF);\n}\n\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\nfunction rol(num, cnt)\n{\n  return (num << cnt) | (num >>> (32 - cnt));\n}\n\n/*\n * Convert an 8-bit or 16-bit string to an array of big-endian words\n * In 8-bit function, characters >255 have their hi-byte silently ignored.\n */\nfunction str2binb(str)\n{\n  var bin = Array();\n  var mask = (1 << chrsz) - 1;\n  for(var i = 0; i < str.length * chrsz; i += chrsz)\n    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (32 - chrsz - i%32);\n  return bin;\n}\n\n/*\n * Convert an array of big-endian words to a string\n */\nfunction binb2str(bin)\n{\n  var str = \"\";\n  var mask = (1 << chrsz) - 1;\n  for(var i = 0; i < bin.length * 32; i += chrsz)\n    str += String.fromCharCode((bin[i>>5] >>> (32 - chrsz - i%32)) & mask);\n  return str;\n}\n\n/*\n * Convert an array of big-endian words to a hex string.\n */\nfunction binb2hex(binarray)\n{\n  var hex_tab = hexcase ? \"0123456789ABCDEF\" : \"0123456789abcdef\";\n  var str = \"\";\n  for(var i = 0; i < binarray.length * 4; i++)\n  {\n    str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +\n           hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);\n  }\n  return str;\n}\n\n/*\n * Convert an array of big-endian words to a base-64 string\n */\nfunction binb2b64(binarray)\n{\n  var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  var str = \"\";\n  for(var i = 0; i < binarray.length * 4; i += 3)\n  {\n    var triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16)\n                | (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 )\n                |  ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);\n    for(var j = 0; j < 4; j++)\n    {\n      if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;\n      else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);\n    }\n  }\n  return str;\n}\n\n\n//@ sourceURL=/node_modules/crypto-browserify/sha.js"
));

require.define("/node_modules/crypto-browserify/rng.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Original code adapted from Robert Kieffer.\n// details at https://github.com/broofa/node-uuid\n(function() {\n  var _global = this;\n\n  var mathRNG, whatwgRNG;\n\n  // NOTE: Math.random() does not guarantee \"cryptographic quality\"\n  mathRNG = function(size) {\n    var bytes = new Array(size);\n    var r;\n\n    for (var i = 0, r; i < size; i++) {\n      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;\n      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return bytes;\n  }\n\n  // currently only available in webkit-based browsers.\n  if (_global.crypto && crypto.getRandomValues) {\n    var _rnds = new Uint32Array(4);\n    whatwgRNG = function(size) {\n      var bytes = new Array(size);\n      crypto.getRandomValues(_rnds);\n\n      for (var c = 0 ; c < size; c++) {\n        bytes[c] = _rnds[c >> 2] >>> ((c & 0x03) * 8) & 0xff;\n      }\n      return bytes;\n    }\n  }\n\n  module.exports = whatwgRNG || mathRNG;\n\n}())\n//@ sourceURL=/node_modules/crypto-browserify/rng.js"
));

require.define("buffer",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = require(\"buffer-browserify\")\n//@ sourceURL=buffer"
));

require.define("/node_modules/buffer-browserify/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index.js\",\"browserify\":\"index.js\"}\n//@ sourceURL=/node_modules/buffer-browserify/package.json"
));

require.define("/node_modules/buffer-browserify/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"function SlowBuffer (size) {\n    this.length = size;\n};\n\nvar assert = require('assert');\n\nexports.INSPECT_MAX_BYTES = 50;\n\n\nfunction toHex(n) {\n  if (n < 16) return '0' + n.toString(16);\n  return n.toString(16);\n}\n\nfunction utf8ToBytes(str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; i++)\n    if (str.charCodeAt(i) <= 0x7F)\n      byteArray.push(str.charCodeAt(i));\n    else {\n      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');\n      for (var j = 0; j < h.length; j++)\n        byteArray.push(parseInt(h[j], 16));\n    }\n\n  return byteArray;\n}\n\nfunction asciiToBytes(str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++ )\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push( str.charCodeAt(i) & 0xFF );\n\n  return byteArray;\n}\n\nfunction base64ToBytes(str) {\n  return require(\"base64-js\").toByteArray(str);\n}\n\nSlowBuffer.byteLength = function (str, encoding) {\n  switch (encoding || \"utf8\") {\n    case 'hex':\n      return str.length / 2;\n\n    case 'utf8':\n    case 'utf-8':\n      return utf8ToBytes(str).length;\n\n    case 'ascii':\n      return str.length;\n\n    case 'base64':\n      return base64ToBytes(str).length;\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n};\n\nfunction blitBuffer(src, dst, offset, length) {\n  var pos, i = 0;\n  while (i < length) {\n    if ((i+offset >= dst.length) || (i >= src.length))\n      break;\n\n    dst[i + offset] = src[i];\n    i++;\n  }\n  return i;\n}\n\nSlowBuffer.prototype.utf8Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.asciiWrite = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.base64Write = function (string, offset, length) {\n  var bytes, pos;\n  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);\n};\n\nSlowBuffer.prototype.base64Slice = function (start, end) {\n  var bytes = Array.prototype.slice.apply(this, arguments)\n  return require(\"base64-js\").fromByteArray(bytes);\n}\n\nfunction decodeUtf8Char(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch (err) {\n    return String.fromCharCode(0xFFFD); // UTF 8 invalid char\n  }\n}\n\nSlowBuffer.prototype.utf8Slice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var res = \"\";\n  var tmp = \"\";\n  var i = 0;\n  while (i < bytes.length) {\n    if (bytes[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);\n      tmp = \"\";\n    } else\n      tmp += \"%\" + bytes[i].toString(16);\n\n    i++;\n  }\n\n  return res + decodeUtf8Char(tmp);\n}\n\nSlowBuffer.prototype.asciiSlice = function () {\n  var bytes = Array.prototype.slice.apply(this, arguments);\n  var ret = \"\";\n  for (var i = 0; i < bytes.length; i++)\n    ret += String.fromCharCode(bytes[i]);\n  return ret;\n}\n\nSlowBuffer.prototype.inspect = function() {\n  var out = [],\n      len = this.length;\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this[i]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = '...';\n      break;\n    }\n  }\n  return '<SlowBuffer ' + out.join(' ') + '>';\n};\n\n\nSlowBuffer.prototype.hexSlice = function(start, end) {\n  var len = this.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = '';\n  for (var i = start; i < end; i++) {\n    out += toHex(this[i]);\n  }\n  return out;\n};\n\n\nSlowBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || 'utf8').toLowerCase();\n  start = +start || 0;\n  if (typeof end == 'undefined') end = this.length;\n\n  // Fastpath empty strings\n  if (+end == start) {\n    return '';\n  }\n\n  switch (encoding) {\n    case 'hex':\n      return this.hexSlice(start, end);\n\n    case 'utf8':\n    case 'utf-8':\n      return this.utf8Slice(start, end);\n\n    case 'ascii':\n      return this.asciiSlice(start, end);\n\n    case 'binary':\n      return this.binarySlice(start, end);\n\n    case 'base64':\n      return this.base64Slice(start, end);\n\n    case 'ucs2':\n    case 'ucs-2':\n      return this.ucs2Slice(start, end);\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n};\n\n\nSlowBuffer.prototype.hexWrite = function(string, offset, length) {\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length;\n  if (strLen % 2) {\n    throw new Error('Invalid hex string');\n  }\n  if (length > strLen / 2) {\n    length = strLen / 2;\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(byte)) throw new Error('Invalid hex string');\n    this[offset + i] = byte;\n  }\n  SlowBuffer._charsWritten = i * 2;\n  return i;\n};\n\n\nSlowBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || 'utf8').toLowerCase();\n\n  switch (encoding) {\n    case 'hex':\n      return this.hexWrite(string, offset, length);\n\n    case 'utf8':\n    case 'utf-8':\n      return this.utf8Write(string, offset, length);\n\n    case 'ascii':\n      return this.asciiWrite(string, offset, length);\n\n    case 'binary':\n      return this.binaryWrite(string, offset, length);\n\n    case 'base64':\n      return this.base64Write(string, offset, length);\n\n    case 'ucs2':\n    case 'ucs-2':\n      return this.ucs2Write(string, offset, length);\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n};\n\n\n// slice(start, end)\nSlowBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n\n  if (end > this.length) {\n    throw new Error('oob');\n  }\n  if (start > end) {\n    throw new Error('oob');\n  }\n\n  return new Buffer(this, end - start, +start);\n};\n\nSlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {\n  var temp = [];\n  for (var i=sourcestart; i<sourceend; i++) {\n    assert.ok(typeof this[i] !== 'undefined', \"copying undefined buffer bytes!\");\n    temp.push(this[i]);\n  }\n\n  for (var i=targetstart; i<targetstart+temp.length; i++) {\n    target[i] = temp[i-targetstart];\n  }\n};\n\nfunction coerce(length) {\n  // Coerce length to a number (possibly NaN), round up\n  // in case it's fractional (e.g. 123.456) then do a\n  // double negate to coerce a NaN to 0. Easy, right?\n  length = ~~Math.ceil(+length);\n  return length < 0 ? 0 : length;\n}\n\n\n// Buffer\n\nfunction Buffer(subject, encoding, offset) {\n  if (!(this instanceof Buffer)) {\n    return new Buffer(subject, encoding, offset);\n  }\n\n  var type;\n\n  // Are we slicing?\n  if (typeof offset === 'number') {\n    this.length = coerce(encoding);\n    this.parent = subject;\n    this.offset = offset;\n  } else {\n    // Find the length\n    switch (type = typeof subject) {\n      case 'number':\n        this.length = coerce(subject);\n        break;\n\n      case 'string':\n        this.length = Buffer.byteLength(subject, encoding);\n        break;\n\n      case 'object': // Assume object is an array\n        this.length = coerce(subject.length);\n        break;\n\n      default:\n        throw new Error('First argument needs to be a number, ' +\n                        'array or string.');\n    }\n\n    if (this.length > Buffer.poolSize) {\n      // Big buffer, just alloc one.\n      this.parent = new SlowBuffer(this.length);\n      this.offset = 0;\n\n    } else {\n      // Small buffer.\n      if (!pool || pool.length - pool.used < this.length) allocPool();\n      this.parent = pool;\n      this.offset = pool.used;\n      pool.used += this.length;\n    }\n\n    // Treat array-ish objects as a byte array.\n    if (isArrayIsh(subject)) {\n      for (var i = 0; i < this.length; i++) {\n        this.parent[i + this.offset] = subject[i];\n      }\n    } else if (type == 'string') {\n      // We are a string\n      this.length = this.write(subject, 0, encoding);\n    }\n  }\n\n}\n\nfunction isArrayIsh(subject) {\n  return Array.isArray(subject) || Buffer.isBuffer(subject) ||\n         subject && typeof subject === 'object' &&\n         typeof subject.length === 'number';\n}\n\nexports.SlowBuffer = SlowBuffer;\nexports.Buffer = Buffer;\n\nBuffer.poolSize = 8 * 1024;\nvar pool;\n\nfunction allocPool() {\n  pool = new SlowBuffer(Buffer.poolSize);\n  pool.used = 0;\n}\n\n\n// Static methods\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer || b instanceof SlowBuffer;\n};\n\nBuffer.concat = function (list, totalLength) {\n  if (!Array.isArray(list)) {\n    throw new Error(\"Usage: Buffer.concat(list, [totalLength])\\n \\\n      list should be an Array.\");\n  }\n\n  if (list.length === 0) {\n    return new Buffer(0);\n  } else if (list.length === 1) {\n    return list[0];\n  }\n\n  if (typeof totalLength !== 'number') {\n    totalLength = 0;\n    for (var i = 0; i < list.length; i++) {\n      var buf = list[i];\n      totalLength += buf.length;\n    }\n  }\n\n  var buffer = new Buffer(totalLength);\n  var pos = 0;\n  for (var i = 0; i < list.length; i++) {\n    var buf = list[i];\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n  return buffer;\n};\n\n// Inspect\nBuffer.prototype.inspect = function inspect() {\n  var out = [],\n      len = this.length;\n\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this.parent[i + this.offset]);\n    if (i == exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = '...';\n      break;\n    }\n  }\n\n  return '<Buffer ' + out.join(' ') + '>';\n};\n\n\nBuffer.prototype.get = function get(i) {\n  if (i < 0 || i >= this.length) throw new Error('oob');\n  return this.parent[this.offset + i];\n};\n\n\nBuffer.prototype.set = function set(i, v) {\n  if (i < 0 || i >= this.length) throw new Error('oob');\n  return this.parent[this.offset + i] = v;\n};\n\n\n// write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')\nBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length;\n      length = undefined;\n    }\n  } else {  // legacy\n    var swap = encoding;\n    encoding = offset;\n    offset = length;\n    length = swap;\n  }\n\n  offset = +offset || 0;\n  var remaining = this.length - offset;\n  if (!length) {\n    length = remaining;\n  } else {\n    length = +length;\n    if (length > remaining) {\n      length = remaining;\n    }\n  }\n  encoding = String(encoding || 'utf8').toLowerCase();\n\n  var ret;\n  switch (encoding) {\n    case 'hex':\n      ret = this.parent.hexWrite(string, this.offset + offset, length);\n      break;\n\n    case 'utf8':\n    case 'utf-8':\n      ret = this.parent.utf8Write(string, this.offset + offset, length);\n      break;\n\n    case 'ascii':\n      ret = this.parent.asciiWrite(string, this.offset + offset, length);\n      break;\n\n    case 'binary':\n      ret = this.parent.binaryWrite(string, this.offset + offset, length);\n      break;\n\n    case 'base64':\n      // Warning: maxLength not taken into account in base64Write\n      ret = this.parent.base64Write(string, this.offset + offset, length);\n      break;\n\n    case 'ucs2':\n    case 'ucs-2':\n      ret = this.parent.ucs2Write(string, this.offset + offset, length);\n      break;\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n\n  Buffer._charsWritten = SlowBuffer._charsWritten;\n\n  return ret;\n};\n\n\n// toString(encoding, start=0, end=buffer.length)\nBuffer.prototype.toString = function(encoding, start, end) {\n  encoding = String(encoding || 'utf8').toLowerCase();\n\n  if (typeof start == 'undefined' || start < 0) {\n    start = 0;\n  } else if (start > this.length) {\n    start = this.length;\n  }\n\n  if (typeof end == 'undefined' || end > this.length) {\n    end = this.length;\n  } else if (end < 0) {\n    end = 0;\n  }\n\n  start = start + this.offset;\n  end = end + this.offset;\n\n  switch (encoding) {\n    case 'hex':\n      return this.parent.hexSlice(start, end);\n\n    case 'utf8':\n    case 'utf-8':\n      return this.parent.utf8Slice(start, end);\n\n    case 'ascii':\n      return this.parent.asciiSlice(start, end);\n\n    case 'binary':\n      return this.parent.binarySlice(start, end);\n\n    case 'base64':\n      return this.parent.base64Slice(start, end);\n\n    case 'ucs2':\n    case 'ucs-2':\n      return this.parent.ucs2Slice(start, end);\n\n    default:\n      throw new Error('Unknown encoding');\n  }\n};\n\n\n// byteLength\nBuffer.byteLength = SlowBuffer.byteLength;\n\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill(value, start, end) {\n  value || (value = 0);\n  start || (start = 0);\n  end || (end = this.length);\n\n  if (typeof value === 'string') {\n    value = value.charCodeAt(0);\n  }\n  if (!(typeof value === 'number') || isNaN(value)) {\n    throw new Error('value is not a number');\n  }\n\n  if (end < start) throw new Error('end < start');\n\n  // Fill 0 bytes; we're done\n  if (end === start) return 0;\n  if (this.length == 0) return 0;\n\n  if (start < 0 || start >= this.length) {\n    throw new Error('start out of bounds');\n  }\n\n  if (end < 0 || end > this.length) {\n    throw new Error('end out of bounds');\n  }\n\n  return this.parent.fill(value,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function(target, target_start, start, end) {\n  var source = this;\n  start || (start = 0);\n  end || (end = this.length);\n  target_start || (target_start = 0);\n\n  if (end < start) throw new Error('sourceEnd < sourceStart');\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0;\n  if (target.length == 0 || source.length == 0) return 0;\n\n  if (target_start < 0 || target_start >= target.length) {\n    throw new Error('targetStart out of bounds');\n  }\n\n  if (start < 0 || start >= source.length) {\n    throw new Error('sourceStart out of bounds');\n  }\n\n  if (end < 0 || end > source.length) {\n    throw new Error('sourceEnd out of bounds');\n  }\n\n  // Are we oob?\n  if (end > this.length) {\n    end = this.length;\n  }\n\n  if (target.length - target_start < end - start) {\n    end = target.length - target_start + start;\n  }\n\n  return this.parent.copy(target.parent,\n                          target_start + target.offset,\n                          start + this.offset,\n                          end + this.offset);\n};\n\n\n// slice(start, end)\nBuffer.prototype.slice = function(start, end) {\n  if (end === undefined) end = this.length;\n  if (end > this.length) throw new Error('oob');\n  if (start > end) throw new Error('oob');\n\n  return new Buffer(this.parent, end - start, +start + this.offset);\n};\n\n\n// Legacy methods for backwards compatibility.\n\nBuffer.prototype.utf8Slice = function(start, end) {\n  return this.toString('utf8', start, end);\n};\n\nBuffer.prototype.binarySlice = function(start, end) {\n  return this.toString('binary', start, end);\n};\n\nBuffer.prototype.asciiSlice = function(start, end) {\n  return this.toString('ascii', start, end);\n};\n\nBuffer.prototype.utf8Write = function(string, offset) {\n  return this.write(string, offset, 'utf8');\n};\n\nBuffer.prototype.binaryWrite = function(string, offset) {\n  return this.write(string, offset, 'binary');\n};\n\nBuffer.prototype.asciiWrite = function(string, offset) {\n  return this.write(string, offset, 'ascii');\n};\n\nBuffer.prototype.readUInt8 = function(offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  return buffer.parent[buffer.offset + offset];\n};\n\nfunction readUInt16(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  if (isBigEndian) {\n    val = buffer.parent[buffer.offset + offset] << 8;\n    val |= buffer.parent[buffer.offset + offset + 1];\n  } else {\n    val = buffer.parent[buffer.offset + offset];\n    val |= buffer.parent[buffer.offset + offset + 1] << 8;\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt16LE = function(offset, noAssert) {\n  return readUInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt16BE = function(offset, noAssert) {\n  return readUInt16(this, offset, true, noAssert);\n};\n\nfunction readUInt32(buffer, offset, isBigEndian, noAssert) {\n  var val = 0;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  if (isBigEndian) {\n    val = buffer.parent[buffer.offset + offset + 1] << 16;\n    val |= buffer.parent[buffer.offset + offset + 2] << 8;\n    val |= buffer.parent[buffer.offset + offset + 3];\n    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);\n  } else {\n    val = buffer.parent[buffer.offset + offset + 2] << 16;\n    val |= buffer.parent[buffer.offset + offset + 1] << 8;\n    val |= buffer.parent[buffer.offset + offset];\n    val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);\n  }\n\n  return val;\n}\n\nBuffer.prototype.readUInt32LE = function(offset, noAssert) {\n  return readUInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readUInt32BE = function(offset, noAssert) {\n  return readUInt32(this, offset, true, noAssert);\n};\n\n\n/*\n * Signed integer types, yay team! A reminder on how two's complement actually\n * works. The first bit is the signed bit, i.e. tells us whether or not the\n * number should be positive or negative. If the two's complement value is\n * positive, then we're done, as it's equivalent to the unsigned representation.\n *\n * Now if the number is positive, you're pretty much done, you can just leverage\n * the unsigned translations and return those. Unfortunately, negative numbers\n * aren't quite that straightforward.\n *\n * At first glance, one might be inclined to use the traditional formula to\n * translate binary numbers between the positive and negative values in two's\n * complement. (Though it doesn't quite work for the most negative value)\n * Mainly:\n *  - invert all the bits\n *  - add one to the result\n *\n * Of course, this doesn't quite work in Javascript. Take for example the value\n * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of\n * course, Javascript will do the following:\n *\n * > ~0xff80\n * -65409\n *\n * Whoh there, Javascript, that's not quite right. But wait, according to\n * Javascript that's perfectly correct. When Javascript ends up seeing the\n * constant 0xff80, it has no notion that it is actually a signed number. It\n * assumes that we've input the unsigned value 0xff80. Thus, when it does the\n * binary negation, it casts it into a signed value, (positive 0xff80). Then\n * when you perform binary negation on that, it turns it into a negative number.\n *\n * Instead, we're going to have to use the following general formula, that works\n * in a rather Javascript friendly way. I'm glad we don't support this kind of\n * weird numbering scheme in the kernel.\n *\n * (BIT-MAX - (unsigned)val + 1) * -1\n *\n * The astute observer, may think that this doesn't make sense for 8-bit numbers\n * (really it isn't necessary for them). However, when you get 16-bit numbers,\n * you do. Let's go back to our prior example and see how this will look:\n *\n * (0xffff - 0xff80 + 1) * -1\n * (0x007f + 1) * -1\n * (0x0080) * -1\n */\nBuffer.prototype.readInt8 = function(offset, noAssert) {\n  var buffer = this;\n  var neg;\n\n  if (!noAssert) {\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  neg = buffer.parent[buffer.offset + offset] & 0x80;\n  if (!neg) {\n    return (buffer.parent[buffer.offset + offset]);\n  }\n\n  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);\n};\n\nfunction readInt16(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  val = readUInt16(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x8000;\n  if (!neg) {\n    return val;\n  }\n\n  return (0xffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt16LE = function(offset, noAssert) {\n  return readInt16(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt16BE = function(offset, noAssert) {\n  return readInt16(this, offset, true, noAssert);\n};\n\nfunction readInt32(buffer, offset, isBigEndian, noAssert) {\n  var neg, val;\n\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  val = readUInt32(buffer, offset, isBigEndian, noAssert);\n  neg = val & 0x80000000;\n  if (!neg) {\n    return (val);\n  }\n\n  return (0xffffffff - val + 1) * -1;\n}\n\nBuffer.prototype.readInt32LE = function(offset, noAssert) {\n  return readInt32(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readInt32BE = function(offset, noAssert) {\n  return readInt32(this, offset, true, noAssert);\n};\n\nfunction readFloat(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.readFloatLE = function(offset, noAssert) {\n  return readFloat(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readFloatBE = function(offset, noAssert) {\n  return readFloat(this, offset, true, noAssert);\n};\n\nfunction readDouble(buffer, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset + 7 < buffer.length,\n        'Trying to read beyond buffer length');\n  }\n\n  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.readDoubleLE = function(offset, noAssert) {\n  return readDouble(this, offset, false, noAssert);\n};\n\nBuffer.prototype.readDoubleBE = function(offset, noAssert) {\n  return readDouble(this, offset, true, noAssert);\n};\n\n\n/*\n * We have to make sure that the value is a valid integer. This means that it is\n * non-negative. It has no fractional component and that it does not exceed the\n * maximum allowed value.\n *\n *      value           The number to check for validity\n *\n *      max             The maximum value\n */\nfunction verifuint(value, max) {\n  assert.ok(typeof (value) == 'number',\n      'cannot write a non-number as a number');\n\n  assert.ok(value >= 0,\n      'specified a negative value for writing an unsigned value');\n\n  assert.ok(value <= max, 'value is larger than maximum value for type');\n\n  assert.ok(Math.floor(value) === value, 'value has a fractional component');\n}\n\nBuffer.prototype.writeUInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'trying to write beyond buffer length');\n\n    verifuint(value, 0xff);\n  }\n\n  buffer.parent[buffer.offset + offset] = value;\n};\n\nfunction writeUInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'trying to write beyond buffer length');\n\n    verifuint(value, 0xffff);\n  }\n\n  if (isBigEndian) {\n    buffer.parent[buffer.offset + offset] = (value & 0xff00) >>> 8;\n    buffer.parent[buffer.offset + offset + 1] = value & 0x00ff;\n  } else {\n    buffer.parent[buffer.offset + offset + 1] = (value & 0xff00) >>> 8;\n    buffer.parent[buffer.offset + offset] = value & 0x00ff;\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt16BE = function(value, offset, noAssert) {\n  writeUInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeUInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'trying to write beyond buffer length');\n\n    verifuint(value, 0xffffffff);\n  }\n\n  if (isBigEndian) {\n    buffer.parent[buffer.offset + offset] = (value >>> 24) & 0xff;\n    buffer.parent[buffer.offset + offset + 1] = (value >>> 16) & 0xff;\n    buffer.parent[buffer.offset + offset + 2] = (value >>> 8) & 0xff;\n    buffer.parent[buffer.offset + offset + 3] = value & 0xff;\n  } else {\n    buffer.parent[buffer.offset + offset + 3] = (value >>> 24) & 0xff;\n    buffer.parent[buffer.offset + offset + 2] = (value >>> 16) & 0xff;\n    buffer.parent[buffer.offset + offset + 1] = (value >>> 8) & 0xff;\n    buffer.parent[buffer.offset + offset] = value & 0xff;\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeUInt32BE = function(value, offset, noAssert) {\n  writeUInt32(this, value, offset, true, noAssert);\n};\n\n\n/*\n * We now move onto our friends in the signed number category. Unlike unsigned\n * numbers, we're going to have to worry a bit more about how we put values into\n * arrays. Since we are only worrying about signed 32-bit values, we're in\n * slightly better shape. Unfortunately, we really can't do our favorite binary\n * & in this system. It really seems to do the wrong thing. For example:\n *\n * > -32 & 0xff\n * 224\n *\n * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of\n * this aren't treated as a signed number. Ultimately a bad thing.\n *\n * What we're going to want to do is basically create the unsigned equivalent of\n * our representation and pass that off to the wuint* functions. To do that\n * we're going to do the following:\n *\n *  - if the value is positive\n *      we can pass it directly off to the equivalent wuint\n *  - if the value is negative\n *      we do the following computation:\n *         mb + val + 1, where\n *         mb   is the maximum unsigned value in that byte size\n *         val  is the Javascript negative integer\n *\n *\n * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If\n * you do out the computations:\n *\n * 0xffff - 128 + 1\n * 0xffff - 127\n * 0xff80\n *\n * You can then encode this value as the signed version. This is really rather\n * hacky, but it should work and get the job done which is our goal here.\n */\n\n/*\n * A series of checks to make sure we actually have a signed 32-bit number\n */\nfunction verifsint(value, max, min) {\n  assert.ok(typeof (value) == 'number',\n      'cannot write a non-number as a number');\n\n  assert.ok(value <= max, 'value larger than maximum allowed value');\n\n  assert.ok(value >= min, 'value smaller than minimum allowed value');\n\n  assert.ok(Math.floor(value) === value, 'value has a fractional component');\n}\n\nfunction verifIEEE754(value, max, min) {\n  assert.ok(typeof (value) == 'number',\n      'cannot write a non-number as a number');\n\n  assert.ok(value <= max, 'value larger than maximum allowed value');\n\n  assert.ok(value >= min, 'value smaller than minimum allowed value');\n}\n\nBuffer.prototype.writeInt8 = function(value, offset, noAssert) {\n  var buffer = this;\n\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifsint(value, 0x7f, -0x80);\n  }\n\n  if (value >= 0) {\n    buffer.writeUInt8(value, offset, noAssert);\n  } else {\n    buffer.writeUInt8(0xff + value + 1, offset, noAssert);\n  }\n};\n\nfunction writeInt16(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 1 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifsint(value, 0x7fff, -0x8000);\n  }\n\n  if (value >= 0) {\n    writeUInt16(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt16LE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt16BE = function(value, offset, noAssert) {\n  writeInt16(this, value, offset, true, noAssert);\n};\n\nfunction writeInt32(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifsint(value, 0x7fffffff, -0x80000000);\n  }\n\n  if (value >= 0) {\n    writeUInt32(buffer, value, offset, isBigEndian, noAssert);\n  } else {\n    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);\n  }\n}\n\nBuffer.prototype.writeInt32LE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeInt32BE = function(value, offset, noAssert) {\n  writeInt32(this, value, offset, true, noAssert);\n};\n\nfunction writeFloat(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 3 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);\n  }\n\n  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,\n      23, 4);\n}\n\nBuffer.prototype.writeFloatLE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeFloatBE = function(value, offset, noAssert) {\n  writeFloat(this, value, offset, true, noAssert);\n};\n\nfunction writeDouble(buffer, value, offset, isBigEndian, noAssert) {\n  if (!noAssert) {\n    assert.ok(value !== undefined && value !== null,\n        'missing value');\n\n    assert.ok(typeof (isBigEndian) === 'boolean',\n        'missing or invalid endian');\n\n    assert.ok(offset !== undefined && offset !== null,\n        'missing offset');\n\n    assert.ok(offset + 7 < buffer.length,\n        'Trying to write beyond buffer length');\n\n    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);\n  }\n\n  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,\n      52, 8);\n}\n\nBuffer.prototype.writeDoubleLE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, false, noAssert);\n};\n\nBuffer.prototype.writeDoubleBE = function(value, offset, noAssert) {\n  writeDouble(this, value, offset, true, noAssert);\n};\n\nSlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;\nSlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;\nSlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;\nSlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;\nSlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;\nSlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;\nSlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;\nSlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;\nSlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;\nSlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;\nSlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;\nSlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;\nSlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;\nSlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;\nSlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;\nSlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;\nSlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;\nSlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;\nSlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;\nSlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;\nSlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;\nSlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;\nSlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;\nSlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;\nSlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;\nSlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;\nSlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;\nSlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;\n\n//@ sourceURL=/node_modules/buffer-browserify/index.js"
));

require.define("assert",Function(['require','module','exports','__dirname','__filename','process','global'],"// UTILITY\nvar util = require('util');\nvar Buffer = require(\"buffer\").Buffer;\nvar pSlice = Array.prototype.slice;\n\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.message = options.message;\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  var stackStartFunction = options.stackStartFunction || fail;\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  }\n};\nutil.inherits(assert.AssertionError, Error);\n\nfunction replacer(key, value) {\n  if (value === undefined) {\n    return '' + value;\n  }\n  if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {\n    return value.toString();\n  }\n  if (typeof value === 'function' || value instanceof RegExp) {\n    return value.toString();\n  }\n  return value;\n}\n\nfunction truncate(s, n) {\n  if (typeof s == 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\n\nassert.AssertionError.prototype.toString = function() {\n  if (this.message) {\n    return [this.name + ':', this.message].join(' ');\n  } else {\n    return [\n      this.name + ':',\n      truncate(JSON.stringify(this.actual, replacer), 128),\n      this.operator,\n      truncate(JSON.stringify(this.expected, replacer), 128)\n    ].join(' ');\n  }\n};\n\n// assert.AssertionError instanceof Error\n\nassert.AssertionError.__proto__ = Error.prototype;\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!!!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {\n    if (actual.length != expected.length) return false;\n\n    for (var i = 0; i < actual.length; i++) {\n      if (actual[i] !== expected[i]) return false;\n    }\n\n    return true;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (typeof actual != 'object' && typeof expected != 'object') {\n    return actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b) {\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b);\n  }\n  try {\n    var ka = Object.keys(a),\n        kb = Object.keys(b),\n        key, i;\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key])) return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (expected instanceof RegExp) {\n    return expected.test(actual);\n  } else if (actual instanceof expected) {\n    return true;\n  } else if (expected.call({}, actual) === true) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  try {\n    block();\n  } catch (e) {\n    actual = e;\n  }\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail('Missing expected exception' + message);\n  }\n\n  if (!shouldThrow && expectedException(actual, expected)) {\n    fail('Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\n};\n\nassert.ifError = function(err) { if (err) {throw err;}};\n\n//@ sourceURL=assert"
));

require.define("/node_modules/buffer-browserify/node_modules/base64-js/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"lib/b64.js\"}\n//@ sourceURL=/node_modules/buffer-browserify/node_modules/base64-js/package.json"
));

require.define("/node_modules/buffer-browserify/node_modules/base64-js/lib/b64.js",Function(['require','module','exports','__dirname','__filename','process','global'],"(function (exports) {\n\t'use strict';\n\n\tvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n\tfunction b64ToByteArray(b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr;\n\t\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow 'Invalid string. Length must be a multiple of 4';\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tplaceHolders = b64.indexOf('=');\n\t\tplaceHolders = placeHolders > 0 ? b64.length - placeHolders : 0;\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);\n\t\t\tarr.push((tmp & 0xFF0000) >> 16);\n\t\t\tarr.push((tmp & 0xFF00) >> 8);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);\n\t\t\tarr.push((tmp >> 8) & 0xFF);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tfunction uint8ToBase64(uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length;\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n\t\t};\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n\t\t\toutput += tripletToBase64(temp);\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1];\n\t\t\t\toutput += lookup[temp >> 2];\n\t\t\t\toutput += lookup[(temp << 4) & 0x3F];\n\t\t\t\toutput += '==';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);\n\t\t\t\toutput += lookup[temp >> 10];\n\t\t\t\toutput += lookup[(temp >> 4) & 0x3F];\n\t\t\t\toutput += lookup[(temp << 2) & 0x3F];\n\t\t\t\toutput += '=';\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tmodule.exports.toByteArray = b64ToByteArray;\n\tmodule.exports.fromByteArray = uint8ToBase64;\n}());\n\n//@ sourceURL=/node_modules/buffer-browserify/node_modules/base64-js/lib/b64.js"
));

require.define("/node_modules/buffer-browserify/buffer_ieee754.js",Function(['require','module','exports','__dirname','__filename','process','global'],"exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {\n  var e, m,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      nBits = -7,\n      i = isBE ? 0 : (nBytes - 1),\n      d = isBE ? 1 : -1,\n      s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity);\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {\n  var e, m, c,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),\n      i = isBE ? (nBytes - 1) : 0,\n      d = isBE ? -1 : 1,\n      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n//@ sourceURL=/node_modules/buffer-browserify/buffer_ieee754.js"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/package.json"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/client.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar Schema   = require('./lib/schema')\nvar Client   = require('./lib/client-opener')\nvar Buffered = require('./lib/buffered-opener')\n\nmodule.exports = function (schema, id) {\n  schema = Schema(schema, id)\n  var c = Client()\n  var b = Buffered(schema, id)\n  c.on('open', function () {\n    b.swap(c)\n  })\n  b.createStream = \n  b.createRemoteStream = c.createStream\n  return b\n}\n\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/client.js"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/lib/schema.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var parserx = require('parse-regexp')\n\n//don't make the timeout too large, because it will prevent the process from exiting...\nvar exports = module.exports = function (schema, id) {\n  if('function' == typeof schema)\n    return schema\n  if('__proto__' === id)\n    throw new Error('__proto__ is invalid id')\n\n  if(!id) throw new Error('schema requires node id')\n\n  var rules = []\n  for (var p in schema) {\n    rules.push({rx: parserx(p) || p, fn: schema[p]})\n  }\n\n  function match (key) {\n    if('object' === typeof key) return key\n    for (var i in rules) {\n      var r = rules[i]\n      var m = key.match(r.rx)\n      if(m && m.index === 0) {\n        var scuttlebutt = r.fn(key)\n        scuttlebutt.name = key\n        'function' === scuttlebutt.setId ? scuttlebutt.setId(id) : scuttlebutt.id = id\n        return scuttlebutt\n      }\n    }\n  }\n\n  match.schema = schema\n  match.rules = rules\n\n  return match\n}\n\nexports.schema = exports\n\nexports.cache =\nfunction (schema, open, onCache) {\n  var local = cached.local = {}\n  function cached (name, tail, cb) {\n    if('function' == typeof tail)\n      cb = tail, tail = true\n\n    //user *must not* pass a Scuttlebutt instance to cached open.\n    if('string' !== typeof name)\n      throw new Error('name must be string')\n\n    //so if this is passed a ready instance...\n    //and there is a cached instance... then pipe them together.\n    //hmm, but the caching should be ontop of the other layer...\n    //will this work?\n    //ah, if a scuttlebutt is passed, and there isn't one in the cache\n    //clone it and put the clone in the cache!\n    //else, pipe it to the cached instace.\n\n    //actually... should combine this into level-scuttlebutt\n    //then only one cache will be necessary.\n\n    //which will work better for reconnections.\n\n    //...so, need lots of tests here.\n\n    //yes, only one cache, the outer most open does not support\n    //opening with a scuttlebutt - but remote, and \n    //level-scuttlebutt do!\n    \n    //then there is only one cache...\n    //so, you always control the point of caching.\n    //no \"russian doll\" caching.\n\n    var cached = local[name]\n    if(cached && 'function' === typeof cached.clone) {\n      var n = cached.clone()\n      n.name = name\n      cb(null, n)\n      return n\n    }\n    var clone\n    var scuttlebutt = local[name] = schema(name)\n    scuttlebutt.name = name\n    open(scuttlebutt, tail, function (err, scuttlebutt) {\n      if(err) return cb(err)\n      cb(null, clone)\n    })\n\n    //will callback an error\n    if(!scuttlebutt) return\n\n    scuttlebutt.name = name\n    \n    //only scuttlebutts with clone can be cleanly cached.\n    if('function' === typeof scuttlebutt.clone) {\n      local[name] = scuttlebutt\n      clone = scuttlebutt.clone()\n      clone.name = name\n      if(onCache) onCache('clone', scuttlebutt.name)\n      //okay... have something to dispose the scuttlebutt when there are 0 streams.\n      //hmm, count streams... and emit an event 'unstream' or something?\n      //okay, if all the steams have closed but this one, then it means no one is using this,\n      //so close...\n      //TODO add this to level-scuttlebutt.\n\n      //OH, hang on... maybe DOMAINS is the right thing to use here...\n\n      var timer = null\n      scuttlebutt.on('unstream', function (n) {\n        if(n === 1) {\n          clearTimeout(timer)\n          timer = setTimeout(function () {\n            scuttlebutt.dispose()\n            if(onCache) onCache('uncache', scuttlebutt.name)\n          }, TIMEOUT*1.5)\n            //if an emitter was passed, imet\n        } else if(n > 1)\n          clearTimeout(timer)\n      })\n      scuttlebutt.on('dispose', function () {\n        delete local[name]\n      })\n    }\n    \n    return scuttlebutt\n  }\n\n  return cached\n}\n\nexports.sync = \nexports.open = function (schema, connect) {\n  //pass in a string name, or a scuttlebutt instance\n  //you want to reconnect to the server.\n  return function (name, tail, cb) {\n    if('function' == typeof tail)\n      cb = tail, tail = true\n\n    if('string' === typeof name)\n      throw new Error('expect cache to create Scuttlebutt for open')\n\n    var scuttlebutt = name\n    /*\n    if('string' === typeof name)\n      scuttlebutt = schema(name)\n    else {\n      scuttlebutt = name\n      name = scuttlebutt.name\n    }\n    */\n    var es = scuttlebutt.createStream()\n    var stream = connect(scuttlebutt.name)\n\n    if(!stream)\n      return cb(new Error('unable to connect'))\n\n    stream.pipe(es).pipe(stream)\n\n    var ready = false\n    es.once('sync', function () {\n      if(ready) return\n      ready = true\n\n      //cb the stream we are loading the scuttlebutt from,\n      //incase it errors after we cb?\n      //I'm not sure about this usecase.\n      //Actually, just leave that feature out!\n      //that way I don't have to break API when I realize it was a bad idea.\n      if(cb)    cb(null, scuttlebutt)\n      if(!tail) es.end()\n    })\n    //hmm, this has no way to detect that the stream has errored\n    stream.once('error', function (err) {\n      if(!ready) return cb(err)\n    })\n\n    return scuttlebutt\n  }\n}\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/lib/schema.js"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/parse-regexp/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/parse-regexp/package.json"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/parse-regexp/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var rx = /^\\/((?:\\\\\\/|[^\\/])+)\\/(.*)$/\nmodule.exports = function (string) {\n  var m = rx.exec(string)\n  return m ? new RegExp(m[1], m[2]) : null\n}\n\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/parse-regexp/index.js"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/lib/client-opener.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var EventEmitter = require('events').EventEmitter\nvar MuxDemux     = require('mux-demux')\nvar remoteOpen = function (connect) {\n  //pass in a string name, or a scuttlebutt instance\n  //you want to reconnect to the server.\n  return function (scuttlebutt, tail, cb) {\n    if('function' == typeof tail)\n      cb = tail, tail = true\n\n    if('object' !== typeof scuttlebutt)\n      throw new Error('expect Scuttlebutt, not ' + typeof scuttlebutt)\n\n    var es = scuttlebutt.createStream(), stream\n    try {\n      stream = connect(scuttlebutt.name)\n    } catch (err) { return cb(err) }\n\n    if(!stream)\n      return cb(new Error('unable to connect'))\n\n    stream.pipe(es).pipe(stream)\n\n    var ready = false\n    es.once('sync', function () {\n      if(ready) return\n      ready = true\n\n      //cb the stream we are loading the scuttlebutt from,\n      //incase it errors after we cb?\n      //I'm not sure about this usecase.\n      //Actually, just leave that feature out!\n      //that way I don't have to break API when I realize it was a bad idea.\n      if(cb)    cb(null, scuttlebutt)\n      if(!tail) es.end()\n    })\n    //hmm, this has no way to detect that the stream has errored\n    stream.once('error', function (err) {\n      if(!ready) return cb(err)\n    })\n\n    return scuttlebutt\n  }\n}\n\nmodule.exports = function () {\n\n  var opener = new EventEmitter()\n  var mx = null\n\n  opener.open = remoteOpen(function (name) {\n    if(!mx) throw new Error('scuttlebutt remoteOpener must be connected')\n    return mx.createStream(name)\n  })\n\n  opener.view = function () {\n    var args = [].slice.call(arguments)\n    return mx.createStream(args)\n  }\n\n  //create stream...\n  opener.createStream = function () {\n    if(mx) throw new Error('remoteOpener may only connect to one server')\n\n    mx = MuxDemux(function (stream) {\n      stream.error(new Error('remoteOpener is client only - cannot recieve stream'))\n    })\n\n    var ended = false\n\n    function onEnd () {\n      if(ended) return ended = true\n      mx.removeListener('end',   onEnd)\n      mx.removeListener('close', onEnd)\n      mx.removeListener('error', onEnd)\n      mx.removeAllListeners()\n      mx = null\n      opener.emit('close')\n    }\n\n    mx.on('close', onEnd)\n    mx.on('end',   onEnd)\n    mx.on('error', onEnd)\n\n    process.nextTick(function () {\n      opener.emit('open', mx)\n      mx.resume()\n    })\n    return mx\n  }\n\n  return opener\n}\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/lib/client-opener.js"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/mux-demux/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/mux-demux/package.json"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/mux-demux/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"'use strict';\n\nvar through = require('through')\n  , extend = require('xtend')\n  , duplex = require('duplex')\n  , serializer = require('stream-serializer')\n\nfunction MuxDemux (opts, onConnection) {\n  if('function' === typeof opts)\n    onConnection = opts, opts = null\n  opts = opts || {}\n\n  function createID() {\n    return (\n      Math.random().toString(16).slice(2) +\n      Math.random().toString(16).slice(2)\n    )\n  }\n\n  var streams = {}, streamCount = 0\n  var md = duplex()//.resume()\n\n  md.on('_data', function (data) {\n    if(!(Array.isArray(data)\n      && 'string' === typeof data[0]\n      && '__proto__' !== data[0]\n      && 'string' === typeof data[1]\n      && '__proto__' !== data[1]\n    )) return\n    var id = data.shift()\n    var event = data[0]\n    var s = streams[id]\n    if(!s) {\n      if(event == 'close')\n        return\n      if(event != 'new')\n        return outer.emit('unknown', id)\n      md.emit('connection', createStream(id, data[1].meta, data[1].opts))\n    }\n    else if (event === 'pause')\n      s.paused = true\n    else if (event === 'resume') {\n      var p = s.paused\n      s.paused = false\n      if(p) s.emit('drain')\n    }\n    else if (event === 'error') {\n      var error = data[1]\n      if (typeof error === 'string') {\n        s.emit('error', new Error(error))\n      } else if (typeof error.message === 'string') {\n        var e = new Error(error.message)\n        extend(e, error)\n        s.emit('error', e)\n      } else {\n        s.emit('error', error)\n      }\n    }\n    else {\n      s.emit.apply(s, data)\n    }\n  })\n  .on('_end', function () {\n    destroyAll()\n    md._end()\n  })\n\n  function destroyAll (_err) {\n    md.removeListener('end', destroyAll)\n    md.removeListener('error', destroyAll)\n    md.removeListener('close', destroyAll)\n    var err = _err || new Error ('unexpected disconnection')\n    for (var i in streams) {\n      var s = streams[i]\n      s.destroyed = true\n      if (opts.error !== true) {\n        s.end()\n      } else {\n        s.emit('error', err)\n        s.destroy()\n      }\n    }\n  }\n\n  //end the stream once sub-streams have ended.\n  //(waits for them to close, like on a tcp server)\n\n  function createStream(id, meta, opts) {\n    streamCount ++\n    var s = through(function (data) {\n      if(!this.writable) {\n        var err = Error('stream is not writable: ' + id)\n        err.stream = this\n        return outer.emit(\"error\", err)\n      }\n      md._data([s.id, 'data', data])\n    }, function () {\n      md._data([s.id, 'end'])\n      if (this.readable && !opts.allowHalfOpen && !this.ended) {\n        this.emit(\"end\")\n      }\n    })\n    s.pause = function () {\n      md._data([s.id, 'pause'])\n    }\n    s.resume = function () {\n      md._data([s.id, 'resume'])\n    }\n    s.error = function (message) {\n      md._data([s.id, 'error', message])\n    }\n    s.once('close', function () {\n      delete streams[id]\n      streamCount --\n      md._data([s.id, 'close'])\n      if(streamCount === 0)\n        md.emit('zero')\n    })\n    s.writable = opts.writable\n    s.readable = opts.readable\n    streams[s.id = id] = s\n    s.meta = meta\n    return s\n  }\n\n  var outer = serializer(opts.wrapper)(md)\n\n  if(md !== outer)\n    md.on('connection', function (stream) {\n      outer.emit('connection', stream)\n    })\n\n  outer.close = function (cb) {\n    md.once('zero', function () {\n      md._end()\n      if(cb) cb()\n    })\n    return this\n  }\n\n  if(onConnection)\n    outer.on('connection', onConnection)\n\n  outer.on('connection', function (stream) {\n    //if mux-demux recieves a stream but there is nothing to handle it,\n    //then return an error to the other side.\n    //still trying to think of the best error message.\n    if(outer.listeners('connection').length === 1)\n      stream.error('remote end lacks connection listener ' \n        + outer.listeners('connection').length)\n  })\n\n  var pipe = outer.pipe\n  outer.pipe = function (dest, opts) {\n    pipe.call(outer, dest, opts)\n    md.on('end', destroyAll)\n    md.on('close', destroyAll)\n    md.on('error', destroyAll)\n    return dest\n  }\n\n  outer.createStream = function (meta, opts) {\n    opts = opts || {}\n    if (!opts.writable && !opts.readable)\n      opts.readable = opts.writable = true\n    var s = createStream(createID(), meta, opts)\n    var _opts = {writable: opts.readable, readable: opts.writable}\n    md._data([s.id, 'new', {meta: meta, opts: _opts}])\n    return s\n  }\n  outer.createWriteStream = function (meta) {\n    return outer.createStream(meta, {writable: true, readable: false})\n  }\n  outer.createReadStream = function (meta) {\n    return outer.createStream(meta, {writable: false, readable: true})\n  }\n\n  return outer\n}\n\nmodule.exports = MuxDemux\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/mux-demux/index.js"
));

require.define("/node_modules/rumours/node_modules/through/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/rumours/node_modules/through/package.json"
));

require.define("/node_modules/rumours/node_modules/through/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Stream = require('stream')\n\n// through\n//\n// a stream that does nothing but re-emit the input.\n// useful for aggregating a series of changing but not ending streams into one stream)\n\n\n\nexports = module.exports = through\nthrough.through = through\n\n//create a readable writable stream.\n\nfunction through (write, end) {\n  write = write || function (data) { this.queue(data) }\n  end = end || function () { this.queue(null) }\n\n  var ended = false, destroyed = false, buffer = []\n  var stream = new Stream()\n  stream.readable = stream.writable = true\n  stream.paused = false\n\n  stream.write = function (data) {\n    write.call(this, data)\n    return !stream.paused\n  }\n\n  function drain() {\n    while(buffer.length && !stream.paused) {\n      var data = buffer.shift()\n      if(null === data)\n        return stream.emit('end')\n      else\n        stream.emit('data', data)\n    }\n  }\n\n  stream.queue = function (data) {\n    buffer.push(data)\n    drain()\n    return stream\n  }\n\n  //this will be registered as the first 'end' listener\n  //must call destroy next tick, to make sure we're after any\n  //stream piped from here.\n  //this is only a problem if end is not emitted synchronously.\n  //a nicer way to do this is to make sure this is the last listener for 'end'\n\n  stream.on('end', function () {\n    stream.readable = false\n    if(!stream.writable)\n      process.nextTick(function () {\n        stream.destroy()\n      })\n  })\n\n  function _end () {\n    stream.writable = false\n    end.call(stream)\n    if(!stream.readable)\n      stream.destroy()\n  }\n\n  stream.end = function (data) {\n    if(ended) return\n    ended = true\n    if(arguments.length) stream.write(data)\n    _end() // will emit or queue\n    return stream\n  }\n\n  stream.destroy = function () {\n    if(destroyed) return\n    destroyed = true\n    ended = true\n    buffer.length = 0\n    stream.writable = stream.readable = false\n    stream.emit('close')\n    return stream\n  }\n\n  stream.pause = function () {\n    if(stream.paused) return\n    stream.paused = true\n    stream.emit('pause')\n    return stream\n  }\n  stream.resume = function () {\n    if(stream.paused) {\n      stream.paused = false\n    }\n    drain()\n    //may have become paused again,\n    //as drain emits 'data'.\n    if(!stream.paused)\n      stream.emit('drain')\n    return stream\n  }\n  return stream\n}\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/through/index.js"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/mux-demux/node_modules/xtend/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/mux-demux/node_modules/xtend/package.json"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/mux-demux/node_modules/xtend/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = extend\n\nfunction extend(target) {\n    for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i],\n            keys = Object.keys(source)\n\n        for (var j = 0; j < keys.length; j++) {\n            var name = keys[j]\n            target[name] = source[name]\n        }\n    }\n\n    return target\n}\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/mux-demux/node_modules/xtend/index.js"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/duplex/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/duplex/package.json"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/duplex/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Stream = require('stream')\n\nmodule.exports = function (write, end) {\n  var stream = new Stream() \n  var buffer = [], ended = false, destroyed = false, emitEnd\n  stream.writable = stream.readable = true\n  stream.paused = false\n  stream._paused = false\n  stream.buffer = buffer\n  \n  stream\n    .on('pause', function () {\n      stream._paused = true\n    })\n    .on('drain', function () {\n      stream._paused = false\n    })\n   \n  function destroySoon () {\n    process.nextTick(stream.destroy.bind(stream))\n  }\n\n  if(write)\n    stream.on('_data', write)\n  if(end)\n    stream.on('_end', end)\n\n  //destroy the stream once both ends are over\n  //but do it in nextTick, so that other listeners\n  //on end have time to respond\n  stream.once('end', function () { \n    stream.readable = false\n    if(!stream.writable) {\n      process.nextTick(function () {\n        stream.destroy()\n      })\n    }\n  })\n\n  stream.once('_end', function () { \n    stream.writable = false\n    if(!stream.readable)\n      stream.destroy()\n  })\n\n  // this is the default write method,\n  // if you overide it, you are resposible\n  // for pause state.\n\n  \n  stream._data = function (data) {\n    if(!stream.paused && !buffer.length)\n      stream.emit('data', data)\n    else \n      buffer.push(data)\n    return !(stream.paused || buffer.length)\n  }\n\n  stream._end = function (data) { \n    if(data) stream._data(data)\n    if(emitEnd) return\n    emitEnd = true\n    //destroy is handled above.\n    stream.drain()\n  }\n\n  stream.write = function (data) {\n    stream.emit('_data', data)\n    return !stream._paused\n  }\n\n  stream.end = function () {\n    stream.writable = false\n    if(stream.ended) return\n    stream.ended = true\n    stream.emit('_end')\n  }\n\n  stream.drain = function () {\n    if(!buffer.length && !emitEnd) return\n    //if the stream is paused after just before emitEnd()\n    //end should be buffered.\n    while(!stream.paused) {\n      if(buffer.length) {\n        stream.emit('data', buffer.shift())\n        if(buffer.length == 0) {\n          stream.emit('_drain')\n        }\n      }\n      else if(emitEnd && stream.readable) {\n        stream.readable = false\n        stream.emit('end')\n        return\n      } else {\n        //if the buffer has emptied. emit drain.\n        return true\n      }\n    }\n  }\n  var started = false\n  stream.resume = function () {\n    //this is where I need pauseRead, and pauseWrite.\n    //here the reading side is unpaused,\n    //but the writing side may still be paused.\n    //the whole buffer might not empity at once.\n    //it might pause again.\n    //the stream should never emit data inbetween pause()...resume()\n    //and write should return !buffer.length\n    started = true\n    stream.paused = false\n    stream.drain() //will emit drain if buffer empties.\n    return stream\n  }\n\n  stream.destroy = function () {\n    if(destroyed) return\n    destroyed = ended = true     \n    buffer.length = 0\n    stream.emit('close')\n  }\n  var pauseCalled = false\n  stream.pause = function () {\n    started = true\n    stream.paused = true\n    stream.emit('_pause')\n    return stream\n  }\n  stream._pause = function () {\n    if(!stream._paused) {\n      stream._paused = true\n      stream.emit('pause')\n    }\n    return this\n  }\n  stream.paused = true\n  process.nextTick(function () {\n    //unless the user manually paused\n    if(started) return\n    stream.resume()\n  })\n \n  return stream\n}\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/duplex/index.js"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/mux-demux/node_modules/stream-serializer/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/mux-demux/node_modules/stream-serializer/package.json"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/mux-demux/node_modules/stream-serializer/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar EventEmitter = require('events').EventEmitter\n\nexports = module.exports = function (wrapper) {\n\n  if('function' == typeof wrapper)\n    return wrapper\n  \n  return exports[wrapper] || exports.json\n}\n\nexports.json = function (stream) {\n\n  var write = stream.write\n  var soFar = ''\n\n  function parse (line) {\n    var js\n    try {\n      js = JSON.parse(line)\n      //ignore lines of whitespace...\n    } catch (err) { \n      return console.error('invalid JSON', line)\n    }\n    if(js !== undefined)\n      write.call(stream, js)\n  }\n\n  function onData (data) {\n    var lines = (soFar + data).split('\\n')\n    soFar = lines.pop()\n    while(lines.length) {\n      parse(lines.shift())\n    }\n  }\n\n  stream.write = onData\n  \n  var end = stream.end\n\n  stream.end = function (data) {\n    if(data)\n      stream.write(data)\n    //if there is any left over...\n    if(soFar) {\n      parse(soFar)\n    }\n    return end.call(stream)\n  }\n\n  stream.emit = function (event, data) {\n\n    if(event == 'data') {\n      data = JSON.stringify(data) + '\\n'\n    }\n    //since all stream events only use one argument, this is okay...\n    EventEmitter.prototype.emit.call(stream, event, data)\n  }\n\n  return stream\n//  return es.pipeline(es.split(), es.parse(), stream, es.stringify())\n}\n\nexports.raw = function (stream) {\n  return stream\n}\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/node_modules/mux-demux/node_modules/stream-serializer/index.js"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/lib/buffered-opener.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var EventEmitter = require('events').EventEmitter\nvar Cache        = require('./cache')\nvar through      = require('through')\n\nmodule.exports = function (schema, id) {\n  var opener = new EventEmitter()\n  var _opener\n\n  if('string' !== typeof id)\n    throw new Error('id must be string')\n\n  opener.swap = function (newOpener) {\n    if(_opener) throw new Error('already has opener, expects opener.emit(\"close\")')\n    if(!newOpener) throw new Error('cannot swap null')\n    _opener = newOpener\n    _opener.once('close', function () {\n      _opener = null\n    })\n    ready()\n    return opener\n  }\n\n  var toOpen = [], toView = [], _open, _view\n\n  //cache at this level, not on scuttlebutt.open\n\n  opener.open = Cache(schema, id, function (scuttlebutt, tail, cb) {\n    if('object' !== typeof scuttlebutt)\n      throw new Error('expected Scuttlebutt')\n\n    if(!_opener)\n      return toOpen.push([scuttlebutt, tail, cb])\n\n    _opener.open(scuttlebutt, tail, cb)\n    return scuttlebutt\n  })\n\n  var cache = opener.open.local\n\n  opener.view = function () {\n    var args = [].slice.call(arguments)\n    if(_opener)\n      return _opener.view.apply(null, args)\n    var stream = through()\n    toView.push({args: args, stream: stream})\n    return stream\n  }\n\n  function ready () {\n    var opening = {}\n    while(_opener && toOpen.length) {\n      var args = toOpen.shift()\n      opening[args[0].name] = true\n      _opener.open.apply(null, args)\n    }\n    while(_opener && toView.length) {\n      var v = toView.shift()\n      _opener.view.apply(null, v.args)\n        .on('error', function (err) {\n          //because stream errors are not propagated...\n          v.stream.emit('error', err)\n        }).pipe(v.stream)\n    }\n\n    //reopen anything that was closed..\n    for(var key in cache)\n      if(!opening[key]) {\n        _opener.open(cache[key], true, function () {})\n      }\n  }\n\n  return opener\n}\n\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/lib/buffered-opener.js"
));

require.define("/node_modules/rumours/node_modules/level-scuttlebutt/lib/cache.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Schema  = require('./schema')\nvar TIMEOUT = 100\n\nmodule.exports = function (schema, id, open, onCache) {\n  var local = cached.local = {}\n  schema = Schema(schema, id)\n  if('string' != typeof id)\n    throw new Error('id must be string')\n  if('function' !== typeof open)\n    throw new Error('open must be function')\n  function cached (name, tail, cb) {\n    if('function' == typeof tail)\n      cb = tail, tail = true\n\n    //user *must not* pass a Scuttlebutt instance to cached open.\n    if('string' !== typeof name)\n      throw new Error('name must be string')\n\n    //so if this is passed a ready instance...\n    //and there is a cached instance... then pipe them together.\n    //hmm, but the caching should be ontop of the other layer...\n    //will this work?\n    //ah, if a scuttlebutt is passed, and there isn't one in the cache\n    //clone it and put the clone in the cache!\n    //else, pipe it to the cached instace.\n\n    //actually... should combine this into level-scuttlebutt\n    //then only one cache will be necessary.\n\n    //which will work better for reconnections.\n\n    //...so, need lots of tests here.\n\n    //yes, only one cache, the outer most open does not support\n    //opening with a scuttlebutt - but remote, and \n    //level-scuttlebutt do!\n    \n    //then there is only one cache...\n    //so, you always control the point of caching.\n    //no \"russian doll\" caching.\n\n    var cached = local[name]\n    if(cached && 'function' === typeof cached.clone) {\n      var n = cached.clone()\n      n.name = name\n      cb(null, n)\n      return n\n    }\n\n    var clone\n    var scuttlebutt = local[name] = schema(name)\n    if(!scuttlebutt)\n      return cb(new Error('no constructor for:'+name))\n\n    scuttlebutt.name = name\n\n    open(scuttlebutt, tail, function (err, scuttlebutt) {\n      if(err) return cb(err)\n      cb(null, clone)\n    })\n\n    //will callback an error\n    if(!scuttlebutt) return\n\n    scuttlebutt.name = name\n    \n    //only scuttlebutts with clone can be cleanly cached.\n    if('function' === typeof scuttlebutt.clone) {\n      local[name] = scuttlebutt\n      clone = scuttlebutt.clone()\n      clone._parent = scuttlebutt\n      clone.name = name\n      if(onCache) onCache('clone', scuttlebutt.name)\n      //okay... have something to dispose the scuttlebutt when there are 0 streams.\n      //hmm, count streams... and emit an event 'unstream' or something?\n      //okay, if all the steams have closed but this one, then it means no one is using this,\n      //so close...\n      //TODO add this to level-scuttlebutt.\n\n      //OH, hang on... maybe DOMAINS is the right thing to use here...\n\n      var timer = null\n      scuttlebutt.on('unclone', function (n) {\n        if(n === 0) {\n          clearTimeout(timer)\n          timer = setTimeout(function () {\n            if(scuttlebutt._clones) return\n            scuttlebutt.dispose()\n            if(onCache) onCache('uncache', scuttlebutt.name)\n          }, TIMEOUT*1.5)\n            //if an emitter was passed, imet\n        } else if(n > 1)\n          clearTimeout(timer)\n      })\n      scuttlebutt.on('dispose', function () {\n        delete local[name]\n      })\n    }\n    \n    return scuttlebutt\n  }\n\n  return cached\n}\n\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/level-scuttlebutt/lib/cache.js"
));

require.define("/node_modules/rumours/node_modules/udid/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"browserify\":\"./browser.js\"}\n//@ sourceURL=/node_modules/rumours/node_modules/udid/package.json"
));

require.define("/node_modules/rumours/node_modules/udid/browser.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar tabs = require('count-tabs')()\n\nmodule.exports = function (name) {\n\n  //the client side will have different domains,\n  //and thus different localStorages per app,\n  //so we don't need to use the name...\n  //however, still use the same api as on the server.\n\n  if(!name)\n    throw new Error('provide app name')\n\n  return tabs.id\n  \n}\n  \n\n//@ sourceURL=/node_modules/rumours/node_modules/udid/browser.js"
));

require.define("/node_modules/rumours/node_modules/udid/node_modules/count-tabs/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/udid/node_modules/count-tabs/package.json"
));

require.define("/node_modules/rumours/node_modules/udid/node_modules/count-tabs/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var EventEmitter = require('events').EventEmitter\nvar hash = require('shasum')\n\nvar id\nvar KEY = 'tabsQuery'\nvar tabs = {}\nvar pattern = /^tabs:(.+)$/\nvar emitter, oldUp\n\n//NOTE. this module uses a global singleton,\n//so the first thing to require it must set the interval\n//else, you will be stuck with the default.\n\n//disabling the interval option for now.\n//is unstable under 500 ms.\nmodule.exports = function (/*interval, */listener) {\n  //if('function' === typeof interval)\n  //  listener = interval, interval = 1000\n  var interval = 500\n\n  function attach() {\n    if(listener) {\n      emitter.on('change', listener)\n      listener.call(emitter, emitter.up, 0)\n    }\n  }\n\n  if(emitter) {\n    attach()\n    return emitter\n  }\n\n  emitter = new EventEmitter()\n\n  emitter.tabs = tabs\n\n  var start = Date.now()\n  for( var key in localStorage) {\n    var m\n    if(m = pattern.exec(key)) {\n      var _id = m[1]\n      if(!id && Number(localStorage[key]) < start - interval*2) {\n        emitter.id = id = _id\n        localStorage['tabs:'+id] = start //claim this key\n      }\n      tabs[_id] = Number(localStorage[key])\n    }\n  }\n\n  if(!id) {\n    emitter.id = id = hash(Date.now())\n    tabs[id] = localStorage['tabs:'+id] = start//claim this key\n  }\n\n  function count () {\n    var now = Date.now()\n    \n    for(var _id in tabs) {\n      if(Number(tabs[_id]) < now - interval*2) {\n        delete tabs[_id]\n        //don't delete old ids, so they can be reused,\n        //making for smaller vector-clocks.\n        //delete localStorage['tabs:'+_id]\n        emitter.emit('close', _id)\n        change = true\n      }\n    }\n    var up = Object.keys(tabs).sort()\n    if(!oldUp || up.join('|') != oldUp.join('|')) {\n      var l = oldUp ? oldUp.length : 0\n      emitter.up = up.length\n      oldUp = up\n      emitter.emit('change', tabs, l)\n    }\n  }\n\n  count()\n\n  window.addEventListener('storage', function (se) {\n    if(m = pattern.exec(se.key)) {\n      var _id = m[1]\n      if(se.newValue)\n        tabs[_id] = Number(se.newValue)\n      else\n        delete tabs[_id] \n      count()\n    }\n  })  \n\n  setInterval(function () {\n    tabs[id] = localStorage['tabs:'+id] = Date.now()\n    count()\n  }, interval)\n\n  attach()\n\n  return emitter\n}\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/udid/node_modules/count-tabs/index.js"
));

require.define("/node_modules/rumours/schema.js",Function(['require','module','exports','__dirname','__filename','process','global'],"function create (con) {\n  return function () {\n    return new con()\n  }\n}\n\n//all the scuttlebutt subclasses written so far.\n\nmodule.exports = {\n  'model': create(require('scuttlebutt/model')),\n  'events': create(require('scuttlebutt/events')),\n  'r-edit': create(require('r-edit')),\n  'r-array': create(require('r-array')),\n  'crdt': create(require('crdt')),\n  'append-only': create(require('append-only')),\n  'expiry-model': create(require('expiry-model'))\n  //hmm, what about scuttlebucket?\n}\n\n\n//@ sourceURL=/node_modules/rumours/schema.js"
));

require.define("/node_modules/rumours/node_modules/scuttlebutt/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/scuttlebutt/package.json"
));

require.define("/node_modules/rumours/node_modules/scuttlebutt/model.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Scuttlebutt = require('./index')\nvar inherits = require('util').inherits\nvar each = require('iterate').each\nvar u = require('./util')\n\nmodule.exports = Model\n\ninherits(Model, Scuttlebutt)\n\nfunction Model (opts) {\n  if(!(this instanceof Model)) return new Model(opts)\n  Scuttlebutt.call(this, opts)\n  this.store = {}\n}\n\nvar m = Model.prototype\n\nm.set = function (k, v) {\n  if(k==='__proto__') return u.protoIsIllegal(this)\n  this.localUpdate([k, v])\n  return this\n}\n\n\nm.get = function (k) {\n  if(k==='__proto__') return u.protoIsIllegal(this)\n  if(this.store[k])\n    return this.store[k][0][1]\n}\n\nm.keys = function () {\n  var a = []\n  for (var k in this.store)\n    a.push(k)\n  return a\n}\n\nm.forEach =\nm.each = function (iter) {\n  for (var k in this.store)\n    iter(this.store[k][0][1], k, this.store)\n  return this\n}\n\n//return this history since sources.\n//sources is a hash of { ID: TIMESTAMP }\n\nm.applyUpdate = function (update) {\n  var key = update[0][0]\n  if('__proto__' === key) return u.protoIsIllegal(this)\n  //ignore if we already have a more recent value\n  if('undefined' !== typeof this.store[key]\n    && this.store[key][1] > update[1])\n    return this.emit('_remove', update)\n\n  if(this.store[key]) this.emit('_remove', this.store[key])\n\n  this.store[key] = update\n  this.emit.apply(this, ['update'].concat(update))\n  this.emit('change', key, update[0][1])\n  this.emit('change:'+key, update[0][1])\n\n  return true\n}\n\nm.history = function (sources) {\n  var self = this\n  var h = []\n  each(this.store, function (e) {\n    if(u.filter(e, sources))\n      h.push(e)\n  })\n  return u.sort(h)\n}\n\nm.toJSON = function () {\n  var o = {}\n  for (var k in this.store)\n    o[k] = this.get(k)\n  return o\n}\n\n//@ sourceURL=/node_modules/rumours/node_modules/scuttlebutt/model.js"
));

require.define("/node_modules/rumours/node_modules/scuttlebutt/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var EventEmitter = require('events').EventEmitter\nvar i = require('iterate')\nvar duplex = require('duplex')\nvar inherits = require('util').inherits\nvar serializer = require('stream-serializer')\nvar u = require('./util')\nvar timestamp = require('monotonic-timestamp')\n\nexports = \nmodule.exports = Scuttlebutt\n\nexports.createID = u.createID\nexports.updateIsRecent = u.filter\nexports.filter = u.filter\nexports.timestamp = timestamp\n\nfunction dutyOfSubclass() {\n  throw new Error('method must be implemented by subclass')\n}\n\nfunction validate (data) {\n  if(!(Array.isArray(data) \n    && 'string' === typeof data[2]\n    && '__proto__'     !== data[2] //THIS WOULD BREAK STUFF\n    && 'number' === typeof data[1]\n  )) return false\n\n  return true\n}\n\nvar emit = EventEmitter.prototype.emit\n\ninherits (Scuttlebutt, EventEmitter)\n\nfunction Scuttlebutt (opts) {\n\n  if(!(this instanceof Scuttlebutt)) return new Scuttlebutt(opts)\n  var id = 'string' === typeof opts ? opts : opts && opts.id\n  this.sources = {}\n  this.setMaxListeners(Number.MAX_VALUE)\n  //count how many other instances we are replicating to.\n  this._streams = 0\n  if(opts && opts.sign && opts.verify) {\n    this.setId(opts.id || opts.createId())\n    this._sign   = opts.sign\n    this._verify = opts.verify\n  } else {\n    this.setId(id || u.createId())\n  }\n}\n\nvar sb = Scuttlebutt.prototype\n\nvar emit = EventEmitter.prototype.emit\n\nsb.applyUpdate = dutyOfSubclass\nsb.history      = dutyOfSubclass\n\nsb.localUpdate = function (trx) {\n  this._update([trx, timestamp(), this.id])\n  return this\n}\n\nsb._update = function (update) {\n  //validated when it comes into the stream\n  var ts = update[1]\n  var source = update[2]\n  //if this message is old for it's source,\n  //ignore it. it's out of order.\n  //each node must emit it's changes in order!\n  \n  var latest = this.sources[source]\n  if(latest && latest >= ts)\n    return emit.call(this, 'old_data', update), false\n\n  this.sources[source] = ts\n\n  var self = this\n  function didVerification (err, verified) {\n\n    // I'm not sure how what should happen if a async verification\n    // errors. if it's an key not found - that is a verification fail,\n    // not a error. if it's genunie error, really you should queue and \n    // try again? or replay the message later\n    // -- this should be done my the security plugin though, not scuttlebutt.\n\n    if(err)\n      return emit.call(self, 'error', err)\n\n    if(!verified)\n      return emit.call(self, 'unverified_data', update)\n\n    // check if this message is older than\n    // the value we already have.\n    // do nothing if so\n    // emit an 'old_data' event because i'll want to track how many\n    // unnecessary messages are sent.\n\n    if(self.applyUpdate(update))\n      emit.call(self, '_update', update) //write to stream.\n\n  }\n\n  if(source !== this.id) {\n    if(this._verify)\n      this._verify(update, didVerification)\n    else\n      didVerification(null, true)\n  } else {\n    if(this._sign) {\n      //could make this async easily enough.\n      update[3] = this._sign(update)\n    }\n    didVerification(null, true)\n  }\n\n  return true\n}\n\nsb.createStream = function (opts) {\n  var self = this\n  //the sources for the remote end.\n  var sources = {}, other\n  var syncSent = false, syncRecv = false\n\n  this._streams ++\n\n  opts = opts || {}\n  var d = duplex()\n  d.name = opts.name\n  var outer = serializer(opts && opts.wrapper)(d)\n  outer.inner = d\n\n  d.writable = opts.writable !== false\n  d.readable = opts.readable !== false\n\n  syncRecv   = !d.writable\n  syncSent   = !d.readable\n\n  var tail = opts.tail !== false //default to tail=true\n\n  function start (data) {\n    //when the digest is recieved from the other end,\n    //send the history.\n    //merge with the current list of sources.\n    sources = data.clock\n    i.each(self.history(sources), function (data) {d._data(data)})\n    \n    outer.emit('header', data)\n    d._data('SYNC')\n    //when we have sent all history\n    outer.emit('syncSent')\n    syncSent = true\n    //when we have recieved all histoyr\n    //emit 'synced' when this stream has synced.\n    if(syncRecv) outer.emit('sync'), outer.emit('synced')\n    if(!tail) d._end()\n  }\n\n  d\n    .on('_data', function (data) {\n      //if it's an array, it's an update.\n      if(Array.isArray(data)) {\n        if(validate(data))\n          return self._update(data)\n      }\n      //if it's an object, it's a scuttlebut digest.\n      else if('object' === typeof data && data)\n        start(data)\n      else if('string' === typeof data && data == 'SYNC') {\n        syncRecv = true\n        outer.emit('syncRecieved')\n        if(syncSent) outer.emit('sync'), outer.emit('synced')\n      }\n    }).on('_end', function () {\n      d._end()\n    })\n    .on('close', function () {\n      self.removeListener('_update', onUpdate)\n      //emit the number of streams that are remaining...\n      //this will be used for memory management...\n      self._streams --\n      emit.call(self, 'unstream', self._streams)\n    })\n\n  if(opts && opts.tail === false) {\n    outer.on('sync', function () {\n      process.nextTick(function () {\n        d._end()\n      })\n    })\n  }\n  function onUpdate (update) { //value, source, ts\n    if(!validate(update) || !u.filter(update, sources))\n      return\n\n    d._data(update)\n\n    //really, this should happen before emitting.\n    var ts = update[1]\n    var source = update[2]\n    sources[source] = ts\n  }\n\n  var outgoing = { id : self.id, clock : self.sources }\n\n  if (opts && opts.meta) outgoing.meta = opts.meta\n\n  if(d.readable) {\n    d._data(outgoing)\n    if(!d.writable)\n      start({clock:{}})\n    if(tail)\n      self.on('_update', onUpdate)\n  }\n\n  self.once('dispose', function () {\n    d.end()\n  })\n\n  return outer\n}\n\nsb.createWriteStream = function (opts) {\n  opts = opts || {}\n  opts.writable = true; opts.readable = false\n  return this.createStream(opts)\n}\n\nsb.createReadStream = function (opts) {\n  opts = opts || {}\n  opts.writable = false; opts.readable = true\n  return this.createStream(opts)\n}\n\nsb.dispose = function () {\n  emit.call(this, 'dispose')\n}\n\nsb.setId = function (id) {\n  if('__proto__' === id) throw new Error('__proto__ is invalid id')\n  if(id == null) throw new Error('null is not invalid id')\n  this.id = id\n  return this\n}\n\nfunction streamDone(stream, listener) {\n\n  function remove () {\n    stream.removeListener('end',   onDone)\n    stream.removeListener('error', onDone)\n    stream.removeListener('close',   onDone)\n  }\n  function onDone (arg) {\n    remove()\n    listener.call(this, arg)\n  }\n\n  //this makes emitter.removeListener(event, listener) still work\n  onDone.listener = listener\n\n  stream.on('end',   onDone)\n  stream.on('error', onDone)\n  stream.on('close', onDone)\n}\n\n//create another instance of this scuttlebutt,\n//that is in sync and attached to this instance.\nsb.clone = function () {\n  var A = this\n  var B = new (A.constructor)\n  B.setId(A.id) //same id. think this will work...\n\n  A._clones = (A._clones || 0) + 1\n\n  var a = A.createStream({wrapper: 'raw'})\n  var b = B.createStream({wrapper: 'raw'})\n\n  //all updates must be sync, so make sure pause never happens.\n  a.pause = b.pause = function noop(){}\n\n  streamDone(b, function () {\n    A._clones--\n    emit.call(A, 'unclone', A._clones)\n  })\n\n  a.pipe(b).pipe(a)\n  //resume both streams, so that the new instance is brought up to date immediately.\n  a.resume()\n  b.resume()\n\n  return B\n}\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/scuttlebutt/index.js"
));

require.define("/node_modules/rumours/node_modules/scuttlebutt/node_modules/iterate/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index.js\"}\n//@ sourceURL=/node_modules/rumours/node_modules/scuttlebutt/node_modules/iterate/package.json"
));

require.define("/node_modules/rumours/node_modules/scuttlebutt/node_modules/iterate/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\n//\n// adds all the fields from obj2 onto obj1\n//\n\nvar each = exports.each = function (obj,iterator){\n var keys = Object.keys(obj)\n keys.forEach(function (key){\n  iterator(obj[key],key,obj) \n })\n}\n\nvar RX = /sadf/.constructor\nfunction rx (iterator ){\n  return iterator instanceof RX ? function (str) { \n      var m = iterator.exec(str)\n      return m && (m[1] ? m[1] : m[0]) \n    } : iterator\n}\n\nvar times = exports.times = function () {\n  var args = [].slice.call(arguments)\n    , iterator = rx(args.pop())\n    , m = args.pop()\n    , i = args.shift()\n    , j = args.shift()\n    , diff, dir\n    , a = []\n    \n    i = 'number' === typeof i ? i : 1\n    diff = j ? j - i : 1\n    dir = i < m\n    if(m == i)\n      throw new Error('steps cannot be the same: '+m+', '+i)\n  for (; dir ? i <= m : m <= i; i += diff)\n    a.push(iterator(i))\n  return a\n}\n\nvar map = exports.map = function (obj, iterator){\n  iterator = rx(iterator)\n  if(Array.isArray(obj))\n    return obj.map(iterator)\n  if('number' === typeof obj)\n    return times.apply(null, [].slice.call(arguments))  \n  //return if null ?  \n  var keys = Object.keys(obj)\n    , r = {}\n  keys.forEach(function (key){\n    r[key] = iterator(obj[key],key,obj) \n  })\n  return r\n}\n\nvar findReturn = exports.findReturn = function (obj, iterator) {\n  iterator = rx(iterator)\n  if(obj == null)\n    return\n  var keys = Object.keys(obj)\n    , l = keys.length\n  for (var i = 0; i < l; i ++) {\n    var key = keys[i]\n      , value = obj[key]\n    var r = iterator(value, key)\n    if(r) return r\n  }\n}\n\nvar find = exports.find = function (obj, iterator) { \n  iterator = rx(iterator)\n  return findReturn (obj, function (v, k) {\n    var r = iterator(v, k)\n    if(r) return v\n  })\n}\n\nvar findKey = exports.findKey = function (obj, iterator) { \n  iterator = rx(iterator)\n  return findReturn (obj, function (v, k) {\n    var r = iterator(v, k)\n    if(r) return k\n  })\n}\n\nvar filter = exports.filter = function (obj, iterator){\n  iterator = rx (iterator)\n\n  if(Array.isArray(obj))\n    return obj.filter(iterator)\n  \n  var keys = Object.keys(obj)\n    , r = {}\n  keys.forEach(function (key){\n    var v\n    if(iterator(v = obj[key],key,obj))\n      r[key] = v\n  })\n  return r \n}\n\nvar mapKeys = exports.mapKeys = function (ary, iterator){\n  var r = {}\n  iterator = rx(iterator)\n  each(ary, function (v,k){\n    r[v] = iterator(v,k)\n  })\n  return r\n}\n\n\nvar mapToArray = exports.mapToArray = function (ary, iterator){\n  var r = []\n  iterator = rx(iterator)\n  each(ary, function (v,k){\n    r.push(iterator(v,k))\n  })\n  return r\n}\n\nvar path = exports.path = function (object, path) {\n\n  for (var i in path) {\n    if(object == null) return undefined\n    var key = path[i]\n    object = object[key]\n  }\n  return object\n}\n\n/*\nNOTE: naive implementation. \n`match` must not contain circular references.\n*/\n\nvar setPath = exports.setPath = function (object, path, value) {\n\n  for (var i in path) {\n    var key = path[i]\n    if(object[key] == null) object[key] = ( \n      i + 1 == path.length ? value : {}\n    )\n    object = object[key]\n  }\n}\n\nvar join = exports.join = function (A, B, it) {\n  each(A, function (a, ak) {\n    each(B, function (b, bk) {\n      it(a, b, ak, bk)\n    })\n  })\n}\n\n//@ sourceURL=/node_modules/rumours/node_modules/scuttlebutt/node_modules/iterate/index.js"
));

require.define("/node_modules/rumours/node_modules/scuttlebutt/node_modules/duplex/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/scuttlebutt/node_modules/duplex/package.json"
));

require.define("/node_modules/rumours/node_modules/scuttlebutt/node_modules/duplex/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Stream = require('stream')\n\nmodule.exports = function (write, end) {\n  var stream = new Stream() \n  var buffer = [], ended = false, destroyed = false, emitEnd\n  stream.writable = stream.readable = true\n  stream.paused = false\n  stream._paused = false\n  stream.buffer = buffer\n  \n  stream\n    .on('pause', function () {\n      stream._paused = true\n    })\n    .on('drain', function () {\n      stream._paused = false\n    })\n   \n  function destroySoon () {\n    process.nextTick(stream.destroy.bind(stream))\n  }\n\n  if(write)\n    stream.on('_data', write)\n  if(end)\n    stream.on('_end', end)\n\n  //destroy the stream once both ends are over\n  //but do it in nextTick, so that other listeners\n  //on end have time to respond\n  stream.once('end', function () { \n    stream.readable = false\n    if(!stream.writable) {\n      process.nextTick(function () {\n        stream.destroy()\n      })\n    }\n  })\n\n  stream.once('_end', function () { \n    stream.writable = false\n    if(!stream.readable)\n      stream.destroy()\n  })\n\n  // this is the default write method,\n  // if you overide it, you are resposible\n  // for pause state.\n\n  \n  stream._data = function (data) {\n    if(!stream.paused && !buffer.length)\n      stream.emit('data', data)\n    else \n      buffer.push(data)\n    return !(stream.paused || buffer.length)\n  }\n\n  stream._end = function (data) { \n    if(data) stream._data(data)\n    if(emitEnd) return\n    emitEnd = true\n    //destroy is handled above.\n    stream.drain()\n  }\n\n  stream.write = function (data) {\n    stream.emit('_data', data)\n    return !stream._paused\n  }\n\n  stream.end = function () {\n    stream.writable = false\n    if(stream.ended) return\n    stream.ended = true\n    stream.emit('_end')\n  }\n\n  stream.drain = function () {\n    if(!buffer.length && !emitEnd) return\n    //if the stream is paused after just before emitEnd()\n    //end should be buffered.\n    while(!stream.paused) {\n      if(buffer.length) {\n        stream.emit('data', buffer.shift())\n        if(buffer.length == 0) {\n          stream.emit('_drain')\n        }\n      }\n      else if(emitEnd && stream.readable) {\n        stream.readable = false\n        stream.emit('end')\n        return\n      } else {\n        //if the buffer has emptied. emit drain.\n        return true\n      }\n    }\n  }\n  var started = false\n  stream.resume = function () {\n    //this is where I need pauseRead, and pauseWrite.\n    //here the reading side is unpaused,\n    //but the writing side may still be paused.\n    //the whole buffer might not empity at once.\n    //it might pause again.\n    //the stream should never emit data inbetween pause()...resume()\n    //and write should return !buffer.length\n    started = true\n    stream.paused = false\n    stream.drain() //will emit drain if buffer empties.\n    return stream\n  }\n\n  stream.destroy = function () {\n    if(destroyed) return\n    destroyed = ended = true     \n    buffer.length = 0\n    stream.emit('close')\n  }\n  var pauseCalled = false\n  stream.pause = function () {\n    started = true\n    stream.paused = true\n    stream.emit('_pause')\n    return stream\n  }\n  stream._pause = function () {\n    if(!stream._paused) {\n      stream._paused = true\n      stream.emit('pause')\n    }\n    return this\n  }\n  stream.paused = true\n  process.nextTick(function () {\n    //unless the user manually paused\n    if(started) return\n    stream.resume()\n  })\n \n  return stream\n}\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/scuttlebutt/node_modules/duplex/index.js"
));

require.define("/node_modules/rumours/node_modules/scuttlebutt/node_modules/stream-serializer/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/scuttlebutt/node_modules/stream-serializer/package.json"
));

require.define("/node_modules/rumours/node_modules/scuttlebutt/node_modules/stream-serializer/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar EventEmitter = require('events').EventEmitter\n\nexports = module.exports = function (wrapper) {\n\n  if('function' == typeof wrapper)\n    return wrapper\n  \n  return exports[wrapper] || exports.json\n}\n\nexports.json = function (stream) {\n\n  var write = stream.write\n  var soFar = ''\n\n  function parse (line) {\n    var js\n    try {\n      js = JSON.parse(line)\n      //ignore lines of whitespace...\n    } catch (err) { \n      return console.error('invalid JSON', line)\n    }\n    if(js !== undefined)\n      write.call(stream, js)\n  }\n\n  function onData (data) {\n    var lines = (soFar + data).split('\\n')\n    soFar = lines.pop()\n    while(lines.length) {\n      parse(lines.shift())\n    }\n  }\n\n  stream.write = onData\n  \n  var end = stream.end\n\n  stream.end = function (data) {\n    if(data)\n      stream.write(data)\n    //if there is any left over...\n    if(soFar) {\n      parse(soFar)\n    }\n    return end.call(stream)\n  }\n\n  stream.emit = function (event, data) {\n\n    if(event == 'data') {\n      data = JSON.stringify(data) + '\\n'\n    }\n    //since all stream events only use one argument, this is okay...\n    EventEmitter.prototype.emit.call(stream, event, data)\n  }\n\n  return stream\n//  return es.pipeline(es.split(), es.parse(), stream, es.stringify())\n}\n\nexports.raw = function (stream) {\n  return stream\n}\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/scuttlebutt/node_modules/stream-serializer/index.js"
));

require.define("/node_modules/rumours/node_modules/scuttlebutt/util.js",Function(['require','module','exports','__dirname','__filename','process','global'],"exports.createId = \nfunction () {\n  return [1,1,1].map(function () {\n    return Math.random().toString(16).substring(2).toUpperCase()\n  }).join('')\n}\n\nexports.filter = function (update, sources) {\n  var ts = update[1]\n  var source = update[2]\n  return (!sources || !sources[source] || sources[source] < ts)\n}\n\nexports.protoIsIllegal = function (s) {\n  s.emit('invalid', new Error('\"__proto__\" is illegal property name'))\n  return null\n}\n\nfunction invalidUpdate(t) {\n  t.emit('invalid', new Error('invalid update'))\n}\n\nexports.validUpdate = function (t, update) {\n  if(!Array.isArray(update)) return invalidUpdate(t)\n  if('string' !== typeof update[1] || 'number' !== typeof update[2])\n    return invalidUpdate(t)\n}\n\nexports.sort = function (hist) {\n  return hist.sort(function (a, b) {\n    //sort by timestamps, then ids.\n    //there should never be a pair with equal timestamps\n    //and ids.\n    return a[1] - b[1] || (a[2] > b[2] ? 1 : -1)\n  })\n}\n\n//@ sourceURL=/node_modules/rumours/node_modules/scuttlebutt/util.js"
));

require.define("/node_modules/rumours/node_modules/scuttlebutt/node_modules/monotonic-timestamp/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/scuttlebutt/node_modules/monotonic-timestamp/package.json"
));

require.define("/node_modules/rumours/node_modules/scuttlebutt/node_modules/monotonic-timestamp/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// If `Date.now()` is invoked twice quickly, it's possible to get two\n// identical time stamps. To avoid generation duplications, subsequent\n// calls are manually ordered to force uniqueness.\n\nvar _last = 0\nvar _count = 1\nvar adjusted = 0\nvar _adjusted = 0\n\nmodule.exports =\nfunction timestamp() {\n  /**\n  Returns NOT an accurate representation of the current time.\n  Since js only measures time as ms, if you call `Date.now()`\n  twice quickly, it's possible to get two identical time stamps.\n  This function guarantees unique but maybe inaccurate results\n  on each call.\n  **/\n  //uncomment this wen\n  var time = Date.now()\n  //time = ~~ (time / 1000) \n  //^^^uncomment when testing...\n\n  /**\n  If time returned is same as in last call, adjust it by\n  adding a number based on the counter. \n  Counter is incremented so that next call get's adjusted properly.\n  Because floats have restricted precision, \n  may need to step past some values...\n  **/\n  if (_last === time)  {\n    do {\n      adjusted = time + ((_count++) / (_count + 999))\n    } while (adjusted === _adjusted)\n    _adjusted = adjusted\n  }\n  // If last time was different reset timer back to `1`.\n  else {\n    _count = 1\n    adjusted = time\n  }\n  _adjusted = adjusted\n  _last = time\n  return adjusted\n}\n\n//@ sourceURL=/node_modules/rumours/node_modules/scuttlebutt/node_modules/monotonic-timestamp/index.js"
));

require.define("/node_modules/rumours/node_modules/scuttlebutt/events.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Scuttlebutt = require('./')\nvar inherits = require('util').inherits\nvar each = require('iterate').each\nvar u = require('./util')\nvar EventEmitter = require('events').EventEmitter\n\nmodule.exports = ReliableEventEmitter\n\ninherits(ReliableEventEmitter, Scuttlebutt)\n\nfunction ReliableEventEmitter (opts) {\n  if(!(this instanceof ReliableEventEmitter)) return new ReliableEventEmitter(opts)\n  Scuttlebutt.call(this, opts)\n}\n\nvar emit = EventEmitter.prototype.emit\nvar emitter = ReliableEventEmitter.prototype\n\nemitter.emit = function (event) {\n  if(event === '__proto__')\n    throw new Error('__proto__ is illegal event name')\n  var args = [].slice.call(arguments)\n  if(event == 'newListener')\n    return emit.apply(this, args)\n  return this.localUpdate(args)\n}\n\nvar on = EventEmitter.prototype.on\n\nemitter.on = function (event, listener) {\n  if(event === '__proto__')\n    throw new Error('__proto__ is invalid event')\n  return on.call(this, event, listener)\n}\n\nemitter.applyUpdate = function (update) {\n  var key = update[0][0]\n  this.events = this.events || {}\n  this.events[key] = this.events[key] || []\n  this.events[key].push(update)\n  //emit the event.\n  emit.apply(this, update[0])\n  return true\n}\n\n\nemitter.history = function (filter) {\n  var self = this\n  var h = []\n  this.events = this.events || {}\n  each(this.events, function (es) {\n    each(es, function (e) {\n      if(u.filter(e, filter))\n        h.push(e)\n    })\n  })\n  return u.sort(h)\n}\n\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/scuttlebutt/events.js"
));

require.define("/node_modules/rumours/node_modules/r-edit/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/r-edit/package.json"
));

require.define("/node_modules/rumours/node_modules/r-edit/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var diff     = require('adiff').diff\nvar RArray   = require('r-array')\nvar inherits = require('util').inherits\n\nfunction patch (a, changes) {\n  changes.forEach(function (patch) {\n    a.splice.apply(a, patch)\n  })\n  return a\n}\n\nfunction split(str) {\n  return str.split('\\n').map(function (l, i, a) {\n    if(i != a.length - 1)\n      return l + '\\n'\n    return l\n  })\n}\n\nmodule.exports = REdit\n\ninherits(REdit, RArray)\n\nfunction REdit() {\n  if(!(this instanceof REdit)) return new REdit()\n  RArray.call(this)\n}\n\nvar R = REdit.prototype\n\nR.text  = function text (text) {\n  if(!arguments.length)\n    return this.toJSON().join('')\n  \n  var old = this.toJSON()\n  text = split(text)\n  //got to adjust the user's selection on the text area...\n  var p = diff(old, text)\n  patch(this, p)\n}\n\nR.unwrap = function () {\n\n}\n\nR.widget = function () {\n  var ta = document.createElement('textarea')\n  ta.setAttribute('cols', 80)\n  ta.setAttribute('rows', 24)\n  this.wrap(ta)\n  return ta\n}\n\nR.wrap = function (ta) {\n  if(!ta) throw new Error('wrap(ta) expects TextArea, or Input')\n\n  var cursor = 0, start\n  var self = this\n\n  if(this.wrapped)\n    throw new Error('rEdit is already wrapping a textarea. unwrap it first!')\n\n  if(ta._rEditWrapper)\n    ta._rEditWrapper.unwrap()\n\n  ta._rEditWrapper = this\n  this.wrapped = ta\n\n  ta.value = this.text()\n\n  function onPreupdate (ch) {\n    //force update when recieve message.\n    cursor = 0\n    start = ta.selectionStart\n    end   = ta.selectionEnd\n    //what atom contains the cursor?\n    var startKey, sum = 0\n    for (var i in self.keys) {\n      var key = self.keys[i]\n      if((sum = self.store[key].length + sum) >= start) {\n        startKey = key; break\n      }\n    }\n    //how much will be inserted into the document?\n    for(var key in ch) {\n      if(key < startKey)\n        cursor += \n          (ch[key] ? ch[key].length : 0)\n        - (self.store[key] ? self.store[key].length : 0)\n    }\n    //THIS IS ACTUALLY WRONG. CAN'T insert into a selection!\n    start = start + cursor\n    end   = end   + cursor\n  }\n  this.on('preupdate', onPreupdate)\n  function on_update (update) {\n    if(update[2] !== self.id) {\n      ta.value = self.toJSON().join('')\n      ta.selectionStart = ta.selectionEnd = start\n    }\n  }\n  this.on('_update'  , on_update)\n  var pending = false\n  function onInput () {\n    //if(pending) return\n    //pending = true\n    //setTimeout(function () {\n    //pending = false\n    self.text(ta.value)\n    //}, 300)\n  }\n  function onKeydown () {\n    start = ta.selectionStart\n    end   = ta.selectionEnd\n  }\n  function onFocus () {\n    ta.selectionStart = ta.selectionEnd = start\n  }\n  ta.addEventListener('input'  , onInput)\n  ta.addEventListener('keydown', onKeydown)\n  ta.addEventListener('focus'  , onFocus )\n\n  this.unwrap = function () {\n    ta.removeEventListener('input'  , onInput)\n    ta.removeEventListener('keydown', onKeydown)\n    ta.removeEventListener('focus'  , onFocus)\n    this.removeListener('preupdate' , onPreupdate)\n    this.removeListener('_update'   , on_update)\n    this.unwrap = function () {}\n  }\n\n  return this\n}\n\n//@ sourceURL=/node_modules/rumours/node_modules/r-edit/index.js"
));

require.define("/node_modules/rumours/node_modules/r-edit/node_modules/adiff/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./index.js\"}\n//@ sourceURL=/node_modules/rumours/node_modules/r-edit/node_modules/adiff/package.json"
));

require.define("/node_modules/rumours/node_modules/r-edit/node_modules/adiff/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"function head (a) {\n  return a[0]\n}\n\nfunction last (a) {\n  return a[a.length - 1]\n}\n\nfunction tail(a) {\n  return a.slice(1)\n}\n\nfunction retreat (e) {\n  return e.pop()\n}\n\nfunction hasLength (e) {\n  return e.length\n}\n\nfunction any(ary, test) {\n  for(var i in ary)\n    if(test(ary[i]))\n      return true\n  return false\n}\n\nvar _rules // set at the bottom  \n\n// note, naive implementation. will break on circular objects.\n\nfunction _equal(a, b) {\n  if(a && !b) return false\n  if(Array.isArray(a))\n    if(a.length != b.length) return false\n  if(a && 'object' == typeof a) {\n    for(var i in a)\n      if(!_equal(a[i], b[i])) return false\n    return true\n  }\n  return a == b\n}\n\nfunction getArgs(args) {\n  return args.length == 1 ? args[0] : [].slice.call(args)\n}\n\n// return the index of the element not like the others, or -1\nfunction oddElement(ary, cmp) {\n  var c\n  function guess(a) {\n    var odd = -1\n    c = 0\n    for (var i = a; i < ary.length; i ++) {\n      if(!cmp(ary[a], ary[i])) {\n        odd = i, c++\n      }\n    }\n    return c > 1 ? -1 : odd\n  }\n  //assume that it is the first element.\n  var g = guess(0)\n  if(-1 != g) return g\n  //0 was the odd one, then all the other elements are equal\n  //else there more than one different element\n  guess(1)\n  return c == 0 ? 0 : -1\n}\nvar exports = module.exports = function (deps, exports) {\n  var equal = (deps && deps.equal) || _equal\n  exports = exports || {} \n  exports.lcs = \n  function lcs() {\n    var cache = {}\n    var args = getArgs(arguments)\n    var a = args[0], b = args[1]\n\n    function key (a,b){\n      return a.length + ':' + b.length\n    }\n\n    //find length that matches at the head\n\n    if(args.length > 2) {\n      //if called with multiple sequences\n      //recurse, since lcs(a, b, c, d) == lcs(lcs(a,b), lcs(c,d))\n      args.push(lcs(args.shift(), args.shift()))\n      return lcs(args)\n    }\n    \n    //this would be improved by truncating input first\n    //and not returning an lcs as an intermediate step.\n    //untill that is a performance problem.\n\n    var start = 0, end = 0\n    for(var i = 0; i < a.length && i < b.length \n      && equal(a[i], b[i])\n      ; i ++\n    )\n      start = i + 1\n\n    if(a.length === start)\n      return a.slice()\n\n    for(var i = 0;  i < a.length - start && i < b.length - start\n      && equal(a[a.length - 1 - i], b[b.length - 1 - i])\n      ; i ++\n    )\n      end = i\n\n    function recurse (a, b) {\n      if(!a.length || !b.length) return []\n      //avoid exponential time by caching the results\n      if(cache[key(a, b)]) return cache[key(a, b)]\n\n      if(equal(a[0], b[0]))\n        return [head(a)].concat(recurse(tail(a), tail(b)))\n      else { \n        var _a = recurse(tail(a), b)\n        var _b = recurse(a, tail(b))\n        return cache[key(a,b)] = _a.length > _b.length ? _a : _b  \n      }\n    }\n    \n    var middleA = a.slice(start, a.length - end)\n    var middleB = b.slice(start, b.length - end)\n\n    return (\n      a.slice(0, start).concat(\n        recurse(middleA, middleB)\n      ).concat(a.slice(a.length - end))\n    )\n  }\n\n  // given n sequences, calc the lcs, and then chunk strings into stable and unstable sections.\n  // unstable chunks are passed to build\n  exports.chunk =\n  function (q, build) {\n    var q = q.map(function (e) { return e.slice() })\n    var lcs = exports.lcs.apply(null, q)\n    var all = [lcs].concat(q)\n\n    function matchLcs (e) {\n      if(e.length && !lcs.length || !e.length && lcs.length)\n        return false //incase the last item is null \n      return equal(last(e), last(lcs)) || ((e.length + lcs.length) === 0)\n    }\n\n    while(any(q, hasLength)) {\n      //if each element is at the lcs then this chunk is stable.\n      while(q.every(matchLcs) && q.every(hasLength)) \n        all.forEach(retreat) \n      //collect the changes in each array upto the next match with the lcs\n      var c = false\n      var unstable = q.map(function (e) {\n        var change = []\n        while(!matchLcs(e)) {\n          change.unshift(retreat(e))\n          c = true\n        }\n        return change\n      })\n      if(c) build(q[0].length, unstable) \n    }\n  }\n\n  exports.diff =\n  function (a, b) {\n    var changes = []\n    exports.chunk([a, b], function (index, unstable) {\n      var del = unstable.shift().length\n      var insert = unstable.shift()\n      changes.push([index, del].concat(insert))\n    })\n    return changes\n  }\n\n  exports.patch = function (a, changes, mutate) {\n    if(mutate !== true) a = a.slice(a)//copy a\n    changes.forEach(function (change) {\n      [].splice.apply(a, change)\n    })\n    return a\n  }\n\n  // http://en.wikipedia.org/wiki/Concestor\n  // me, concestor, you...\n  exports.merge = function () {\n    var args = getArgs(arguments)\n    var patch = exports.diff3(args)\n    return exports.patch(args[0], patch)\n  }\n\n  exports.diff3 = function () {\n    var args = getArgs(arguments)\n    var r = []\n    exports.chunk(args, function (index, unstable) {\n      var mine = unstable[0]\n      var insert = resolve(unstable)\n      if(equal(mine, insert)) return \n      r.push([index, mine.length].concat(insert)) \n    })\n    return r\n  }\n  exports.oddOneOut =\n    function oddOneOut (changes) {\n      changes = changes.slice()\n      //put the concestor first\n      changes.unshift(changes.splice(1,1)[0])\n      var i = oddElement(changes, equal)\n      if(i == 0) // concestor was different, 'false conflict'\n        return changes[1]\n      if (~i)\n        return changes[i] \n    }\n  exports.insertMergeOverDelete = \n    //i've implemented this as a seperate rule,\n    //because I had second thoughts about this.\n    function insertMergeOverDelete (changes) {\n      changes = changes.slice()\n      changes.splice(1,1)// remove concestor\n      \n      //if there is only one non empty change thats okay.\n      //else full confilct\n      for (var i = 0, nonempty; i < changes.length; i++)\n        if(changes[i].length) \n          if(!nonempty) nonempty = changes[i]\n          else return // full conflict\n      return nonempty\n    }\n\n  var rules = (deps && deps.rules) || [exports.oddOneOut, exports.insertMergeOverDelete]\n\n  function resolve (changes) {\n    var l = rules.length\n    for (var i in rules) { // first\n      \n      var c = rules[i] && rules[i](changes)\n      if(c) return c\n    }\n    changes.splice(1,1) // remove concestor\n    //returning the conflicts as an object is a really bad idea,\n    // because == will not detect they are the same. and conflicts build.\n    // better to use\n    // '<<<<<<<<<<<<<'\n    // of course, i wrote this before i started on snob, so i didn't know that then.\n    /*var conflict = ['>>>>>>>>>>>>>>>>']\n    while(changes.length)\n      conflict = conflict.concat(changes.shift()).concat('============')\n    conflict.pop()\n    conflict.push          ('<<<<<<<<<<<<<<<')\n    changes.unshift       ('>>>>>>>>>>>>>>>')\n    return conflict*/\n    //nah, better is just to use an equal can handle objects\n    return {'?': changes}\n  }\n  return exports\n}\nexports(null, exports)\n\n//@ sourceURL=/node_modules/rumours/node_modules/r-edit/node_modules/adiff/index.js"
));

require.define("/node_modules/rumours/node_modules/r-array/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/r-array/package.json"
));

require.define("/node_modules/rumours/node_modules/r-array/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar between     = require('between')\nvar Scuttlebutt = require('scuttlebutt')\nvar inherits    = require('util').inherits\nvar filter      = require('scuttlebutt/util').filter\n\ninherits(RArray, Scuttlebutt)\n\nmodule.exports = RArray\n\nfunction fuzz () {\n  return Math.random().toString().substring(2, 5)\n}\n\nvar DOEMIT = true, CHANGE = {}\n\nfunction order (a, b) {\n  //timestamp, then source\n  return between.strord(a[1], b[1]) || between.strord(a[2], b[2])\n}\n\nfunction RArray () {\n  Scuttlebutt.call(this)\n  this.keys = []\n  this.store = {}\n  this._hist = {}\n  this.length = 0\n  if(arguments.length) {\n    var self = this\n    ;[].forEach.call(arguments, function (e) {\n      self.push(e)\n    })\n  }\n}\n\nvar A = RArray.prototype\n\nA.last = function () {\n  return this.keys[this.keys.length - 1]\n}\n\nA.first = function () {\n  return this.keys[0]\n}\n\nA.insert = function (before, val, after) {  \n  var key = between(before || between.lo, after || between.hi) + fuzz()\n  this.set(key, val)\n  return key\n}\n\nA.push = function (val) {\n  var key = this.insert(this.last(), val)\n}\n\nA.unshift = function (val) {\n  var key = this.insert(null, val, this.first())\n}\n\nA.indexOf = function (val) {\n  for(var i in this.keys) {\n    var key = this.keys[i]\n    if(v === this.get(key)) return i\n  }\n  return null\n}\n\nA.indexOfKey = function (key) {\n  return this.keys.indexOf(key)\n}\n\nA.toJSON = function () {\n  var store = this.store\n  var self = this\n  return this.keys.map(function (key) {\n    return self.get(key)\n  })\n}\n\nA.set = function (key, val) {\n  if('string' == typeof key) {\n    if(val === null) return this.unset(key)\n    if(null == this.store[key]) this.length ++\n    this.store[key] = val\n    if(!~this.keys.indexOf(key)) {\n      this.keys.push(key)\n      this.keys.sort()\n    }\n    CHANGE[key] = val\n    DOEMIT && this._emit()\n  }\n}\n\nA.get = function (key) {\n  return this.store[key]\n}\n\nA.unset = function (key) {\n  if('string' == typeof key) {\n    if(null != this.store[key]) this.length --\n    delete this.store[key]\n    var i = this.keys.indexOf(key)\n    if(!~i) return\n    this.keys.splice(i, 1)    \n\n    CHANGE[key] = null\n    DOEMIT && this._emit()\n  }\n}\n\nA.pop = function () {\n  var l = this.last()\n  var val = this.store[l]\n  this.unset(l)\n  return val\n}\n\nA.shift = function () {\n  var f = this.first()\n  var val = this.store[f]\n  this.unset(f)\n  return val\n}\n\nA._emit = function () {\n  if(!DOEMIT) return\n  this.localUpdate(CHANGE)\n  CHANGE = {}\n}\n\nA.splice = function (i, d /*,...args*/) {\n  var args = [].slice.call(arguments, 2)\n  var j = 0, l = args.length\n\n  DOEMIT = false\n\n  if(d + i > this.keys.length)\n    d = this.keys.length - i\n  \n  while(j < d) {\n    if(j < l)\n      this.set(this.keys[i+j], args[j]), j++\n    else\n      this.unset(this.keys[i+j]), d--\n  }\n\n  while(j < l)\n    this.insert(this.keys[i+j-1], args[j], this.keys[i+j]), j++\n\n  DOEMIT = true\n  this._emit()\n}\n\nA.applyUpdate = function (update) {\n  DOEMIT = false\n  var change = update[0], old\n  var apply = {}, ch = {}\n  var old = {}\n  for(var key in change) {\n    if(!this._hist[key] || order(update, this._hist[key]) > 0)\n      apply[key] = change[key]\n  }\n  //allow the user to see what the change is going to be.\n  this.emit('preupdate', apply) \n\n  //apply the change...\n  for(var key in apply) {\n    var o = this._hist[key]\n    o && (old[o[1]+':'+o[2]] = o) //ts:source\n    this._hist[key] = update\n    this.set(key, apply[key])\n  }\n\n  //check if old elements need to be removed.\n  //may also want to keep old updates hanging around \n  //so the user can see recent history...\n  for(var id in old) {\n    var o = old[id][0], rm = true\n    for(var key in o) {\n      if(this._hist[key] === old[id]) rm = false\n    }\n    if(rm)\n      this.emit('_remove', old[id])\n  }\n    \n  DOEMIT = true\n  CHANGE = {}\n  this.emit('update', apply)\n  return true\n}\n\n\nA.history = function (sources) {\n  var h = []\n  for (var key in this._hist) {\n    var update = this._hist[key]\n      if(!~h.indexOf(update) && filter(update, sources))\n        h.push(update)\n  }\n  return h.sort(order)\n}\n\nA.forEach = function (fun) {\n  return this.toJSON().forEach(fun)\n}\n\nA.filter = function (fun) {\n  return this.toJSON().filter(fun)\n}\n\nA.map = function (fun) {\n  return this.toJSON().map(fun)\n}\n\nA.reduce = function (fun, initial) {\n  return this.toJSON().reduce(fun, initial)\n}\n\n//.length is a property, not a function.\n\n//@ sourceURL=/node_modules/rumours/node_modules/r-array/index.js"
));

require.define("/node_modules/rumours/node_modules/r-array/node_modules/between/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/r-array/node_modules/between/package.json"
));

require.define("/node_modules/rumours/node_modules/r-array/node_modules/between/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nfunction inject (chars) {\n\n  chars = chars ||\n  '!0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~'\n\n  chars = chars.split('').sort().join('')\n\n  var exports = between\n\n  exports.between   = between\n\n  exports.randstr   = randstr\n  exports.between   = between\n  exports.strord    = strord\n\n  exports.lo        = chars[0]\n  exports.hi        = chars[chars.length - 1]\n\n  exports.inject    = inject\n\n  function randstr(l) {\n    var str = ''\n    while(l--) \n      str += chars[\n        Math.floor(\n          Math.random() * chars.length \n        )\n      ]\n    return str\n  }\n\n  /*\n    SOME EXAMPLE STRINGS, IN ORDER\n   \n    0\n    00001\n    0001\n    001\n    001001\n    00101\n    0011\n    0011001\n    001100101\n    00110011\n    001101\n    00111\n    01  \n\n    if you never make a string that ends in the lowest char,\n    then it is always possible to make a string between two strings.\n    this is like how decimals never end in 0. \n\n    example:\n\n    between('A', 'AB') \n\n    ... 'AA' will sort between 'A' and 'AB' but then it is impossible\n    to make a string inbetween 'A' and 'AA'.\n    instead, return 'AAB', then there will be space.\n\n  */\n\n  function between (a, b) {\n\n    var s = '', i = 0\n\n    while (true) {\n\n      var _a = chars.indexOf(a[i])\n      var _b = chars.indexOf(b[i])\n     \n      if(_a == -1) _a = 0\n      if(_b == -1) _b = chars.length - 1\n\n      i++\n\n      var c = chars[\n          _a + 1 < _b \n        ? Math.round((_a+_b)/2)\n        : _a\n      ]\n\n      s += c\n\n      if(a < s && s < b && c != exports.lo)\n        return s;\n    }\n  }\n\n  function strord (a, b) {\n    return (\n      a == b ?  0\n    : a <  b ? -1\n    :           1\n    )\n  }\n\n  between.strord\n\n  return between\n}\n\n\nmodule.exports = inject(null)\n\n//@ sourceURL=/node_modules/rumours/node_modules/r-array/node_modules/between/index.js"
));

require.define("/node_modules/rumours/node_modules/crdt/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/crdt/package.json"
));

require.define("/node_modules/rumours/node_modules/crdt/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"//index\n'use strict';\n\nvar inherits     = require('util').inherits\nvar EventEmitter = require('events').EventEmitter\n\nexports = module.exports = require('./doc')\nexports.Row              = require('./row')\n\nexports.sync             = sync\nexports.Set              = require('./set')\nexports.Seq              = require('./seq')\n\nexports.Doc = exports\n\nfunction sync(a, b) {\n  var as = a.createStream()\n  var bs = b.createStream()\n  return as.pipe(bs).pipe(as)\n}\n\n\nexports.createStream = function (doc, opts) {\n  return doc.createStream(opts)\n}\n\n//@ sourceURL=/node_modules/rumours/node_modules/crdt/index.js"
));

require.define("/node_modules/rumours/node_modules/crdt/doc.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var inherits     = require('util').inherits\nvar Row          = require('./row')\nvar between      = require('between')\nvar Set          = require('./set')\nvar Seq          = require('./seq')\nvar Scuttlebutt  = require('scuttlebutt')\nvar EventEmitter = require('events').EventEmitter\nvar createId     = require('scuttlebutt/util').createId\n\ninherits(Doc, Scuttlebutt)\n\nfunction merge(to, from) {\n  for(var k in from)\n    to[k] = from[k]\n  return to\n}\n\n\nmodule.exports = Doc\n//doc\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/*\n  idea: instead of using a tombstone for deletes,\n  use a anti-tombstone to show something is alive.\n  breathing: count. -- updated by an authority.\n  set breathing to 0 to kill something.\n  \n  if a node has rows that have been garbage collected on the server,\n  it will be obvious from the value of breathing.\n\n  node disconnects... makes changes...\n  other nodes delete some things, which get garbage collected.\n\n  node reconnects.\n  server updates the node, but only increments _breathing for some rows.\n  \n  clearly, the nodes that do not have an upto date _breathing are either\n  dead, or where created by the node while it was offline.\n\n  would breathing need to be a vector clock?\n  \n  if the disconneded node is still updating the rows,\n  maybe it shouldn't be deleted, that is, undeleted.\n\n  may be on to something here... but this needs more thinking.\n\n  will depend on how much churn something has...\n*/\n\nfunction order (a, b) {\n  return between.strord(a[1], b[1]) || between.strord(a[2], b[2])\n}\n\nfunction Doc (id) {\n  if (!(this instanceof Doc)) return new Doc(id)\n  //the id of the doc refers to the instance.\n  //that is, to the node.\n  //it's used to identify a node \n//  this.id = id || '#' + Math.round(Math.random()*1000)\n  this.rows = {}\n  this.hist = {}\n  this.recieved = {}\n  this.sets = new EventEmitter() //for tracking membership of sets.\n  this.setMaxListeners(Infinity)\n  this.sets.setMaxListeners(Infinity)\n  Scuttlebutt.call(this, id)\n\n}\n\nDoc.prototype.add = function (initial) {\n  var id = initial.id === undefined ? createId() : initial.id\n  var r = this._add(id, 'local')\n  r._set(initial, 'local')\n  return r\n}\n\nDoc.prototype._add = function (id, source, change) {\n\n  var doc = this\n\n  if(this.rows[id])\n    return this.rows[id]\n\n  var r = id instanceof Row ? id : new Row(id)\n  this.rows[r.id] = r\n\n  function track (changes, source) {\n    doc.localUpdate([r.id, changes])\n  }\n\n  r.on('preupdate', track)\n\n  r._new = true\n  return r\n}\n\nDoc.prototype.timeUpdated = function (row, key) {\n  var h = this.hist[row.id] \n  if(!h) return\n  return h[key][2]\n}\n\nDoc.prototype.set = function (id, change) {\n  var r = this._add(id, 'local', change)\n  return r.set(change)\n}\n\n/*\n  histroy for each row is indexed by key.\n  key -> update that set that key.\n\n  so applying a change is as simple\n  as iterating over the keys in the rows hist\n  checking if the new update is more recent\n  than the hist update\n  if so, replace that keys hist.\n*/\n\nDoc.prototype.applyUpdate = function (update, source) {\n\n  //apply an update to a row.\n  //take into account histroy.\n  //and insert the change into the correct place.\n  var id      = update[0][0]\n  var changes = update[0][1]\n  var timestamp = update[1]\n  var from    = update[2]\n\n  var changed = {}\n\n  var row = this._add(id, source)\n  var hist = this.hist[id] = this.hist[id] || {}\n  var emit = false, oldnews = false\n\n\n  //remember the most recent update from each node.\n  //now handled my scuttlebutt.\n//  if(!row.validate(changes)) return\n  \n  for(var key in changes) {\n    var value = changes[key]\n    if(!hist[key] || order(hist[key], update) < 0) {\n      if(hist[key]) this.emit('_remove', hist[key])\n      hist[key] = update\n      changed[key] = changes[key]\n      emit = true \n    }\n  }\n\n//  probably, there may be mulitple sets that listen to the same key, \n//  but activate on different values...\n//\n//  hang on, in the mean time, I will probably only be managing n < 10 sets. \n//  at once, \n\n  merge(row.state, changed)\n  for(var k in changed)\n    this.sets.emit(k, row, changed) \n  \n  if(!emit) return\n  \n  if(row._new) {\n    this.emit('add', row)\n    this.emit('create', row) //alias\n    row._new = false\n  }\n  this.emit('_update', update)\n  row.emit('update', update, changed)\n  row.emit('changes', changes, changed)\n  row.emit('change', changed) //installing this in paralel, so tests still pass.\n  //will depreciate the old way later.\n  this.emit('update', update, source)   //rename this event to 'data' or 'diff'?\n  this.emit('row_update', row)          //rename this event to 'update'\n}\n\nDoc.prototype.history = function (sources) {\n  var h = []\n  for (var id in this.hist) {\n    var hist = this.hist[id]\n    for (var k in hist) {\n      if(!~h.indexOf(hist[k]) && Scuttlebutt.filter(hist[k], sources))\n        h.push(hist[k])\n    }\n  }\n  return h.sort(order)\n}\n\nfunction _set(self, key, val, type) {\n   var id = key + ':' + val\n  if(self.sets[id]) return self.sets[id] \n  return self.sets[key + ':' + val] = new type(self, key, val) \n}\n\nDoc.prototype.createSet = function (key, val) {\n  return _set(this, key, val, Set)\n}\n\nDoc.prototype.createSeq = function (key, val) {\n  return _set(this, key, val, Seq)\n}\n\nDoc.prototype.toJSON = function () {\n  var j = {}\n  for (var k in this.rows)\n    j[k] = this.rows[k].state\n  return j\n}\n//retrive a reference to a row.\n//if the row is not created yet, create \nDoc.prototype.get = function (id) {\n  return this.rows[id] = this.rows[id] || this._add(new Row(id), 'local')\n}\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/crdt/doc.js"
));

require.define("/node_modules/rumours/node_modules/crdt/row.js",Function(['require','module','exports','__dirname','__filename','process','global'],"//row\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n'use strict';\n\nvar inherits     = require('util').inherits\nvar EventEmitter = require('events').EventEmitter\n\nmodule.exports = Row\n\ninherits(Row, EventEmitter)\n\nfunction Row (id) {\n  this.id = id\n  this.state = {id: id}\n  this.setMaxListeners(Infinity)\n}\n\nRow.prototype.set = function (changes, v) {\n  if(arguments.length == 2) {\n    var k = changes \n    changes = {}\n    changes[k] = v\n  }\n\n  if(changes.id && changes.id !== this.state.id)\n    throw new Error('id cannot be changed')\n\n  this._set(changes, 'local')  \n  return this\n}\n\nRow.prototype.validate = function (changes) {\n  try {\n    this.emit('validate', changes)\n    return true\n  } catch (e) {\n    console.error('validation', e.message)\n    return false\n  } \n}\n\nRow.prototype._set = function (changes, source) {\n\n  //the change is applied by the Doc!\n  this.emit('preupdate', changes, source)\n  return this\n}\n\nRow.prototype.get = function (key) {\n  if(key)\n    return this.state[key]\n  return this.state\n}\n\nRow.prototype.toJSON = function () {\n  return this.state\n}\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/crdt/row.js"
));

require.define("/node_modules/rumours/node_modules/crdt/node_modules/between/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/rumours/node_modules/crdt/node_modules/between/package.json"
));

require.define("/node_modules/rumours/node_modules/crdt/node_modules/between/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nfunction inject (chars) {\n\n  chars = chars ||\n  '!0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~'\n\n  chars = chars.split('').sort().join('')\n\n  var exports = between\n\n  exports.between   = between\n\n  exports.randstr   = randstr\n  exports.between   = between\n  exports.strord    = strord\n\n  exports.lo        = chars[0]\n  exports.hi        = chars[chars.length - 1]\n\n  exports.inject    = inject\n\n  function randstr(l) {\n    var str = ''\n    while(l--) \n      str += chars[\n        Math.floor(\n          Math.random() * chars.length \n        )\n      ]\n    return str\n  }\n\n  /*\n    SOME EXAMPLE STRINGS, IN ORDER\n   \n    0\n    00001\n    0001\n    001\n    001001\n    00101\n    0011\n    0011001\n    001100101\n    00110011\n    001101\n    00111\n    01  \n\n    if you never make a string that ends in the lowest char,\n    then it is always possible to make a string between two strings.\n    this is like how decimals never end in 0. \n\n    example:\n\n    between('A', 'AB') \n\n    ... 'AA' will sort between 'A' and 'AB' but then it is impossible\n    to make a string inbetween 'A' and 'AA'.\n    instead, return 'AAB', then there will be space.\n\n  */\n\n  function between (a, b) {\n\n    var s = '', i = 0\n\n    while (true) {\n\n      var _a = chars.indexOf(a[i])\n      var _b = chars.indexOf(b[i])\n     \n      if(_a == -1) _a = 0\n      if(_b == -1) _b = chars.length - 1\n\n      i++\n\n      var c = chars[\n          _a + 1 < _b \n        ? Math.round((_a+_b)/2)\n        : _a\n      ]\n\n      s += c\n\n      if(a < s && s < b && c != exports.lo)\n        return s;\n    }\n  }\n\n  function strord (a, b) {\n    return (\n      a == b ?  0\n    : a <  b ? -1\n    :           1\n    )\n  }\n\n  between.strord\n\n  return between\n}\n\n\nmodule.exports = inject(null)\n\n//@ sourceURL=/node_modules/rumours/node_modules/crdt/node_modules/between/index.js"
));

require.define("/node_modules/rumours/node_modules/crdt/set.js",Function(['require','module','exports','__dirname','__filename','process','global'],"'use strict';\nvar inherits     = require('util').inherits\nvar EventEmitter = require('events').EventEmitter\nvar Row          = require('./row')\nvar between      = require('between')\n\ninherits(Set, EventEmitter)\n\nmodule.exports = Set\n\n//set\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/*\n  a set is just a query.\n  could expand this to enable replicating a subset of a document.\n  that could enable massive documents that are too large to fit in memory.\n  as long as they could be partitioned.\n\n  heh, join queries? or rather, recursive queries,\n  for when rows have sets.\n\n  that is my vibe. don't make a database you have to \n  _map_ to your application. pre-map the database.\n\n  could also specify sets like\n\n  //set of all things\n  {type: 'thing'}\n\n  //set of things with thier parts\n  { type: 'thing',\n    parts: {\n      parent_id: function (val) {return val == this.id}\n    }\n  }\n\n  or use map-reduces. remember, if the the reduce is \n  monotonic you don't have to remember each input.\n*/\n\n//TODO check if any currently existing items should be in the set. currently, one must create the set before recieving anything.\n\nfunction Set(doc, key, value) {\n  var array = this._array = []\n  var rows = this.rows =  {}\n  var set = this\n\n  //DO NOT CHANGE once you have created the set.\n  this.key = key\n  this.value = value\n\n  function add(row) {\n    array.push(row)\n    rows[row.id] = row\n    set.emit('add', row)\n\n    function remove (_, changed) {\n      if(row.state[key] === value) {\n        set.emit('changes', row, changed)\n        return\n      }\n      delete rows[row.id]\n      var i = array.indexOf(row)\n      if(~i) array.splice(i, 1)\n      set.emit('changes', row, changed)\n      set.emit('remove', row)\n      row.removeListener('changes', remove)\n    }\n\n    row.on('changes', remove)\n \n  }\n\n  doc.sets.on(key, function (row, changed) {\n    if(changed[key] !== value) return \n    add(row)\n  })\n\n  this.rm = this.remove = function (row) {\n    row = this.get(row) \n    if(!row) return\n    return row.set(key, null)\n  }\n\n  for(var id in doc.rows) {\n    var row = doc.get(id)\n    if(row.get(key) === value) add(row) \n  }\n\n  this.setMaxListeners(Infinity)\n\n}\n\nSet.prototype.asArray = function () {\n  return this._array\n}\n\nSet.prototype.toJSON = function () {\n  return this._array.map(function (e) {\n    return e.state\n  }).sort(function (a, b) {\n    return between.strord(a._sort || a.id, b._sort || b.id)\n  })\n}\n\nSet.prototype.each = \nSet.prototype.forEach = function (iter) {\n  return this._array.forEach(iter)\n}\n\nSet.prototype.get = function (id) {\n  if(!arguments.length)\n    return this.array\n  return (\n      'string' === typeof id ? this.rows[id] \n    : 'number' === typeof id ? this.rows[id] \n    : id && id.id            ? this.rows[id.id]\n    :                          null\n  )\n}\n\nSet.prototype.has = function (row) {\n  return this.get(row)\n}\n\n//@ sourceURL=/node_modules/rumours/node_modules/crdt/set.js"
));

require.define("/node_modules/rumours/node_modules/crdt/seq.js",Function(['require','module','exports','__dirname','__filename','process','global'],"'use strict';\n\nvar Set      = require('./set')\nvar Row      = require('./row')\nvar inherits = require('util').inherits\nvar between  = require('between')\n\nmodule.exports = Seq\n\nfunction sort (array) {\n  return array.sort(function (a, b) {\n    return between.strord(a.get('_sort'), b.get('_sort'))\n  })\n}\n\ninherits(Seq, Set)\n\nfunction find (obj, iter) {\n  \n  for(var k in obj) {\n    var v = obj[k]\n    if(iter(v, k, obj)) return v\n  }\n  return null\n}\n\nfunction Seq (doc, key, val) {\n\n  Set.call(this, doc, key, val)\n  var seq = this\n  this.on('changes', function (row, changes) {\n    if(!changes._sort) return\n    sort(seq._array)\n    //check if there is already an item with this sort key.\n    var prev = \n    find(seq._array, function (other) {\n      return other != row && other.get('_sort') == row.get('_sort')\n    })\n\n    //nudge it forward if it has the same key.    \n    if(prev)\n      seq.insert(row, prev, seq.next(row)) \n    else\n      seq.emit('move', row)\n  })\n  this.insert = function (obj, before, after) {\n\n    before = toKey(this.get(before) || '!')\n    after  = toKey(this.get(after)  || '~')\n\n    //must get id from the doc,\n    //because may be moving this item into this set.\n    if('string' === typeof obj)\n      obj = doc.rows[obj]\n\n    var _sort = \n       between.between(before, after ) \n     + between.randstr(3) //add a random tail so it's hard\n                    //to concurrently add two items with the\n                    //same sort.\n \n    var r, changes\n    if(obj instanceof Row) {\n      r = obj\n      changes = {_sort: _sort}\n      if(r.get(key) != val)\n        changes[key] = val\n      r.set(changes)\n    } else {\n      obj._sort = _sort\n      obj[key] = val\n      r = doc.set(id(obj), obj)\n    } \n    sort(this._array)\n    return r\n  }\n}\n\nfunction toKey (key) {\n\n  return (\n     'string' === typeof key ? key \n  :  key instanceof Row      ? key.get()._sort\n  :  key                     ? key._sort\n  : null\n  )\n\n}\n\n/*\n  items are relative to each other,\n  more like a linked list.\n  although it is possible to make an\n  index based interface, before after,\n  etc is more natural\n*/\n\nfunction max (ary, test, wantIndex) {\n  var max = null, _max = -1\n  if(!ary.length) return\n\n  for (var i = 0; i < ary.length; i++)\n    if(test(max, ary[i])) max = ary[_max = i]\n  return wantIndex ? _max : max\n}\n\nSeq.prototype.prev = function (key) {\n  key = toKey(this.get(key) || '~')\n  //find the greatest item that is less than `key`.\n  //since the list is kept in order,\n  //a binary search is used.\n  //think about that later\n  return max(this._array, function (M, m) {\n    if(toKey(m) < key)\n      return M ? toKey(m) > toKey(M) : true\n  })\n}\n\nSeq.prototype.next = function (key) {\n  key = toKey(this.get(key) || '!')\n  return max(this._array, function (M, m) {\n    if(toKey(m) > key)\n      return M ? toKey(m) < toKey(M) : true\n  })\n}\n\nfunction id(obj) {\n  return (obj.id \n  ||  obj._id \n  ||  '_' + Date.now() \n    + '_' + Math.round(Math.random()*1000)\n  )\n}\n\nSeq.prototype.before = function (obj, before) {\n  return this.insert(obj, this.prev(before), before)\n}\n\nSeq.prototype.after = function (obj, after) {\n  return this.insert(obj, after, this.next(after))\n}\n\nSeq.prototype.first = function () {\n  return this._array[0]\n}\n\nSeq.prototype.last = function () {\n  return this._array[this._array.length - 1]\n}\n\nSeq.prototype.indexOf = function (obj) {\n  return this._array.indexOf('string' == typeof obj ? this.rows[obj] : obj)\n}\n\nSeq.prototype.at = function (i) {\n  return this._array[i]\n}\n\nSeq.prototype.unshift = function (obj) {\n  return this.insert(obj, '!', this.first())\n}\n\nSeq.prototype.push = function (obj) {\n  return this.insert(obj, this.last(), '~') \n}\n\nSeq.prototype.length = function () {\n  return this._array.length\n}\n\nSeq.prototype.pop = function () {\n  return this.remove(this.last())\n}\n\nSeq.prototype.shift = function () {\n  return this.remove(this.first())\n}\n\n\n//@ sourceURL=/node_modules/rumours/node_modules/crdt/seq.js"
));

require.define("/node_modules/rumours/node_modules/append-only/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/rumours/node_modules/append-only/package.json"
));

require.define("/node_modules/rumours/node_modules/append-only/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Scuttlebutt = require(\"scuttlebutt\")\n    , filter = Scuttlebutt.filter\n    , inherits = require(\"util\").inherits\n\ninherits(AppendOnly, Scuttlebutt)\n\nvar proto = AppendOnly.prototype\n\nproto.push = push\nproto.remove = remove\nproto.applyUpdate = applyUpdate\nproto.history = history\nproto.toJSON = proto.createArray = createArray\n\nmodule.exports = AppendOnly\n\nfunction AppendOnly(options) {\n    if (! (this instanceof AppendOnly)) {\n        return new AppendOnly(options)\n    }\n\n    Scuttlebutt.call(this, options)\n\n    var store = this._store = []\n    this._hash = {}\n\n    this.on(\"_remove\", function (update, update2) {\n        var index = store.indexOf(update)\n        if (index !== -1) {\n            store.splice(index, 1)\n        }\n\n        index = store.indexOf(update2)\n        if (index !== -1) {\n            store.splice(index, 1)\n        }\n    })\n}\n\nfunction push(item) {\n    this.localUpdate({ push: item })\n}\n\nfunction remove(id) {\n    this.localUpdate({ remove: id.__id ? id.__id : id })\n}\n\nfunction toId (update) {\n    var ts = update[1]\n        , source = update[2]\n\n    return source + \":\" + ts\n}\n\nfunction applyUpdate(update) {\n    var value = update[0]\n\n    this._store.push(update)\n\n    if (value.push) {\n        var item = value.push\n            , id = toId(update)\n\n        Object.defineProperty(item, \"__id\", {\n            value: id\n            , configurable: true\n        })\n        this._hash[id] = update\n        this.emit(\"item\", item)\n    } else if (value.remove) {\n        var id = value.remove\n            , _update = this._hash[id]\n\n        ;delete this._hash[id]\n\n        this.emit(\"_remove\", _update, update)\n        this.emit(\"remove\", _update[0].push)\n    }\n    return true\n}\n\nfunction history(sources) {\n    return this._store.filter(function (update) {\n        return filter(update, sources)\n    })\n}\n\nfunction createArray() {\n    var hash = this._hash\n\n    return Object.keys(hash).map(findKey, hash)\n}\n\nfunction findKey(key) {\n    return this[key][0].push\n}\n\n//@ sourceURL=/node_modules/rumours/node_modules/append-only/index.js"
));

require.define("/node_modules/rumours/node_modules/expiry-model/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/rumours/node_modules/expiry-model/package.json"
));

require.define("/node_modules/rumours/node_modules/expiry-model/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var Scuttlebutt = require(\"scuttlebutt\")\nvar extend = require(\"xtend\")\nvar LRU = require(\"lru-cache\")\nvar filter = Scuttlebutt.filter\n\nvar DAY = 1000 * 60 * 60 * 24\nvar defaults = {\n    max: 500\n    , maxAge: DAY\n}\n\nmodule.exports = ExpiryModel\n\nfunction ExpiryModel(options) {\n    options = extend({}, defaults, options || {})\n\n    if (!options.dispose) {\n        options.dispose = dispose\n    }\n\n    var scuttle = Scuttlebutt()\n    var maxAge = options.maxAge\n    var store = LRU(options)\n\n    scuttle.set = set\n    scuttle.get = get\n    scuttle.applyUpdate = applyUpdate\n    scuttle.toJSON = toJSON\n    scuttle.history = history\n\n    return scuttle\n\n    function dispose(key, value) {\n        var source = value[2]\n        var found = false\n\n        store.forEach(function (record) {\n            if (record[2] === source && record[1] !== value[1]) {\n                found = true\n            }\n        })\n\n        if (!found) {\n            delete scuttle.sources[source]\n        }\n    }\n\n    function set(key, value) {\n        scuttle.localUpdate([key, value])\n    }\n\n    function get(key) {\n        var record = store.get(key)\n\n        return record ? record[0][1] : null\n    }\n\n    function getMergedRecord(update) {\n        var transaction = update[0]\n        var key = transaction[0]\n        var current = store.get(key)\n\n        if (!current) {\n            return update.slice()\n        }\n\n        var currentValue = current[0][1]\n        var currentTs = current[1]\n        var value = transaction[1]\n        var ts = update[1]\n\n        if (typeof currentValue === \"object\" &&\n            typeof value === \"object\" && value !== null\n        ) {\n            if (currentTs > ts) {\n                value = extend({}, value, currentValue)\n            } else {\n                value = extend({}, currentValue, value)\n            }\n        } else if (currentTs > ts) {\n            return false\n        }\n\n        return [[key, value], ts, update[2]]\n    }\n\n    function applyUpdate(update) {\n        var ts = update[1]\n        var key = update[0][0]\n\n        if (ts <= Date.now() - maxAge) {\n            return false\n        }\n\n        var record = getMergedRecord(update)\n\n        if (record === false) {\n            return false\n        } else if (record[0][1] === null) {\n            store.del(key)\n        } else {\n            store.set(key, record)\n        }\n\n        scuttle.emit(\"update\", record[0][0], record[0][1]\n            , record[1], record[2])\n\n        return true\n    }\n\n    function toJSON() {\n        var hash = {}\n\n        store.forEach(function (record, key) {\n            hash[key] = record[0][1]\n        })\n\n        return hash\n    }\n\n    function history(sources) {\n        sources = sources || {}\n        var list = []\n        var now = Date.now()\n\n        store.forEach(function (record, key) {\n            var ts = record[1]\n\n            if (ts > now - maxAge) {\n                if (filter(record, sources)) {\n                    list.push(record)\n                }\n            } else {\n                store.del(key)\n            }\n        })\n\n        return list.sort(function (a, b) {\n            if (a[2] !== b[2]) {\n                return 0\n            }\n\n            return a[1] < b[1] ? -1 : 1\n        })\n    }\n}\n\n//@ sourceURL=/node_modules/rumours/node_modules/expiry-model/index.js"
));

require.define("/node_modules/rumours/node_modules/expiry-model/node_modules/xtend/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"index\"}\n//@ sourceURL=/node_modules/rumours/node_modules/expiry-model/node_modules/xtend/package.json"
));

require.define("/node_modules/rumours/node_modules/expiry-model/node_modules/xtend/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = extend\n\nfunction extend(target) {\n    for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i],\n            keys = Object.keys(source)\n\n        for (var j = 0; j < keys.length; j++) {\n            var name = keys[j]\n            target[name] = source[name]\n        }\n    }\n\n    return target\n}\n//@ sourceURL=/node_modules/rumours/node_modules/expiry-model/node_modules/xtend/index.js"
));

require.define("/node_modules/rumours/node_modules/expiry-model/node_modules/lru-cache/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"lib/lru-cache.js\"}\n//@ sourceURL=/node_modules/rumours/node_modules/expiry-model/node_modules/lru-cache/package.json"
));

require.define("/node_modules/rumours/node_modules/expiry-model/node_modules/lru-cache/lib/lru-cache.js",Function(['require','module','exports','__dirname','__filename','process','global'],";(function () { // closure for web browsers\n\nif (typeof module === 'object' && module.exports) {\n  module.exports = LRUCache\n} else {\n  // just set the global for non-node platforms.\n  this.LRUCache = LRUCache\n}\n\nfunction hOP (obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key)\n}\n\nfunction naiveLength () { return 1 }\n\nfunction LRUCache (options) {\n  if (!(this instanceof LRUCache)) {\n    return new LRUCache(options)\n  }\n\n  var max\n  if (typeof options === 'number') {\n    max = options\n    options = { max: max }\n  }\n\n  if (!options) options = {}\n\n  max = options.max\n\n  var lengthCalculator = options.length || naiveLength\n\n  if (typeof lengthCalculator !== \"function\") {\n    lengthCalculator = naiveLength\n  }\n\n  if (!max || !(typeof max === \"number\") || max <= 0 ) {\n    // a little bit silly.  maybe this should throw?\n    max = Infinity\n  }\n\n  var allowStale = options.stale || false\n\n  var maxAge = options.maxAge || null\n\n  var dispose = options.dispose\n\n  var cache = Object.create(null) // hash of items by key\n    , lruList = Object.create(null) // list of items in order of use recency\n    , mru = 0 // most recently used\n    , length = 0 // number of items in the list\n    , itemCount = 0\n\n\n  // resize the cache when the max changes.\n  Object.defineProperty(this, \"max\",\n    { set : function (mL) {\n        if (!mL || !(typeof mL === \"number\") || mL <= 0 ) mL = Infinity\n        max = mL\n        // if it gets above double max, trim right away.\n        // otherwise, do it whenever it's convenient.\n        if (length > max) trim()\n      }\n    , get : function () { return max }\n    , enumerable : true\n    })\n\n  // resize the cache when the lengthCalculator changes.\n  Object.defineProperty(this, \"lengthCalculator\",\n    { set : function (lC) {\n        if (typeof lC !== \"function\") {\n          lengthCalculator = naiveLength\n          length = itemCount\n          for (var key in cache) {\n            cache[key].length = 1\n          }\n        } else {\n          lengthCalculator = lC\n          length = 0\n          for (var key in cache) {\n            cache[key].length = lengthCalculator(cache[key].value)\n            length += cache[key].length\n          }\n        }\n\n        if (length > max) trim()\n      }\n    , get : function () { return lengthCalculator }\n    , enumerable : true\n    })\n\n  Object.defineProperty(this, \"length\",\n    { get : function () { return length }\n    , enumerable : true\n    })\n\n\n  Object.defineProperty(this, \"itemCount\",\n    { get : function () { return itemCount }\n    , enumerable : true\n    })\n\n  this.forEach = function (fn, thisp) {\n    thisp = thisp || this\n    var i = 0;\n    for (var k = mru - 1; k >= 0 && i < itemCount; k--) if (lruList[k]) {\n      i++\n      var hit = lruList[k]\n      fn.call(thisp, hit.value, hit.key, this)\n    }\n  }\n\n  this.keys = function () {\n    var keys = new Array(itemCount)\n    var i = 0\n    for (var k = mru - 1; k >= 0 && i < itemCount; k--) if (lruList[k]) {\n      var hit = lruList[k]\n      keys[i++] = hit.key\n    }\n    return keys\n  }\n\n  this.values = function () {\n    var values = new Array(itemCount)\n    var i = 0\n    for (var k = mru - 1; k >= 0 && i < itemCount; k--) if (lruList[k]) {\n      var hit = lruList[k]\n      values[i++] = hit.value\n    }\n    return values\n  }\n\n  this.reset = function () {\n    if (dispose) {\n      for (var k in cache) {\n        dispose(k, cache[k].value)\n      }\n    }\n    cache = {}\n    lruList = {}\n    mru = 0\n    length = 0\n    itemCount = 0\n  }\n\n  // Provided for debugging/dev purposes only. No promises whatsoever that\n  // this API stays stable.\n  this.dump = function () {\n    return cache\n  }\n\n  this.dumpLru = function () {\n    return lruList\n  }\n\n  this.set = function (key, value) {\n    if (hOP(cache, key)) {\n      // dispose of the old one before overwriting\n      if (dispose) dispose(key, cache[key].value)\n      if (maxAge) cache[key].now = Date.now()\n      cache[key].value = value\n      this.get(key)\n      return true\n    }\n\n    var len = lengthCalculator(value)\n    var age = maxAge ? Date.now() : 0\n    var hit = new Entry(key, value, mru++, len, age)\n\n    // oversized objects fall out of cache automatically.\n    if (hit.length > max) {\n      if (dispose) dispose(key, value)\n      return false\n    }\n\n    length += hit.length\n    lruList[hit.lu] = cache[key] = hit\n    itemCount ++\n\n    if (length > max) trim()\n    return true\n  }\n\n  this.has = function (key) {\n    if (!hOP(cache, key)) return false\n    var hit = cache[key]\n    if (maxAge && (Date.now() - hit.now > maxAge)) {\n      return false\n    }\n    return true\n  }\n\n  this.get = function (key) {\n    if (!hOP(cache, key)) return\n    var hit = cache[key]\n    if (maxAge && (Date.now() - hit.now > maxAge)) {\n      this.del(key)\n      return allowStale ? hit.value : undefined\n    }\n    delete lruList[hit.lu]\n    hit.lu = mru ++\n    lruList[hit.lu] = hit\n    return hit.value\n  }\n\n  this.del = function (key) {\n    if (!hOP(cache, key)) return\n    var hit = cache[key]\n    if (dispose) dispose(key, hit.value)\n    delete cache[key]\n    delete lruList[hit.lu]\n    length -= hit.length\n    itemCount --\n  }\n\n  function trim () {\n    if (length <= max) return\n    for (var k in lruList) {\n      if (length <= max) break;\n      var hit = lruList[k]\n      if (dispose) dispose(hit.key, hit.value)\n      length -= hit.length\n      itemCount --\n      delete cache[ hit.key ]\n      delete lruList[k]\n    }\n  }\n}\n\n// classy, since V8 prefers predictable objects.\nfunction Entry (key, value, mru, len, age) {\n  this.key = key\n  this.value = value\n  this.lu = mru\n  this.length = len\n  this.now = age\n}\n\n})()\n\n//@ sourceURL=/node_modules/rumours/node_modules/expiry-model/node_modules/lru-cache/lib/lru-cache.js"
));

require.define("/node_modules/hash-change/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/hash-change/package.json"
));

require.define("/node_modules/hash-change/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var EventEmitter = require('events').EventEmitter\n\nvar hashchange = module.exports = new EventEmitter()\n\nwindow.addEventListener('hashchange', function () {\n  hashchange.emit('change', hashchange.hash())\n})\n\nhashchange.hash = function () {\n  return window.location.hash.substring(1)\n}\n\n//@ sourceURL=/node_modules/hash-change/index.js"
));

require.define("/node_modules/observable/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/observable/package.json"
));

require.define("/node_modules/observable/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],";(function () {\n\n// bind a to b -- One Way Binding\nfunction bind1(a, b) {\n  a(b()); b(a)\n}\n//bind a to b and b to a -- Two Way Binding\nfunction bind2(a, b) {\n  b(a()); a(b); b(a); \n}\n\n//---util-funtions------\n\n//check if this call is a get.\nfunction isGet(val) {\n  return undefined === val\n}\n\n//check if this call is a set, else, it's a listen\nfunction isSet(val) {\n  return 'function' !== typeof val\n}\n\n//trigger all listeners\nfunction all(ary, val) {\n  for(var k in ary)\n    ary[k](val)\n}\n\n//remove a listener\nfunction remove(ary, item) {\n  delete ary[ary.indexOf(item)]  \n}\n\n//register a listener\nfunction on(emitter, event, listener) {\n  (emitter.on || emitter.addEventListener)\n    .call(emitter, event, listener, false)\n}\n\nfunction off(emitter, event, listener) {\n  (emitter.removeListener || emitter.removeEventListener || emitter.off)\n    .call(emitter, event, listener, false)\n}\n\n//An observable that stores a value.\n\nfunction value () {\n  var _val, listeners = []\n  return function (val) {\n    return (\n      isGet(val) ? _val\n    : isSet(val) ? all(listeners, _val = val)\n    : (listeners.push(val), function () {\n        remove(listeners, val)\n      })\n  )}}\n  //^ if written in this style, always ends )}}\n\n/*\n##property\nobserve a property of an object, works with scuttlebutt.\ncould change this to work with backbone Model - but it would become ugly.\n*/\n\nfunction property (model, key) {\n  return function (val) {\n    return (\n      isGet(val) ? model.get(key) :\n      isSet(val) ? model.set(key, val) :\n      (on(model, 'change:'+key, val), function () {\n        off(model, 'change:'+key, val)\n      })\n    )}}\n\n/*\nnote the use of the elvis operator `?:` in chained else-if formation,\nand also the comma operator `,` which evaluates each part and then\nreturns the last value.\n\nonly 8 lines! that isn't much for what this baby can do!\n*/\n\nfunction transform (observable, down, up) {\n  return function (val) {\n    return (\n      isGet(val) ? down(observable())\n    : isSet(val) ? observable((up || down)(val))\n    : observable(function (_val) { val(down(_val)) })\n    )}}\n\nfunction not(observable) {\n  return transform(observable, function (v) { return !v })\n}\n\nfunction listen (element, event, attr, listener) {\n  function onEvent () {\n    listener(element[attr])\n  }\n  on(element, event, onEvent)\n  return function () {\n    off(element, event, onEvent)\n  }\n}\n\n//observe html element - aliased as `input`\nfunction attribute(element, attr, event) {\n  attr = attr || 'value'; event = event || 'input'\n  return function (val) {\n    return (\n      isGet(val) ? element[attr]\n    : isSet(val) ? element[attr] = val\n    : listen(element, event, attr, val)\n    )}}\n\n//toggle based on an event, like mouseover, mouseout\nfunction toggle (el, up, down) {\n  var i = false\n  return function (val) {\n    function onUp() {\n      i || val(i = true)\n    }\n    function onDown () {\n      i && val(i = false)\n    }\n    return (\n      isGet(val) ? i\n    : isSet(val) ? undefined //read only\n    : (on(el, up, onUp), on(el, down || up, onDown), function () {\n      off(el, up, onUp); off(el, down || up, onDown)\n    })\n  )}}\n\nfunction error (message) {\n  throw new Error(message)\n}\n\nfunction compute (observables, compute) {\n  function getAll() {\n    return compute.apply(null, observables.map(function (e) {return e()}))\n  }\n  return function (val) {\n    return (\n      isGet(val) ? getAll()\n    : isSet(val) ? error('read-only')\n    : observables.forEach(function (obs) {\n        obs(function () { val(getAll()) })\n      })\n    )}}\n\nfunction boolean (observable, truthy, falsey) {\n  return transform(observable, function (val) {\n      return val ? truthy : falsey\n    }, function (val) {\n      return val == truthy ? true : false\n    })\n  }\n\nvar exports = value\nexports.bind1     = bind1\nexports.bind2     = bind2\nexports.value     = value\nexports.not       = not\nexports.property  = property\nexports.input     =\nexports.attribute = attribute\nexports.compute   = compute\nexports.transform = transform\nexports.boolean   = boolean\nexports.toggle    = toggle\nexports.hover     = function (e) { return toggle(e, 'mouseover', 'mouseout')}\nexports.focus     = function (e) { return toggle(e, 'focus', 'blur')}\n\nif('object' === typeof module) module.exports = exports\nelse                           this.observable = exports\n})()\n\n//@ sourceURL=/node_modules/observable/index.js"
));

require.define("/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/package.json"
));

require.define("/utils.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar o = require('observable')\n\nexports.debounce = function (b, delay, max) {\n\n  var v = o()\n  v(b())\n\n  var timer, start\n\n  b(function () {\n    clearTimeout(timer)\n    timer = setTimeout(function () {\n      v(b())\n    }, delay || 333)\n\n  })\n\n  return v\n}\n\nexports.query = function (b, get, initial) {\n\n  var v = o(), m = 0\n\n  v(initial)\n\n  b(function (val) {\n    var n = m + 1\n\n    get(val, function (err, data) {\n      if(!err && m < n)\n        m = n, v(data)\n    })\n  })\n  return v\n}\n\nexports.rArray = function (ary) {\n  var v = o()\n  ary.on('update', function () {\n    v(ary.toJSON())\n  })\n  v(ary.toJSON())\n  return v\n}\n\nexports.log = function (ob, name) {\n  ob(function (val) {\n    console.log(name, val)\n  })\n  return ob\n}\n\nexports.list = function (ary, template, el) {\n  el = el || document.createElement('ul')\n  function onUpdate(a) {\n    el.innerHTML = ''\n    a.forEach(function (e, i) {\n      var t\n      if(e) t = template(e, i)\n      t && el.appendChild(t)\n    })\n  }\n\n  ary(onUpdate)\n  onUpdate(ary() || [])\n  return el\n}\n\nexports.index = function (list) {\n  var v = o(); v(0)\n  return o.transform(v, function (n) {\n    var l = list() ? list().length : 1\n    return 0 > n ? 0 : n >= l ? l - 1 : n\n  })\n}\n\nexports.sortable = function (arv, template, el) {\n  return Sortable(arv(), template, el).once('update', function (arr) {\n    arv(arr)\n  }).element\n}\n\n//@ sourceURL=/utils.js"
));

require.define("/node_modules/jsonp/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/jsonp/package.json"
));

require.define("/node_modules/jsonp/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\n/**\n * Module dependencies\n */\n\nvar debug = require('debug')('jsonp');\n\n/**\n * Module exports.\n */\n\nmodule.exports = jsonp;\n\n/**\n * Callback index.\n */\n\nvar count = 0;\n\n/**\n * Noop function.\n */\n\nfunction noop(){};\n\n/**\n * JSONP handler\n *\n * Options:\n *  - param {String} qs parameter (`callback`)\n *  - timeout {Number} how long after a timeout error is emitted (`60000`)\n *\n * @param {String} url\n * @param {Object|Function} optional options / callback\n * @param {Function} optional callback\n */\n\nfunction jsonp(url, opts, fn){\n  if ('function' == typeof opts) {\n    fn = opts;\n    opts = {};\n  }\n\n  var opts = opts || {};\n  var param = opts.param || 'callback';\n  var timeout = null != opts.timeout ? opts.timeout : 60000;\n  var enc = encodeURIComponent;\n  var target = document.getElementsByTagName('script')[0];\n  var script;\n  var timer;\n\n  // generate a unique id for this request\n  var id = count++;\n\n  if (timeout) {\n    timer = setTimeout(function(){\n      cleanup();\n      fn && fn(new Error('Timeout'));\n    }, timeout);\n  }\n\n  function cleanup(){\n    target.parentNode.removeChild(script);\n    window['__jp' + id] = noop;\n  }\n\n  window['__jp' + id] = function(data){\n    debug('jsonp got', data);\n    if (timer) clearTimeout(timer);\n    cleanup();\n    fn && fn(null, data);\n  };\n\n  // add qs component\n  url += (~url.indexOf('?') ? '&' : '?') + param + '=' + enc('__jp' + id + '');\n  url = url.replace('?&', '?');\n\n  debug('jsonp req \"%s\"', url);\n\n  // create script\n  script = document.createElement('script');\n  script.src = url;\n  target.parentNode.insertBefore(script, target);\n};\n\n//@ sourceURL=/node_modules/jsonp/index.js"
));

require.define("/node_modules/jsonp/node_modules/debug/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"lib/debug.js\",\"browserify\":\"debug.js\"}\n//@ sourceURL=/node_modules/jsonp/node_modules/debug/package.json"
));

require.define("/node_modules/jsonp/node_modules/debug/debug.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\n/**\n * Expose `debug()` as the module.\n */\n\nmodule.exports = debug;\n\n/**\n * Create a debugger with the given `name`.\n *\n * @param {String} name\n * @return {Type}\n * @api public\n */\n\nfunction debug(name) {\n  if (!debug.enabled(name)) return function(){};\n\n  return function(fmt){\n    var curr = new Date;\n    var ms = curr - (debug[name] || curr);\n    debug[name] = curr;\n\n    fmt = name\n      + ' '\n      + fmt\n      + ' +' + debug.humanize(ms);\n\n    // This hackery is required for IE8\n    // where `console.log` doesn't have 'apply'\n    window.console\n      && console.log\n      && Function.prototype.apply.call(console.log, console, arguments);\n  }\n}\n\n/**\n * The currently active debug mode names.\n */\n\ndebug.names = [];\ndebug.skips = [];\n\n/**\n * Enables a debug mode by name. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} name\n * @api public\n */\n\ndebug.enable = function(name) {\n  try {\n    localStorage.debug = name;\n  } catch(e){}\n\n  var split = (name || '').split(/[\\s,]+/)\n    , len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    name = split[i].replace('*', '.*?');\n    if (name[0] === '-') {\n      debug.skips.push(new RegExp('^' + name.substr(1) + '$'));\n    }\n    else {\n      debug.names.push(new RegExp('^' + name + '$'));\n    }\n  }\n};\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\ndebug.disable = function(){\n  debug.enable('');\n};\n\n/**\n * Humanize the given `ms`.\n *\n * @param {Number} m\n * @return {String}\n * @api private\n */\n\ndebug.humanize = function(ms) {\n  var sec = 1000\n    , min = 60 * 1000\n    , hour = 60 * min;\n\n  if (ms >= hour) return (ms / hour).toFixed(1) + 'h';\n  if (ms >= min) return (ms / min).toFixed(1) + 'm';\n  if (ms >= sec) return (ms / sec | 0) + 's';\n  return ms + 'ms';\n};\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\ndebug.enabled = function(name) {\n  for (var i = 0, len = debug.skips.length; i < len; i++) {\n    if (debug.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (var i = 0, len = debug.names.length; i < len; i++) {\n    if (debug.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n// persist\n\nif (window.localStorage) debug.enable(localStorage.debug);\n\n//@ sourceURL=/node_modules/jsonp/node_modules/debug/debug.js"
));

require.define("/node_modules/youtube-player/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/youtube-player/package.json"
));

require.define("/node_modules/youtube-player/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var EventEmitter = require('events').EventEmitter\nvar inherits = require('util').inherits\n\nmodule.exports = YouTubePlayer\n\nvar waiting = []\nvar ready = false\n\ninherits(YouTubePlayer, EventEmitter)\n\n  if (!window['YT'])\n    window.YT = {};\n \n/*\n{ id // element id\n, width\n, height\n// initial video?\n*/\n\nvar states = ['ready', 'end', 'play', 'pause', 'buffer', 'cue']\n\n\nfunction YouTubePlayer (options) {\n  var self = this, player, isPolling\n  this.ready = false\n  options.events = {\n    onStateChange: function (state) {\n      state = states[state.data + 1]\n\n      /*\n        this is really weird, but the first time that youtube\n        emits ready, it's not actually ready.\n        it hasn't added all the methods yet.\n\n        I don't know exactly when it will be ready,\n        so I've gotta poll for that.\n      */\n\n\n      if (!self.ready && !isPolling) {\n        pollReady()\n      }\n      self.emit(state)\n      self.emit('change', state)\n    },\n    onReady: function() {\n      /*\n        sometimes only onReady and not the the initial\n        ready onStateChange is fired. so should\n        poll here too\n      */\n      if (!self.ready && !isPolling) {\n        pollReady()\n      }\n    },\n    onError: function (code) {\n      var message = ({\n        '2': 'invalid parameter',\n        '100': 'video not found',\n        '101': 'video not embeddable',\n        '150': 'video not embeddable'\n      })[code]\n      self.emit('error', new Error(message))\n    }\n  }\n\n  function pollReady() {\n    if(!self.player.loadVideoById) {\n      isPolling = true\n      setTimeout(pollReady, 1)\n      return\n    }\n\n    isPolling = false\n\n    if(!self.ready) {\n      self.ready = true\n      self.emit('ready')\n      if(self.waiting)\n        self.play.apply(self, self.waiting)\n    }  \n  }\n\n  function create() {\n    self.player = new YT.Player(options.id, options)\n  }\n\n  if(!ready)\n    waiting.push(create)\n}\n\nfunction map(a, b) {\n  YouTubePlayer.prototype[a] = \n  'function' == typeof b ? b : function () {\n    var args = [].slice.call(arguments)\n    if('function' === typeof this.player[b])\n    this.player[b].apply(this.player, args)\n  }\n}\n\nmap('play', function (id, seconds, quality) {\n  var args = [].slice.call(arguments), self = this\n  if(!this.ready)\n    this.waiting = args\n  else\n    this.player.loadVideoById(id, seconds, quality)\n})\n\nmap('start'    , 'playVideo')\nmap('cue'     , 'cueVideoById')\nmap('stop'    , 'stopVideo')\nmap('pause'   , 'pauseVideo')\nmap('clear'   , 'clearVideo')\nmap('seek'    , 'seekTo')\nmap('length'  , 'getDuration')\n\nmap('mute')\nmap('unMute')\nmap('isMuted')\nmap('setVolume')\nmap('getVolume')\n\n//global listener... sorry. this is youtube.\nwindow.onYouTubePlayerAPIReady = function () {\n  ready = true\n  while(waiting.length)\n    waiting.shift()()\n} \n\n//this is from http://www.youtube.com/player_api\n//gonna inline it here to save a request.\nsetTimeout(function () {\n if (!YT.Player) {\n    (function () {\n      var p = document.location.protocol == 'https:' ? 'https:' : 'http:'\n      var s = p + '//s.ytimg.com/yt/jsbin/www-widgetapi-vflCAfh6H.js'\n      var a = document.createElement('script')\n      a.src = s\n      a.async = true\n      document.head.insertBefore(a, document.head.firstElementChild)\n      YT.embed_template = \n        \"\\u003ciframe width=\\\"425\\\" height=\\\"344\\\" src=\\\"\\\"\" + \n        \"frameborder=\\\"0\\\" allowfullscreen\\u003e\\u003c\\/iframe\\u003e\"\n    })()\n  }\n}, 1)\n\n//@ sourceURL=/node_modules/youtube-player/index.js"
));

require.define("/node_modules/sortable/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {}\n//@ sourceURL=/node_modules/sortable/package.json"
));

require.define("/node_modules/sortable/index.js",Function(['require','module','exports','__dirname','__filename','process','global'],"var $ = require('./ui')\nvar EventEmitter = require('events').EventEmitter\n\nmodule.exports = function (array, template, list) {\n\n  var emitter = new EventEmitter()\n  if(!(list instanceof HTMLElement))\n    list = document.createElement(list || \"ol\")\n\n  function index (e) {\n    return [].indexOf.call(e.parentNode.children, e)\n  }\n\n  sortableList(array, template, function (ary, ch) {\n    emitter.emit('splice', ary, ch)\n  }, list) \n\n  function length (a) {\n    return 'function' === typeof a ? a.length() : a.length\n  }\n\n  function sortableList(array, template, onChange, list) {\n    array.forEach(function (e, i) {\n      var el = e && template(e, i)\n      if(el) list.appendChild(el)\n    })\n\n    var from\n    \n    $(list).sortable({\n      start: function (e, u) {\n        from = index(u.item[0])\n        //console.log('START', from)\n      },\n      stop: function (e, u) {\n        var to = index(u.item[0])\n        //console.log('TO', to, 'FROM', from)\n        //if(to > from) to\n        var v = array[from]\n        var changes = [[from, 1], [to, 0, v]]\n        \n        changes.forEach(function (ch) {\n          array.splice.apply(array, ch)\n          emitter.emit(array, ch)\n        })\n      }\n    }).disableSelection();\n  }\n\n  emitter.element = list\n  emitter.splice = function (index, del) {\n    var insert = [].slice.call(arguments, 2)\n    var args = [].slice.call(arguments)\n    _del = del || 0\n\n    function at(i) {\n      return list.children[i]\n    }\n\n    while(_del--)\n      list.removeChild(at(index))\n\n    insert.forEach(function (e, i) {\n      var t = template(e, index + i), a = at(index)\n      if(!t) return\n      if(a) list.insertBefore(t, a)\n      else  list.appendChild(t)\n    })\n    \n    var r = array.splice.apply(array, args)\n    emitter.emit('splice', array, args)\n    return r\n  }\n\n  emitter.unshift = function (o) {\n    return emitter.splice(0, 0, o), length(array)\n  }\n  emitter.push = function (o) {\n    return emitter.splice(length(array), 0, o), length(array)\n  }\n  emitter.shift = function (o) {\n    return emitter.splice(0, 1)[0] || null\n  }\n  emitter.pop = function (o) {\n    return emitter.splice(length(array) - 1, 1)[0]\n  }\n  emitter.length = function () {\n    return length(array)\n  }\n  emitter.slice = function () {\n    return array.slice.apply(array, arguments)\n  }\n\n  //this is just a hack, need better solution\n  emitter._reset = function (ary) {\n    list.innerHTML = '', array.length = 0\n    ary.forEach(function (e, i) {\n      var t = template(e, i)\n      if(!t) return\n      array[i] = e\n      list.appendChild(t)\n    })\n    return emitter\n  }\n\n  return emitter\n}\n\n//@ sourceURL=/node_modules/sortable/index.js"
));

require.define("/node_modules/sortable/ui.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar jQuery = require('jquery-browserify');\nmodule.exports = jQuery\n\n;\n/*! jQuery UI - v1.10.1 - 2013-02-21\n* http://jqueryui.com\n* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.position.js, jquery.ui.draggable.js, jquery.ui.droppable.js, jquery.ui.sortable.js\n* Copyright (c) 2013 jQuery Foundation and other contributors Licensed MIT */\n\n(function( $, undefined ) {\n\nvar uuid = 0,\n  runiqueId = /^ui-id-\\d+$/;\n\n// prevent duplicate loading\n// this is only a problem because we proxy existing functions\n// and we don't want to double proxy them\n$.ui = $.ui || {};\nif ( $.ui.version ) {\n  return;\n}\n\n$.extend( $.ui, {\n  version: \"1.10.1\",\n\n  keyCode: {\n    BACKSPACE: 8,\n    COMMA: 188,\n    DELETE: 46,\n    DOWN: 40,\n    END: 35,\n    ENTER: 13,\n    ESCAPE: 27,\n    HOME: 36,\n    LEFT: 37,\n    NUMPAD_ADD: 107,\n    NUMPAD_DECIMAL: 110,\n    NUMPAD_DIVIDE: 111,\n    NUMPAD_ENTER: 108,\n    NUMPAD_MULTIPLY: 106,\n    NUMPAD_SUBTRACT: 109,\n    PAGE_DOWN: 34,\n    PAGE_UP: 33,\n    PERIOD: 190,\n    RIGHT: 39,\n    SPACE: 32,\n    TAB: 9,\n    UP: 38\n  }\n});\n\n// plugins\n$.fn.extend({\n  _focus: $.fn.focus,\n  focus: function( delay, fn ) {\n    return typeof delay === \"number\" ?\n      this.each(function() {\n        var elem = this;\n        setTimeout(function() {\n          $( elem ).focus();\n          if ( fn ) {\n            fn.call( elem );\n          }\n        }, delay );\n      }) :\n      this._focus.apply( this, arguments );\n  },\n\n  scrollParent: function() {\n    var scrollParent;\n    if (($.ui.ie && (/(static|relative)/).test(this.css(\"position\"))) || (/absolute/).test(this.css(\"position\"))) {\n      scrollParent = this.parents().filter(function() {\n        return (/(relative|absolute|fixed)/).test($.css(this,\"position\")) && (/(auto|scroll)/).test($.css(this,\"overflow\")+$.css(this,\"overflow-y\")+$.css(this,\"overflow-x\"));\n      }).eq(0);\n    } else {\n      scrollParent = this.parents().filter(function() {\n        return (/(auto|scroll)/).test($.css(this,\"overflow\")+$.css(this,\"overflow-y\")+$.css(this,\"overflow-x\"));\n      }).eq(0);\n    }\n\n    return (/fixed/).test(this.css(\"position\")) || !scrollParent.length ? $(document) : scrollParent;\n  },\n\n  zIndex: function( zIndex ) {\n    if ( zIndex !== undefined ) {\n      return this.css( \"zIndex\", zIndex );\n    }\n\n    if ( this.length ) {\n      var elem = $( this[ 0 ] ), position, value;\n      while ( elem.length && elem[ 0 ] !== document ) {\n        // Ignore z-index if position is set to a value where z-index is ignored by the browser\n        // This makes behavior of this function consistent across browsers\n        // WebKit always returns auto if the element is positioned\n        position = elem.css( \"position\" );\n        if ( position === \"absolute\" || position === \"relative\" || position === \"fixed\" ) {\n          // IE returns 0 when zIndex is not specified\n          // other browsers return a string\n          // we ignore the case of nested elements with an explicit value of 0\n          // <div style=\"z-index: -10;\"><div style=\"z-index: 0;\"></div></div>\n          value = parseInt( elem.css( \"zIndex\" ), 10 );\n          if ( !isNaN( value ) && value !== 0 ) {\n            return value;\n          }\n        }\n        elem = elem.parent();\n      }\n    }\n\n    return 0;\n  },\n\n  uniqueId: function() {\n    return this.each(function() {\n      if ( !this.id ) {\n        this.id = \"ui-id-\" + (++uuid);\n      }\n    });\n  },\n\n  removeUniqueId: function() {\n    return this.each(function() {\n      if ( runiqueId.test( this.id ) ) {\n        $( this ).removeAttr( \"id\" );\n      }\n    });\n  }\n});\n\n// selectors\nfunction focusable( element, isTabIndexNotNaN ) {\n  var map, mapName, img,\n    nodeName = element.nodeName.toLowerCase();\n  if ( \"area\" === nodeName ) {\n    map = element.parentNode;\n    mapName = map.name;\n    if ( !element.href || !mapName || map.nodeName.toLowerCase() !== \"map\" ) {\n      return false;\n    }\n    img = $( \"img[usemap=#\" + mapName + \"]\" )[0];\n    return !!img && visible( img );\n  }\n  return ( /input|select|textarea|button|object/.test( nodeName ) ?\n    !element.disabled :\n    \"a\" === nodeName ?\n      element.href || isTabIndexNotNaN :\n      isTabIndexNotNaN) &&\n    // the element and all of its ancestors must be visible\n    visible( element );\n}\n\nfunction visible( element ) {\n  return $.expr.filters.visible( element ) &&\n    !$( element ).parents().addBack().filter(function() {\n      return $.css( this, \"visibility\" ) === \"hidden\";\n    }).length;\n}\n\n$.extend( $.expr[ \":\" ], {\n  data: $.expr.createPseudo ?\n    $.expr.createPseudo(function( dataName ) {\n      return function( elem ) {\n        return !!$.data( elem, dataName );\n      };\n    }) :\n    // support: jQuery <1.8\n    function( elem, i, match ) {\n      return !!$.data( elem, match[ 3 ] );\n    },\n\n  focusable: function( element ) {\n    return focusable( element, !isNaN( $.attr( element, \"tabindex\" ) ) );\n  },\n\n  tabbable: function( element ) {\n    var tabIndex = $.attr( element, \"tabindex\" ),\n      isTabIndexNaN = isNaN( tabIndex );\n    return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );\n  }\n});\n\n// support: jQuery <1.8\nif ( !$( \"<a>\" ).outerWidth( 1 ).jquery ) {\n  $.each( [ \"Width\", \"Height\" ], function( i, name ) {\n    var side = name === \"Width\" ? [ \"Left\", \"Right\" ] : [ \"Top\", \"Bottom\" ],\n      type = name.toLowerCase(),\n      orig = {\n        innerWidth: $.fn.innerWidth,\n        innerHeight: $.fn.innerHeight,\n        outerWidth: $.fn.outerWidth,\n        outerHeight: $.fn.outerHeight\n      };\n\n    function reduce( elem, size, border, margin ) {\n      $.each( side, function() {\n        size -= parseFloat( $.css( elem, \"padding\" + this ) ) || 0;\n        if ( border ) {\n          size -= parseFloat( $.css( elem, \"border\" + this + \"Width\" ) ) || 0;\n        }\n        if ( margin ) {\n          size -= parseFloat( $.css( elem, \"margin\" + this ) ) || 0;\n        }\n      });\n      return size;\n    }\n\n    $.fn[ \"inner\" + name ] = function( size ) {\n      if ( size === undefined ) {\n        return orig[ \"inner\" + name ].call( this );\n      }\n\n      return this.each(function() {\n        $( this ).css( type, reduce( this, size ) + \"px\" );\n      });\n    };\n\n    $.fn[ \"outer\" + name] = function( size, margin ) {\n      if ( typeof size !== \"number\" ) {\n        return orig[ \"outer\" + name ].call( this, size );\n      }\n\n      return this.each(function() {\n        $( this).css( type, reduce( this, size, true, margin ) + \"px\" );\n      });\n    };\n  });\n}\n\n// support: jQuery <1.8\nif ( !$.fn.addBack ) {\n  $.fn.addBack = function( selector ) {\n    return this.add( selector == null ?\n      this.prevObject : this.prevObject.filter( selector )\n    );\n  };\n}\n\n// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)\nif ( $( \"<a>\" ).data( \"a-b\", \"a\" ).removeData( \"a-b\" ).data( \"a-b\" ) ) {\n  $.fn.removeData = (function( removeData ) {\n    return function( key ) {\n      if ( arguments.length ) {\n        return removeData.call( this, $.camelCase( key ) );\n      } else {\n        return removeData.call( this );\n      }\n    };\n  })( $.fn.removeData );\n}\n\n\n\n\n\n// deprecated\n$.ui.ie = !!/msie [\\w.]+/.exec( navigator.userAgent.toLowerCase() );\n\n$.support.selectstart = \"onselectstart\" in document.createElement( \"div\" );\n$.fn.extend({\n  disableSelection: function() {\n    return this.bind( ( $.support.selectstart ? \"selectstart\" : \"mousedown\" ) +\n      \".ui-disableSelection\", function( event ) {\n        event.preventDefault();\n      });\n  },\n\n  enableSelection: function() {\n    return this.unbind( \".ui-disableSelection\" );\n  }\n});\n\n$.extend( $.ui, {\n  // $.ui.plugin is deprecated.  Use the proxy pattern instead.\n  plugin: {\n    add: function( module, option, set ) {\n      var i,\n        proto = $.ui[ module ].prototype;\n      for ( i in set ) {\n        proto.plugins[ i ] = proto.plugins[ i ] || [];\n        proto.plugins[ i ].push( [ option, set[ i ] ] );\n      }\n    },\n    call: function( instance, name, args ) {\n      var i,\n        set = instance.plugins[ name ];\n      if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {\n        return;\n      }\n\n      for ( i = 0; i < set.length; i++ ) {\n        if ( instance.options[ set[ i ][ 0 ] ] ) {\n          set[ i ][ 1 ].apply( instance.element, args );\n        }\n      }\n    }\n  },\n\n  // only used by resizable\n  hasScroll: function( el, a ) {\n\n    //If overflow is hidden, the element might have extra content, but the user wants to hide it\n    if ( $( el ).css( \"overflow\" ) === \"hidden\") {\n      return false;\n    }\n\n    var scroll = ( a && a === \"left\" ) ? \"scrollLeft\" : \"scrollTop\",\n      has = false;\n\n    if ( el[ scroll ] > 0 ) {\n      return true;\n    }\n\n    // TODO: determine which cases actually cause this to happen\n    // if the element doesn't have the scroll set, see if it's possible to\n    // set the scroll\n    el[ scroll ] = 1;\n    has = ( el[ scroll ] > 0 );\n    el[ scroll ] = 0;\n    return has;\n  }\n});\n\n})( jQuery );\n(function( $, undefined ) {\n\nvar uuid = 0,\n  slice = Array.prototype.slice,\n  _cleanData = $.cleanData;\n$.cleanData = function( elems ) {\n  for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {\n    try {\n      $( elem ).triggerHandler( \"remove\" );\n    // http://bugs.jquery.com/ticket/8235\n    } catch( e ) {}\n  }\n  _cleanData( elems );\n};\n\n$.widget = function( name, base, prototype ) {\n  var fullName, existingConstructor, constructor, basePrototype,\n    // proxiedPrototype allows the provided prototype to remain unmodified\n    // so that it can be used as a mixin for multiple widgets (#8876)\n    proxiedPrototype = {},\n    namespace = name.split( \".\" )[ 0 ];\n\n  name = name.split( \".\" )[ 1 ];\n  fullName = namespace + \"-\" + name;\n\n  if ( !prototype ) {\n    prototype = base;\n    base = $.Widget;\n  }\n\n  // create selector for plugin\n  $.expr[ \":\" ][ fullName.toLowerCase() ] = function( elem ) {\n    return !!$.data( elem, fullName );\n  };\n\n  $[ namespace ] = $[ namespace ] || {};\n  existingConstructor = $[ namespace ][ name ];\n  constructor = $[ namespace ][ name ] = function( options, element ) {\n    // allow instantiation without \"new\" keyword\n    if ( !this._createWidget ) {\n      return new constructor( options, element );\n    }\n\n    // allow instantiation without initializing for simple inheritance\n    // must use \"new\" keyword (the code above always passes args)\n    if ( arguments.length ) {\n      this._createWidget( options, element );\n    }\n  };\n  // extend with the existing constructor to carry over any static properties\n  $.extend( constructor, existingConstructor, {\n    version: prototype.version,\n    // copy the object used to create the prototype in case we need to\n    // redefine the widget later\n    _proto: $.extend( {}, prototype ),\n    // track widgets that inherit from this widget in case this widget is\n    // redefined after a widget inherits from it\n    _childConstructors: []\n  });\n\n  basePrototype = new base();\n  // we need to make the options hash a property directly on the new instance\n  // otherwise we'll modify the options hash on the prototype that we're\n  // inheriting from\n  basePrototype.options = $.widget.extend( {}, basePrototype.options );\n  $.each( prototype, function( prop, value ) {\n    if ( !$.isFunction( value ) ) {\n      proxiedPrototype[ prop ] = value;\n      return;\n    }\n    proxiedPrototype[ prop ] = (function() {\n      var _super = function() {\n          return base.prototype[ prop ].apply( this, arguments );\n        },\n        _superApply = function( args ) {\n          return base.prototype[ prop ].apply( this, args );\n        };\n      return function() {\n        var __super = this._super,\n          __superApply = this._superApply,\n          returnValue;\n\n        this._super = _super;\n        this._superApply = _superApply;\n\n        returnValue = value.apply( this, arguments );\n\n        this._super = __super;\n        this._superApply = __superApply;\n\n        return returnValue;\n      };\n    })();\n  });\n  constructor.prototype = $.widget.extend( basePrototype, {\n    // TODO: remove support for widgetEventPrefix\n    // always use the name + a colon as the prefix, e.g., draggable:start\n    // don't prefix for widgets that aren't DOM-based\n    widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name\n  }, proxiedPrototype, {\n    constructor: constructor,\n    namespace: namespace,\n    widgetName: name,\n    widgetFullName: fullName\n  });\n\n  // If this widget is being redefined then we need to find all widgets that\n  // are inheriting from it and redefine all of them so that they inherit from\n  // the new version of this widget. We're essentially trying to replace one\n  // level in the prototype chain.\n  if ( existingConstructor ) {\n    $.each( existingConstructor._childConstructors, function( i, child ) {\n      var childPrototype = child.prototype;\n\n      // redefine the child widget using the same prototype that was\n      // originally used, but inherit from the new version of the base\n      $.widget( childPrototype.namespace + \".\" + childPrototype.widgetName, constructor, child._proto );\n    });\n    // remove the list of existing child constructors from the old constructor\n    // so the old child constructors can be garbage collected\n    delete existingConstructor._childConstructors;\n  } else {\n    base._childConstructors.push( constructor );\n  }\n\n  $.widget.bridge( name, constructor );\n};\n\n$.widget.extend = function( target ) {\n  var input = slice.call( arguments, 1 ),\n    inputIndex = 0,\n    inputLength = input.length,\n    key,\n    value;\n  for ( ; inputIndex < inputLength; inputIndex++ ) {\n    for ( key in input[ inputIndex ] ) {\n      value = input[ inputIndex ][ key ];\n      if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {\n        // Clone objects\n        if ( $.isPlainObject( value ) ) {\n          target[ key ] = $.isPlainObject( target[ key ] ) ?\n            $.widget.extend( {}, target[ key ], value ) :\n            // Don't extend strings, arrays, etc. with objects\n            $.widget.extend( {}, value );\n        // Copy everything else by reference\n        } else {\n          target[ key ] = value;\n        }\n      }\n    }\n  }\n  return target;\n};\n\n$.widget.bridge = function( name, object ) {\n  var fullName = object.prototype.widgetFullName || name;\n  $.fn[ name ] = function( options ) {\n    var isMethodCall = typeof options === \"string\",\n      args = slice.call( arguments, 1 ),\n      returnValue = this;\n\n    // allow multiple hashes to be passed on init\n    options = !isMethodCall && args.length ?\n      $.widget.extend.apply( null, [ options ].concat(args) ) :\n      options;\n\n    if ( isMethodCall ) {\n      this.each(function() {\n        var methodValue,\n          instance = $.data( this, fullName );\n        if ( !instance ) {\n          return $.error( \"cannot call methods on \" + name + \" prior to initialization; \" +\n            \"attempted to call method '\" + options + \"'\" );\n        }\n        if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === \"_\" ) {\n          return $.error( \"no such method '\" + options + \"' for \" + name + \" widget instance\" );\n        }\n        methodValue = instance[ options ].apply( instance, args );\n        if ( methodValue !== instance && methodValue !== undefined ) {\n          returnValue = methodValue && methodValue.jquery ?\n            returnValue.pushStack( methodValue.get() ) :\n            methodValue;\n          return false;\n        }\n      });\n    } else {\n      this.each(function() {\n        var instance = $.data( this, fullName );\n        if ( instance ) {\n          instance.option( options || {} )._init();\n        } else {\n          $.data( this, fullName, new object( options, this ) );\n        }\n      });\n    }\n\n    return returnValue;\n  };\n};\n\n$.Widget = function( /* options, element */ ) {};\n$.Widget._childConstructors = [];\n\n$.Widget.prototype = {\n  widgetName: \"widget\",\n  widgetEventPrefix: \"\",\n  defaultElement: \"<div>\",\n  options: {\n    disabled: false,\n\n    // callbacks\n    create: null\n  },\n  _createWidget: function( options, element ) {\n    element = $( element || this.defaultElement || this )[ 0 ];\n    this.element = $( element );\n    this.uuid = uuid++;\n    this.eventNamespace = \".\" + this.widgetName + this.uuid;\n    this.options = $.widget.extend( {},\n      this.options,\n      this._getCreateOptions(),\n      options );\n\n    this.bindings = $();\n    this.hoverable = $();\n    this.focusable = $();\n\n    if ( element !== this ) {\n      $.data( element, this.widgetFullName, this );\n      this._on( true, this.element, {\n        remove: function( event ) {\n          if ( event.target === element ) {\n            this.destroy();\n          }\n        }\n      });\n      this.document = $( element.style ?\n        // element within the document\n        element.ownerDocument :\n        // element is window or document\n        element.document || element );\n      this.window = $( this.document[0].defaultView || this.document[0].parentWindow );\n    }\n\n    this._create();\n    this._trigger( \"create\", null, this._getCreateEventData() );\n    this._init();\n  },\n  _getCreateOptions: $.noop,\n  _getCreateEventData: $.noop,\n  _create: $.noop,\n  _init: $.noop,\n\n  destroy: function() {\n    this._destroy();\n    // we can probably remove the unbind calls in 2.0\n    // all event bindings should go through this._on()\n    this.element\n      .unbind( this.eventNamespace )\n      // 1.9 BC for #7810\n      // TODO remove dual storage\n      .removeData( this.widgetName )\n      .removeData( this.widgetFullName )\n      // support: jquery <1.6.3\n      // http://bugs.jquery.com/ticket/9413\n      .removeData( $.camelCase( this.widgetFullName ) );\n    this.widget()\n      .unbind( this.eventNamespace )\n      .removeAttr( \"aria-disabled\" )\n      .removeClass(\n        this.widgetFullName + \"-disabled \" +\n        \"ui-state-disabled\" );\n\n    // clean up events and states\n    this.bindings.unbind( this.eventNamespace );\n    this.hoverable.removeClass( \"ui-state-hover\" );\n    this.focusable.removeClass( \"ui-state-focus\" );\n  },\n  _destroy: $.noop,\n\n  widget: function() {\n    return this.element;\n  },\n\n  option: function( key, value ) {\n    var options = key,\n      parts,\n      curOption,\n      i;\n\n    if ( arguments.length === 0 ) {\n      // don't return a reference to the internal hash\n      return $.widget.extend( {}, this.options );\n    }\n\n    if ( typeof key === \"string\" ) {\n      // handle nested keys, e.g., \"foo.bar\" => { foo: { bar: ___ } }\n      options = {};\n      parts = key.split( \".\" );\n      key = parts.shift();\n      if ( parts.length ) {\n        curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );\n        for ( i = 0; i < parts.length - 1; i++ ) {\n          curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};\n          curOption = curOption[ parts[ i ] ];\n        }\n        key = parts.pop();\n        if ( value === undefined ) {\n          return curOption[ key ] === undefined ? null : curOption[ key ];\n        }\n        curOption[ key ] = value;\n      } else {\n        if ( value === undefined ) {\n          return this.options[ key ] === undefined ? null : this.options[ key ];\n        }\n        options[ key ] = value;\n      }\n    }\n\n    this._setOptions( options );\n\n    return this;\n  },\n  _setOptions: function( options ) {\n    var key;\n\n    for ( key in options ) {\n      this._setOption( key, options[ key ] );\n    }\n\n    return this;\n  },\n  _setOption: function( key, value ) {\n    this.options[ key ] = value;\n\n    if ( key === \"disabled\" ) {\n      this.widget()\n        .toggleClass( this.widgetFullName + \"-disabled ui-state-disabled\", !!value )\n        .attr( \"aria-disabled\", value );\n      this.hoverable.removeClass( \"ui-state-hover\" );\n      this.focusable.removeClass( \"ui-state-focus\" );\n    }\n\n    return this;\n  },\n\n  enable: function() {\n    return this._setOption( \"disabled\", false );\n  },\n  disable: function() {\n    return this._setOption( \"disabled\", true );\n  },\n\n  _on: function( suppressDisabledCheck, element, handlers ) {\n    var delegateElement,\n      instance = this;\n\n    // no suppressDisabledCheck flag, shuffle arguments\n    if ( typeof suppressDisabledCheck !== \"boolean\" ) {\n      handlers = element;\n      element = suppressDisabledCheck;\n      suppressDisabledCheck = false;\n    }\n\n    // no element argument, shuffle and use this.element\n    if ( !handlers ) {\n      handlers = element;\n      element = this.element;\n      delegateElement = this.widget();\n    } else {\n      // accept selectors, DOM elements\n      element = delegateElement = $( element );\n      this.bindings = this.bindings.add( element );\n    }\n\n    $.each( handlers, function( event, handler ) {\n      function handlerProxy() {\n        // allow widgets to customize the disabled handling\n        // - disabled as an array instead of boolean\n        // - disabled class as method for disabling individual parts\n        if ( !suppressDisabledCheck &&\n            ( instance.options.disabled === true ||\n              $( this ).hasClass( \"ui-state-disabled\" ) ) ) {\n          return;\n        }\n        return ( typeof handler === \"string\" ? instance[ handler ] : handler )\n          .apply( instance, arguments );\n      }\n\n      // copy the guid so direct unbinding works\n      if ( typeof handler !== \"string\" ) {\n        handlerProxy.guid = handler.guid =\n          handler.guid || handlerProxy.guid || $.guid++;\n      }\n\n      var match = event.match( /^(\\w+)\\s*(.*)$/ ),\n        eventName = match[1] + instance.eventNamespace,\n        selector = match[2];\n      if ( selector ) {\n        delegateElement.delegate( selector, eventName, handlerProxy );\n      } else {\n        element.bind( eventName, handlerProxy );\n      }\n    });\n  },\n\n  _off: function( element, eventName ) {\n    eventName = (eventName || \"\").split( \" \" ).join( this.eventNamespace + \" \" ) + this.eventNamespace;\n    element.unbind( eventName ).undelegate( eventName );\n  },\n\n  _delay: function( handler, delay ) {\n    function handlerProxy() {\n      return ( typeof handler === \"string\" ? instance[ handler ] : handler )\n        .apply( instance, arguments );\n    }\n    var instance = this;\n    return setTimeout( handlerProxy, delay || 0 );\n  },\n\n  _hoverable: function( element ) {\n    this.hoverable = this.hoverable.add( element );\n    this._on( element, {\n      mouseenter: function( event ) {\n        $( event.currentTarget ).addClass( \"ui-state-hover\" );\n      },\n      mouseleave: function( event ) {\n        $( event.currentTarget ).removeClass( \"ui-state-hover\" );\n      }\n    });\n  },\n\n  _focusable: function( element ) {\n    this.focusable = this.focusable.add( element );\n    this._on( element, {\n      focusin: function( event ) {\n        $( event.currentTarget ).addClass( \"ui-state-focus\" );\n      },\n      focusout: function( event ) {\n        $( event.currentTarget ).removeClass( \"ui-state-focus\" );\n      }\n    });\n  },\n\n  _trigger: function( type, event, data ) {\n    var prop, orig,\n      callback = this.options[ type ];\n\n    data = data || {};\n    event = $.Event( event );\n    event.type = ( type === this.widgetEventPrefix ?\n      type :\n      this.widgetEventPrefix + type ).toLowerCase();\n    // the original event may come from any element\n    // so we need to reset the target on the new event\n    event.target = this.element[ 0 ];\n\n    // copy original event properties over to the new event\n    orig = event.originalEvent;\n    if ( orig ) {\n      for ( prop in orig ) {\n        if ( !( prop in event ) ) {\n          event[ prop ] = orig[ prop ];\n        }\n      }\n    }\n\n    this.element.trigger( event, data );\n    return !( $.isFunction( callback ) &&\n      callback.apply( this.element[0], [ event ].concat( data ) ) === false ||\n      event.isDefaultPrevented() );\n  }\n};\n\n$.each( { show: \"fadeIn\", hide: \"fadeOut\" }, function( method, defaultEffect ) {\n  $.Widget.prototype[ \"_\" + method ] = function( element, options, callback ) {\n    if ( typeof options === \"string\" ) {\n      options = { effect: options };\n    }\n    var hasOptions,\n      effectName = !options ?\n        method :\n        options === true || typeof options === \"number\" ?\n          defaultEffect :\n          options.effect || defaultEffect;\n    options = options || {};\n    if ( typeof options === \"number\" ) {\n      options = { duration: options };\n    }\n    hasOptions = !$.isEmptyObject( options );\n    options.complete = callback;\n    if ( options.delay ) {\n      element.delay( options.delay );\n    }\n    if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {\n      element[ method ]( options );\n    } else if ( effectName !== method && element[ effectName ] ) {\n      element[ effectName ]( options.duration, options.easing, callback );\n    } else {\n      element.queue(function( next ) {\n        $( this )[ method ]();\n        if ( callback ) {\n          callback.call( element[ 0 ] );\n        }\n        next();\n      });\n    }\n  };\n});\n\n})( jQuery );\n(function( $, undefined ) {\n\nvar mouseHandled = false;\n$( document ).mouseup( function() {\n  mouseHandled = false;\n});\n\n$.widget(\"ui.mouse\", {\n  version: \"1.10.1\",\n  options: {\n    cancel: \"input,textarea,button,select,option\",\n    distance: 1,\n    delay: 0\n  },\n  _mouseInit: function() {\n    var that = this;\n\n    this.element\n      .bind(\"mousedown.\"+this.widgetName, function(event) {\n        return that._mouseDown(event);\n      })\n      .bind(\"click.\"+this.widgetName, function(event) {\n        if (true === $.data(event.target, that.widgetName + \".preventClickEvent\")) {\n          $.removeData(event.target, that.widgetName + \".preventClickEvent\");\n          event.stopImmediatePropagation();\n          return false;\n        }\n      });\n\n    this.started = false;\n  },\n\n  // TODO: make sure destroying one instance of mouse doesn't mess with\n  // other instances of mouse\n  _mouseDestroy: function() {\n    this.element.unbind(\".\"+this.widgetName);\n    if ( this._mouseMoveDelegate ) {\n      $(document)\n        .unbind(\"mousemove.\"+this.widgetName, this._mouseMoveDelegate)\n        .unbind(\"mouseup.\"+this.widgetName, this._mouseUpDelegate);\n    }\n  },\n\n  _mouseDown: function(event) {\n    // don't let more than one widget handle mouseStart\n    if( mouseHandled ) { return; }\n\n    // we may have missed mouseup (out of window)\n    (this._mouseStarted && this._mouseUp(event));\n\n    this._mouseDownEvent = event;\n\n    var that = this,\n      btnIsLeft = (event.which === 1),\n      // event.target.nodeName works around a bug in IE 8 with\n      // disabled inputs (#7620)\n      elIsCancel = (typeof this.options.cancel === \"string\" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);\n    if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {\n      return true;\n    }\n\n    this.mouseDelayMet = !this.options.delay;\n    if (!this.mouseDelayMet) {\n      this._mouseDelayTimer = setTimeout(function() {\n        that.mouseDelayMet = true;\n      }, this.options.delay);\n    }\n\n    if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {\n      this._mouseStarted = (this._mouseStart(event) !== false);\n      if (!this._mouseStarted) {\n        event.preventDefault();\n        return true;\n      }\n    }\n\n    // Click event may never have fired (Gecko & Opera)\n    if (true === $.data(event.target, this.widgetName + \".preventClickEvent\")) {\n      $.removeData(event.target, this.widgetName + \".preventClickEvent\");\n    }\n\n    // these delegates are required to keep context\n    this._mouseMoveDelegate = function(event) {\n      return that._mouseMove(event);\n    };\n    this._mouseUpDelegate = function(event) {\n      return that._mouseUp(event);\n    };\n    $(document)\n      .bind(\"mousemove.\"+this.widgetName, this._mouseMoveDelegate)\n      .bind(\"mouseup.\"+this.widgetName, this._mouseUpDelegate);\n\n    event.preventDefault();\n\n    mouseHandled = true;\n    return true;\n  },\n\n  _mouseMove: function(event) {\n    // IE mouseup check - mouseup happened when mouse was out of window\n    if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {\n      return this._mouseUp(event);\n    }\n\n    if (this._mouseStarted) {\n      this._mouseDrag(event);\n      return event.preventDefault();\n    }\n\n    if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {\n      this._mouseStarted =\n        (this._mouseStart(this._mouseDownEvent, event) !== false);\n      (this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));\n    }\n\n    return !this._mouseStarted;\n  },\n\n  _mouseUp: function(event) {\n    $(document)\n      .unbind(\"mousemove.\"+this.widgetName, this._mouseMoveDelegate)\n      .unbind(\"mouseup.\"+this.widgetName, this._mouseUpDelegate);\n\n    if (this._mouseStarted) {\n      this._mouseStarted = false;\n\n      if (event.target === this._mouseDownEvent.target) {\n        $.data(event.target, this.widgetName + \".preventClickEvent\", true);\n      }\n\n      this._mouseStop(event);\n    }\n\n    return false;\n  },\n\n  _mouseDistanceMet: function(event) {\n    return (Math.max(\n        Math.abs(this._mouseDownEvent.pageX - event.pageX),\n        Math.abs(this._mouseDownEvent.pageY - event.pageY)\n      ) >= this.options.distance\n    );\n  },\n\n  _mouseDelayMet: function(/* event */) {\n    return this.mouseDelayMet;\n  },\n\n  // These are placeholder methods, to be overriden by extending plugin\n  _mouseStart: function(/* event */) {},\n  _mouseDrag: function(/* event */) {},\n  _mouseStop: function(/* event */) {},\n  _mouseCapture: function(/* event */) { return true; }\n});\n\n})(jQuery);\n(function( $, undefined ) {\n\n$.ui = $.ui || {};\n\nvar cachedScrollbarWidth,\n  max = Math.max,\n  abs = Math.abs,\n  round = Math.round,\n  rhorizontal = /left|center|right/,\n  rvertical = /top|center|bottom/,\n  roffset = /[\\+\\-]\\d+(\\.[\\d]+)?%?/,\n  rposition = /^\\w+/,\n  rpercent = /%$/,\n  _position = $.fn.position;\n\nfunction getOffsets( offsets, width, height ) {\n  return [\n    parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),\n    parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )\n  ];\n}\n\nfunction parseCss( element, property ) {\n  return parseInt( $.css( element, property ), 10 ) || 0;\n}\n\nfunction getDimensions( elem ) {\n  var raw = elem[0];\n  if ( raw.nodeType === 9 ) {\n    return {\n      width: elem.width(),\n      height: elem.height(),\n      offset: { top: 0, left: 0 }\n    };\n  }\n  if ( $.isWindow( raw ) ) {\n    return {\n      width: elem.width(),\n      height: elem.height(),\n      offset: { top: elem.scrollTop(), left: elem.scrollLeft() }\n    };\n  }\n  if ( raw.preventDefault ) {\n    return {\n      width: 0,\n      height: 0,\n      offset: { top: raw.pageY, left: raw.pageX }\n    };\n  }\n  return {\n    width: elem.outerWidth(),\n    height: elem.outerHeight(),\n    offset: elem.offset()\n  };\n}\n\n$.position = {\n  scrollbarWidth: function() {\n    if ( cachedScrollbarWidth !== undefined ) {\n      return cachedScrollbarWidth;\n    }\n    var w1, w2,\n      div = $( \"<div style='display:block;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>\" ),\n      innerDiv = div.children()[0];\n\n    $( \"body\" ).append( div );\n    w1 = innerDiv.offsetWidth;\n    div.css( \"overflow\", \"scroll\" );\n\n    w2 = innerDiv.offsetWidth;\n\n    if ( w1 === w2 ) {\n      w2 = div[0].clientWidth;\n    }\n\n    div.remove();\n\n    return (cachedScrollbarWidth = w1 - w2);\n  },\n  getScrollInfo: function( within ) {\n    var overflowX = within.isWindow ? \"\" : within.element.css( \"overflow-x\" ),\n      overflowY = within.isWindow ? \"\" : within.element.css( \"overflow-y\" ),\n      hasOverflowX = overflowX === \"scroll\" ||\n        ( overflowX === \"auto\" && within.width < within.element[0].scrollWidth ),\n      hasOverflowY = overflowY === \"scroll\" ||\n        ( overflowY === \"auto\" && within.height < within.element[0].scrollHeight );\n    return {\n      width: hasOverflowX ? $.position.scrollbarWidth() : 0,\n      height: hasOverflowY ? $.position.scrollbarWidth() : 0\n    };\n  },\n  getWithinInfo: function( element ) {\n    var withinElement = $( element || window ),\n      isWindow = $.isWindow( withinElement[0] );\n    return {\n      element: withinElement,\n      isWindow: isWindow,\n      offset: withinElement.offset() || { left: 0, top: 0 },\n      scrollLeft: withinElement.scrollLeft(),\n      scrollTop: withinElement.scrollTop(),\n      width: isWindow ? withinElement.width() : withinElement.outerWidth(),\n      height: isWindow ? withinElement.height() : withinElement.outerHeight()\n    };\n  }\n};\n\n$.fn.position = function( options ) {\n  if ( !options || !options.of ) {\n    return _position.apply( this, arguments );\n  }\n\n  // make a copy, we don't want to modify arguments\n  options = $.extend( {}, options );\n\n  var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,\n    target = $( options.of ),\n    within = $.position.getWithinInfo( options.within ),\n    scrollInfo = $.position.getScrollInfo( within ),\n    collision = ( options.collision || \"flip\" ).split( \" \" ),\n    offsets = {};\n\n  dimensions = getDimensions( target );\n  if ( target[0].preventDefault ) {\n    // force left top to allow flipping\n    options.at = \"left top\";\n  }\n  targetWidth = dimensions.width;\n  targetHeight = dimensions.height;\n  targetOffset = dimensions.offset;\n  // clone to reuse original targetOffset later\n  basePosition = $.extend( {}, targetOffset );\n\n  // force my and at to have valid horizontal and vertical positions\n  // if a value is missing or invalid, it will be converted to center\n  $.each( [ \"my\", \"at\" ], function() {\n    var pos = ( options[ this ] || \"\" ).split( \" \" ),\n      horizontalOffset,\n      verticalOffset;\n\n    if ( pos.length === 1) {\n      pos = rhorizontal.test( pos[ 0 ] ) ?\n        pos.concat( [ \"center\" ] ) :\n        rvertical.test( pos[ 0 ] ) ?\n          [ \"center\" ].concat( pos ) :\n          [ \"center\", \"center\" ];\n    }\n    pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : \"center\";\n    pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : \"center\";\n\n    // calculate offsets\n    horizontalOffset = roffset.exec( pos[ 0 ] );\n    verticalOffset = roffset.exec( pos[ 1 ] );\n    offsets[ this ] = [\n      horizontalOffset ? horizontalOffset[ 0 ] : 0,\n      verticalOffset ? verticalOffset[ 0 ] : 0\n    ];\n\n    // reduce to just the positions without the offsets\n    options[ this ] = [\n      rposition.exec( pos[ 0 ] )[ 0 ],\n      rposition.exec( pos[ 1 ] )[ 0 ]\n    ];\n  });\n\n  // normalize collision option\n  if ( collision.length === 1 ) {\n    collision[ 1 ] = collision[ 0 ];\n  }\n\n  if ( options.at[ 0 ] === \"right\" ) {\n    basePosition.left += targetWidth;\n  } else if ( options.at[ 0 ] === \"center\" ) {\n    basePosition.left += targetWidth / 2;\n  }\n\n  if ( options.at[ 1 ] === \"bottom\" ) {\n    basePosition.top += targetHeight;\n  } else if ( options.at[ 1 ] === \"center\" ) {\n    basePosition.top += targetHeight / 2;\n  }\n\n  atOffset = getOffsets( offsets.at, targetWidth, targetHeight );\n  basePosition.left += atOffset[ 0 ];\n  basePosition.top += atOffset[ 1 ];\n\n  return this.each(function() {\n    var collisionPosition, using,\n      elem = $( this ),\n      elemWidth = elem.outerWidth(),\n      elemHeight = elem.outerHeight(),\n      marginLeft = parseCss( this, \"marginLeft\" ),\n      marginTop = parseCss( this, \"marginTop\" ),\n      collisionWidth = elemWidth + marginLeft + parseCss( this, \"marginRight\" ) + scrollInfo.width,\n      collisionHeight = elemHeight + marginTop + parseCss( this, \"marginBottom\" ) + scrollInfo.height,\n      position = $.extend( {}, basePosition ),\n      myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );\n\n    if ( options.my[ 0 ] === \"right\" ) {\n      position.left -= elemWidth;\n    } else if ( options.my[ 0 ] === \"center\" ) {\n      position.left -= elemWidth / 2;\n    }\n\n    if ( options.my[ 1 ] === \"bottom\" ) {\n      position.top -= elemHeight;\n    } else if ( options.my[ 1 ] === \"center\" ) {\n      position.top -= elemHeight / 2;\n    }\n\n    position.left += myOffset[ 0 ];\n    position.top += myOffset[ 1 ];\n\n    // if the browser doesn't support fractions, then round for consistent results\n    if ( !$.support.offsetFractions ) {\n      position.left = round( position.left );\n      position.top = round( position.top );\n    }\n\n    collisionPosition = {\n      marginLeft: marginLeft,\n      marginTop: marginTop\n    };\n\n    $.each( [ \"left\", \"top\" ], function( i, dir ) {\n      if ( $.ui.position[ collision[ i ] ] ) {\n        $.ui.position[ collision[ i ] ][ dir ]( position, {\n          targetWidth: targetWidth,\n          targetHeight: targetHeight,\n          elemWidth: elemWidth,\n          elemHeight: elemHeight,\n          collisionPosition: collisionPosition,\n          collisionWidth: collisionWidth,\n          collisionHeight: collisionHeight,\n          offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],\n          my: options.my,\n          at: options.at,\n          within: within,\n          elem : elem\n        });\n      }\n    });\n\n    if ( options.using ) {\n      // adds feedback as second argument to using callback, if present\n      using = function( props ) {\n        var left = targetOffset.left - position.left,\n          right = left + targetWidth - elemWidth,\n          top = targetOffset.top - position.top,\n          bottom = top + targetHeight - elemHeight,\n          feedback = {\n            target: {\n              element: target,\n              left: targetOffset.left,\n              top: targetOffset.top,\n              width: targetWidth,\n              height: targetHeight\n            },\n            element: {\n              element: elem,\n              left: position.left,\n              top: position.top,\n              width: elemWidth,\n              height: elemHeight\n            },\n            horizontal: right < 0 ? \"left\" : left > 0 ? \"right\" : \"center\",\n            vertical: bottom < 0 ? \"top\" : top > 0 ? \"bottom\" : \"middle\"\n          };\n        if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {\n          feedback.horizontal = \"center\";\n        }\n        if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {\n          feedback.vertical = \"middle\";\n        }\n        if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {\n          feedback.important = \"horizontal\";\n        } else {\n          feedback.important = \"vertical\";\n        }\n        options.using.call( this, props, feedback );\n      };\n    }\n\n    elem.offset( $.extend( position, { using: using } ) );\n  });\n};\n\n$.ui.position = {\n  fit: {\n    left: function( position, data ) {\n      var within = data.within,\n        withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,\n        outerWidth = within.width,\n        collisionPosLeft = position.left - data.collisionPosition.marginLeft,\n        overLeft = withinOffset - collisionPosLeft,\n        overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,\n        newOverRight;\n\n      // element is wider than within\n      if ( data.collisionWidth > outerWidth ) {\n        // element is initially over the left side of within\n        if ( overLeft > 0 && overRight <= 0 ) {\n          newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;\n          position.left += overLeft - newOverRight;\n        // element is initially over right side of within\n        } else if ( overRight > 0 && overLeft <= 0 ) {\n          position.left = withinOffset;\n        // element is initially over both left and right sides of within\n        } else {\n          if ( overLeft > overRight ) {\n            position.left = withinOffset + outerWidth - data.collisionWidth;\n          } else {\n            position.left = withinOffset;\n          }\n        }\n      // too far left -> align with left edge\n      } else if ( overLeft > 0 ) {\n        position.left += overLeft;\n      // too far right -> align with right edge\n      } else if ( overRight > 0 ) {\n        position.left -= overRight;\n      // adjust based on position and margin\n      } else {\n        position.left = max( position.left - collisionPosLeft, position.left );\n      }\n    },\n    top: function( position, data ) {\n      var within = data.within,\n        withinOffset = within.isWindow ? within.scrollTop : within.offset.top,\n        outerHeight = data.within.height,\n        collisionPosTop = position.top - data.collisionPosition.marginTop,\n        overTop = withinOffset - collisionPosTop,\n        overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,\n        newOverBottom;\n\n      // element is taller than within\n      if ( data.collisionHeight > outerHeight ) {\n        // element is initially over the top of within\n        if ( overTop > 0 && overBottom <= 0 ) {\n          newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;\n          position.top += overTop - newOverBottom;\n        // element is initially over bottom of within\n        } else if ( overBottom > 0 && overTop <= 0 ) {\n          position.top = withinOffset;\n        // element is initially over both top and bottom of within\n        } else {\n          if ( overTop > overBottom ) {\n            position.top = withinOffset + outerHeight - data.collisionHeight;\n          } else {\n            position.top = withinOffset;\n          }\n        }\n      // too far up -> align with top\n      } else if ( overTop > 0 ) {\n        position.top += overTop;\n      // too far down -> align with bottom edge\n      } else if ( overBottom > 0 ) {\n        position.top -= overBottom;\n      // adjust based on position and margin\n      } else {\n        position.top = max( position.top - collisionPosTop, position.top );\n      }\n    }\n  },\n  flip: {\n    left: function( position, data ) {\n      var within = data.within,\n        withinOffset = within.offset.left + within.scrollLeft,\n        outerWidth = within.width,\n        offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,\n        collisionPosLeft = position.left - data.collisionPosition.marginLeft,\n        overLeft = collisionPosLeft - offsetLeft,\n        overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,\n        myOffset = data.my[ 0 ] === \"left\" ?\n          -data.elemWidth :\n          data.my[ 0 ] === \"right\" ?\n            data.elemWidth :\n            0,\n        atOffset = data.at[ 0 ] === \"left\" ?\n          data.targetWidth :\n          data.at[ 0 ] === \"right\" ?\n            -data.targetWidth :\n            0,\n        offset = -2 * data.offset[ 0 ],\n        newOverRight,\n        newOverLeft;\n\n      if ( overLeft < 0 ) {\n        newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;\n        if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {\n          position.left += myOffset + atOffset + offset;\n        }\n      }\n      else if ( overRight > 0 ) {\n        newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;\n        if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {\n          position.left += myOffset + atOffset + offset;\n        }\n      }\n    },\n    top: function( position, data ) {\n      var within = data.within,\n        withinOffset = within.offset.top + within.scrollTop,\n        outerHeight = within.height,\n        offsetTop = within.isWindow ? within.scrollTop : within.offset.top,\n        collisionPosTop = position.top - data.collisionPosition.marginTop,\n        overTop = collisionPosTop - offsetTop,\n        overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,\n        top = data.my[ 1 ] === \"top\",\n        myOffset = top ?\n          -data.elemHeight :\n          data.my[ 1 ] === \"bottom\" ?\n            data.elemHeight :\n            0,\n        atOffset = data.at[ 1 ] === \"top\" ?\n          data.targetHeight :\n          data.at[ 1 ] === \"bottom\" ?\n            -data.targetHeight :\n            0,\n        offset = -2 * data.offset[ 1 ],\n        newOverTop,\n        newOverBottom;\n      if ( overTop < 0 ) {\n        newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;\n        if ( ( position.top + myOffset + atOffset + offset) > overTop && ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) ) {\n          position.top += myOffset + atOffset + offset;\n        }\n      }\n      else if ( overBottom > 0 ) {\n        newOverTop = position.top -  data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;\n        if ( ( position.top + myOffset + atOffset + offset) > overBottom && ( newOverTop > 0 || abs( newOverTop ) < overBottom ) ) {\n          position.top += myOffset + atOffset + offset;\n        }\n      }\n    }\n  },\n  flipfit: {\n    left: function() {\n      $.ui.position.flip.left.apply( this, arguments );\n      $.ui.position.fit.left.apply( this, arguments );\n    },\n    top: function() {\n      $.ui.position.flip.top.apply( this, arguments );\n      $.ui.position.fit.top.apply( this, arguments );\n    }\n  }\n};\n\n// fraction support test\n(function () {\n  var testElement, testElementParent, testElementStyle, offsetLeft, i,\n    body = document.getElementsByTagName( \"body\" )[ 0 ],\n    div = document.createElement( \"div\" );\n\n  //Create a \"fake body\" for testing based on method used in jQuery.support\n  testElement = document.createElement( body ? \"div\" : \"body\" );\n  testElementStyle = {\n    visibility: \"hidden\",\n    width: 0,\n    height: 0,\n    border: 0,\n    margin: 0,\n    background: \"none\"\n  };\n  if ( body ) {\n    $.extend( testElementStyle, {\n      position: \"absolute\",\n      left: \"-1000px\",\n      top: \"-1000px\"\n    });\n  }\n  for ( i in testElementStyle ) {\n    testElement.style[ i ] = testElementStyle[ i ];\n  }\n  testElement.appendChild( div );\n  testElementParent = body || document.documentElement;\n  testElementParent.insertBefore( testElement, testElementParent.firstChild );\n\n  div.style.cssText = \"position: absolute; left: 10.7432222px;\";\n\n  offsetLeft = $( div ).offset().left;\n  $.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;\n\n  testElement.innerHTML = \"\";\n  testElementParent.removeChild( testElement );\n})();\n\n}( jQuery ) );\n(function( $, undefined ) {\n\n$.widget(\"ui.draggable\", $.ui.mouse, {\n  version: \"1.10.1\",\n  widgetEventPrefix: \"drag\",\n  options: {\n    addClasses: true,\n    appendTo: \"parent\",\n    axis: false,\n    connectToSortable: false,\n    containment: false,\n    cursor: \"auto\",\n    cursorAt: false,\n    grid: false,\n    handle: false,\n    helper: \"original\",\n    iframeFix: false,\n    opacity: false,\n    refreshPositions: false,\n    revert: false,\n    revertDuration: 500,\n    scope: \"default\",\n    scroll: true,\n    scrollSensitivity: 20,\n    scrollSpeed: 20,\n    snap: false,\n    snapMode: \"both\",\n    snapTolerance: 20,\n    stack: false,\n    zIndex: false,\n\n    // callbacks\n    drag: null,\n    start: null,\n    stop: null\n  },\n  _create: function() {\n\n    if (this.options.helper === \"original\" && !(/^(?:r|a|f)/).test(this.element.css(\"position\"))) {\n      this.element[0].style.position = \"relative\";\n    }\n    if (this.options.addClasses){\n      this.element.addClass(\"ui-draggable\");\n    }\n    if (this.options.disabled){\n      this.element.addClass(\"ui-draggable-disabled\");\n    }\n\n    this._mouseInit();\n\n  },\n\n  _destroy: function() {\n    this.element.removeClass( \"ui-draggable ui-draggable-dragging ui-draggable-disabled\" );\n    this._mouseDestroy();\n  },\n\n  _mouseCapture: function(event) {\n\n    var o = this.options;\n\n    // among others, prevent a drag on a resizable-handle\n    if (this.helper || o.disabled || $(event.target).closest(\".ui-resizable-handle\").length > 0) {\n      return false;\n    }\n\n    //Quit if we're not on a valid handle\n    this.handle = this._getHandle(event);\n    if (!this.handle) {\n      return false;\n    }\n\n    $(o.iframeFix === true ? \"iframe\" : o.iframeFix).each(function() {\n      $(\"<div class='ui-draggable-iframeFix' style='background: #fff;'></div>\")\n      .css({\n        width: this.offsetWidth+\"px\", height: this.offsetHeight+\"px\",\n        position: \"absolute\", opacity: \"0.001\", zIndex: 1000\n      })\n      .css($(this).offset())\n      .appendTo(\"body\");\n    });\n\n    return true;\n\n  },\n\n  _mouseStart: function(event) {\n\n    var o = this.options;\n\n    //Create and append the visible helper\n    this.helper = this._createHelper(event);\n\n    this.helper.addClass(\"ui-draggable-dragging\");\n\n    //Cache the helper size\n    this._cacheHelperProportions();\n\n    //If ddmanager is used for droppables, set the global draggable\n    if($.ui.ddmanager) {\n      $.ui.ddmanager.current = this;\n    }\n\n    /*\n     * - Position generation -\n     * This block generates everything position related - it's the core of draggables.\n     */\n\n    //Cache the margins of the original element\n    this._cacheMargins();\n\n    //Store the helper's css position\n    this.cssPosition = this.helper.css(\"position\");\n    this.scrollParent = this.helper.scrollParent();\n\n    //The element's absolute position on the page minus margins\n    this.offset = this.positionAbs = this.element.offset();\n    this.offset = {\n      top: this.offset.top - this.margins.top,\n      left: this.offset.left - this.margins.left\n    };\n\n    $.extend(this.offset, {\n      click: { //Where the click happened, relative to the element\n        left: event.pageX - this.offset.left,\n        top: event.pageY - this.offset.top\n      },\n      parent: this._getParentOffset(),\n      relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper\n    });\n\n    //Generate the original position\n    this.originalPosition = this.position = this._generatePosition(event);\n    this.originalPageX = event.pageX;\n    this.originalPageY = event.pageY;\n\n    //Adjust the mouse offset relative to the helper if \"cursorAt\" is supplied\n    (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));\n\n    //Set a containment if given in the options\n    if(o.containment) {\n      this._setContainment();\n    }\n\n    //Trigger event + callbacks\n    if(this._trigger(\"start\", event) === false) {\n      this._clear();\n      return false;\n    }\n\n    //Recache the helper size\n    this._cacheHelperProportions();\n\n    //Prepare the droppable offsets\n    if ($.ui.ddmanager && !o.dropBehaviour) {\n      $.ui.ddmanager.prepareOffsets(this, event);\n    }\n\n\n    this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position\n\n    //If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)\n    if ( $.ui.ddmanager ) {\n      $.ui.ddmanager.dragStart(this, event);\n    }\n\n    return true;\n  },\n\n  _mouseDrag: function(event, noPropagation) {\n\n    //Compute the helpers position\n    this.position = this._generatePosition(event);\n    this.positionAbs = this._convertPositionTo(\"absolute\");\n\n    //Call plugins and callbacks and use the resulting position if something is returned\n    if (!noPropagation) {\n      var ui = this._uiHash();\n      if(this._trigger(\"drag\", event, ui) === false) {\n        this._mouseUp({});\n        return false;\n      }\n      this.position = ui.position;\n    }\n\n    if(!this.options.axis || this.options.axis !== \"y\") {\n      this.helper[0].style.left = this.position.left+\"px\";\n    }\n    if(!this.options.axis || this.options.axis !== \"x\") {\n      this.helper[0].style.top = this.position.top+\"px\";\n    }\n    if($.ui.ddmanager) {\n      $.ui.ddmanager.drag(this, event);\n    }\n\n    return false;\n  },\n\n  _mouseStop: function(event) {\n\n    //If we are using droppables, inform the manager about the drop\n    var element,\n      that = this,\n      elementInDom = false,\n      dropped = false;\n    if ($.ui.ddmanager && !this.options.dropBehaviour) {\n      dropped = $.ui.ddmanager.drop(this, event);\n    }\n\n    //if a drop comes from outside (a sortable)\n    if(this.dropped) {\n      dropped = this.dropped;\n      this.dropped = false;\n    }\n\n    //if the original element is no longer in the DOM don't bother to continue (see #8269)\n    element = this.element[0];\n    while ( element && (element = element.parentNode) ) {\n      if (element === document ) {\n        elementInDom = true;\n      }\n    }\n    if ( !elementInDom && this.options.helper === \"original\" ) {\n      return false;\n    }\n\n    if((this.options.revert === \"invalid\" && !dropped) || (this.options.revert === \"valid\" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {\n      $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {\n        if(that._trigger(\"stop\", event) !== false) {\n          that._clear();\n        }\n      });\n    } else {\n      if(this._trigger(\"stop\", event) !== false) {\n        this._clear();\n      }\n    }\n\n    return false;\n  },\n\n  _mouseUp: function(event) {\n    //Remove frame helpers\n    $(\"div.ui-draggable-iframeFix\").each(function() {\n      this.parentNode.removeChild(this);\n    });\n\n    //If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)\n    if( $.ui.ddmanager ) {\n      $.ui.ddmanager.dragStop(this, event);\n    }\n\n    return $.ui.mouse.prototype._mouseUp.call(this, event);\n  },\n\n  cancel: function() {\n\n    if(this.helper.is(\".ui-draggable-dragging\")) {\n      this._mouseUp({});\n    } else {\n      this._clear();\n    }\n\n    return this;\n\n  },\n\n  _getHandle: function(event) {\n\n    var handle = !this.options.handle || !$(this.options.handle, this.element).length ? true : false;\n    $(this.options.handle, this.element)\n      .find(\"*\")\n      .addBack()\n      .each(function() {\n        if(this === event.target) {\n          handle = true;\n        }\n      });\n\n    return handle;\n\n  },\n\n  _createHelper: function(event) {\n\n    var o = this.options,\n      helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper === \"clone\" ? this.element.clone().removeAttr(\"id\") : this.element);\n\n    if(!helper.parents(\"body\").length) {\n      helper.appendTo((o.appendTo === \"parent\" ? this.element[0].parentNode : o.appendTo));\n    }\n\n    if(helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css(\"position\"))) {\n      helper.css(\"position\", \"absolute\");\n    }\n\n    return helper;\n\n  },\n\n  _adjustOffsetFromHelper: function(obj) {\n    if (typeof obj === \"string\") {\n      obj = obj.split(\" \");\n    }\n    if ($.isArray(obj)) {\n      obj = {left: +obj[0], top: +obj[1] || 0};\n    }\n    if (\"left\" in obj) {\n      this.offset.click.left = obj.left + this.margins.left;\n    }\n    if (\"right\" in obj) {\n      this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;\n    }\n    if (\"top\" in obj) {\n      this.offset.click.top = obj.top + this.margins.top;\n    }\n    if (\"bottom\" in obj) {\n      this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;\n    }\n  },\n\n  _getParentOffset: function() {\n\n    //Get the offsetParent and cache its position\n    this.offsetParent = this.helper.offsetParent();\n    var po = this.offsetParent.offset();\n\n    // This is a special case where we need to modify a offset calculated on start, since the following happened:\n    // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent\n    // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that\n    //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag\n    if(this.cssPosition === \"absolute\" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {\n      po.left += this.scrollParent.scrollLeft();\n      po.top += this.scrollParent.scrollTop();\n    }\n\n    //This needs to be actually done for all browsers, since pageX/pageY includes this information\n    //Ugly IE fix\n    if((this.offsetParent[0] === document.body) ||\n      (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === \"html\" && $.ui.ie)) {\n      po = { top: 0, left: 0 };\n    }\n\n    return {\n      top: po.top + (parseInt(this.offsetParent.css(\"borderTopWidth\"),10) || 0),\n      left: po.left + (parseInt(this.offsetParent.css(\"borderLeftWidth\"),10) || 0)\n    };\n\n  },\n\n  _getRelativeOffset: function() {\n\n    if(this.cssPosition === \"relative\") {\n      var p = this.element.position();\n      return {\n        top: p.top - (parseInt(this.helper.css(\"top\"),10) || 0) + this.scrollParent.scrollTop(),\n        left: p.left - (parseInt(this.helper.css(\"left\"),10) || 0) + this.scrollParent.scrollLeft()\n      };\n    } else {\n      return { top: 0, left: 0 };\n    }\n\n  },\n\n  _cacheMargins: function() {\n    this.margins = {\n      left: (parseInt(this.element.css(\"marginLeft\"),10) || 0),\n      top: (parseInt(this.element.css(\"marginTop\"),10) || 0),\n      right: (parseInt(this.element.css(\"marginRight\"),10) || 0),\n      bottom: (parseInt(this.element.css(\"marginBottom\"),10) || 0)\n    };\n  },\n\n  _cacheHelperProportions: function() {\n    this.helperProportions = {\n      width: this.helper.outerWidth(),\n      height: this.helper.outerHeight()\n    };\n  },\n\n  _setContainment: function() {\n\n    var over, c, ce,\n      o = this.options;\n\n    if(o.containment === \"parent\") {\n      o.containment = this.helper[0].parentNode;\n    }\n    if(o.containment === \"document\" || o.containment === \"window\") {\n      this.containment = [\n        o.containment === \"document\" ? 0 : $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left,\n        o.containment === \"document\" ? 0 : $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top,\n        (o.containment === \"document\" ? 0 : $(window).scrollLeft()) + $(o.containment === \"document\" ? document : window).width() - this.helperProportions.width - this.margins.left,\n        (o.containment === \"document\" ? 0 : $(window).scrollTop()) + ($(o.containment === \"document\" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top\n      ];\n    }\n\n    if(!(/^(document|window|parent)$/).test(o.containment) && o.containment.constructor !== Array) {\n      c = $(o.containment);\n      ce = c[0];\n\n      if(!ce) {\n        return;\n      }\n\n      over = ($(ce).css(\"overflow\") !== \"hidden\");\n\n      this.containment = [\n        (parseInt($(ce).css(\"borderLeftWidth\"),10) || 0) + (parseInt($(ce).css(\"paddingLeft\"),10) || 0),\n        (parseInt($(ce).css(\"borderTopWidth\"),10) || 0) + (parseInt($(ce).css(\"paddingTop\"),10) || 0),\n        (over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css(\"borderLeftWidth\"),10) || 0) - (parseInt($(ce).css(\"paddingRight\"),10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right,\n        (over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css(\"borderTopWidth\"),10) || 0) - (parseInt($(ce).css(\"paddingBottom\"),10) || 0) - this.helperProportions.height - this.margins.top  - this.margins.bottom\n      ];\n      this.relative_container = c;\n\n    } else if(o.containment.constructor === Array) {\n      this.containment = o.containment;\n    }\n\n  },\n\n  _convertPositionTo: function(d, pos) {\n\n    if(!pos) {\n      pos = this.position;\n    }\n\n    var mod = d === \"absolute\" ? 1 : -1,\n      scroll = this.cssPosition === \"absolute\" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);\n\n    return {\n      top: (\n        pos.top  +                                // The absolute mouse position\n        this.offset.relative.top * mod +                    // Only for relative positioned nodes: Relative offset from element to offset parent\n        this.offset.parent.top * mod -                    // The offsetParent's offset without borders (offset + border)\n        ( ( this.cssPosition === \"fixed\" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)\n      ),\n      left: (\n        pos.left +                                // The absolute mouse position\n        this.offset.relative.left * mod +                    // Only for relative positioned nodes: Relative offset from element to offset parent\n        this.offset.parent.left * mod  -                    // The offsetParent's offset without borders (offset + border)\n        ( ( this.cssPosition === \"fixed\" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)\n      )\n    };\n\n  },\n\n  _generatePosition: function(event) {\n\n    var containment, co, top, left,\n      o = this.options,\n      scroll = this.cssPosition === \"absolute\" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,\n      scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName),\n      pageX = event.pageX,\n      pageY = event.pageY;\n\n    /*\n     * - Position constraining -\n     * Constrain the position to a mix of grid, containment.\n     */\n\n    if(this.originalPosition) { //If we are not dragging yet, we won't check for options\n      if(this.containment) {\n      if (this.relative_container){\n        co = this.relative_container.offset();\n        containment = [ this.containment[0] + co.left,\n          this.containment[1] + co.top,\n          this.containment[2] + co.left,\n          this.containment[3] + co.top ];\n      }\n      else {\n        containment = this.containment;\n      }\n\n        if(event.pageX - this.offset.click.left < containment[0]) {\n          pageX = containment[0] + this.offset.click.left;\n        }\n        if(event.pageY - this.offset.click.top < containment[1]) {\n          pageY = containment[1] + this.offset.click.top;\n        }\n        if(event.pageX - this.offset.click.left > containment[2]) {\n          pageX = containment[2] + this.offset.click.left;\n        }\n        if(event.pageY - this.offset.click.top > containment[3]) {\n          pageY = containment[3] + this.offset.click.top;\n        }\n      }\n\n      if(o.grid) {\n        //Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)\n        top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;\n        pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;\n\n        left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;\n        pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;\n      }\n\n    }\n\n    return {\n      top: (\n        pageY -                                  // The absolute mouse position\n        this.offset.click.top  -                        // Click offset (relative to the element)\n        this.offset.relative.top -                        // Only for relative positioned nodes: Relative offset from element to offset parent\n        this.offset.parent.top +                        // The offsetParent's offset without borders (offset + border)\n        ( ( this.cssPosition === \"fixed\" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))\n      ),\n      left: (\n        pageX -                                  // The absolute mouse position\n        this.offset.click.left -                        // Click offset (relative to the element)\n        this.offset.relative.left -                        // Only for relative positioned nodes: Relative offset from element to offset parent\n        this.offset.parent.left +                        // The offsetParent's offset without borders (offset + border)\n        ( ( this.cssPosition === \"fixed\" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))\n      )\n    };\n\n  },\n\n  _clear: function() {\n    this.helper.removeClass(\"ui-draggable-dragging\");\n    if(this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {\n      this.helper.remove();\n    }\n    this.helper = null;\n    this.cancelHelperRemoval = false;\n  },\n\n  // From now on bulk stuff - mainly helpers\n\n  _trigger: function(type, event, ui) {\n    ui = ui || this._uiHash();\n    $.ui.plugin.call(this, type, [event, ui]);\n    //The absolute position has to be recalculated after plugins\n    if(type === \"drag\") {\n      this.positionAbs = this._convertPositionTo(\"absolute\");\n    }\n    return $.Widget.prototype._trigger.call(this, type, event, ui);\n  },\n\n  plugins: {},\n\n  _uiHash: function() {\n    return {\n      helper: this.helper,\n      position: this.position,\n      originalPosition: this.originalPosition,\n      offset: this.positionAbs\n    };\n  }\n\n});\n\n$.ui.plugin.add(\"draggable\", \"connectToSortable\", {\n  start: function(event, ui) {\n\n    var inst = $(this).data(\"ui-draggable\"), o = inst.options,\n      uiSortable = $.extend({}, ui, { item: inst.element });\n    inst.sortables = [];\n    $(o.connectToSortable).each(function() {\n      var sortable = $.data(this, \"ui-sortable\");\n      if (sortable && !sortable.options.disabled) {\n        inst.sortables.push({\n          instance: sortable,\n          shouldRevert: sortable.options.revert\n        });\n        sortable.refreshPositions();  // Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).\n        sortable._trigger(\"activate\", event, uiSortable);\n      }\n    });\n\n  },\n  stop: function(event, ui) {\n\n    //If we are still over the sortable, we fake the stop event of the sortable, but also remove helper\n    var inst = $(this).data(\"ui-draggable\"),\n      uiSortable = $.extend({}, ui, { item: inst.element });\n\n    $.each(inst.sortables, function() {\n      if(this.instance.isOver) {\n\n        this.instance.isOver = 0;\n\n        inst.cancelHelperRemoval = true; //Don't remove the helper in the draggable instance\n        this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)\n\n        //The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: \"valid/invalid\"\n        if(this.shouldRevert) {\n          this.instance.options.revert = true;\n        }\n\n        //Trigger the stop of the sortable\n        this.instance._mouseStop(event);\n\n        this.instance.options.helper = this.instance.options._helper;\n\n        //If the helper has been the original item, restore properties in the sortable\n        if(inst.options.helper === \"original\") {\n          this.instance.currentItem.css({ top: \"auto\", left: \"auto\" });\n        }\n\n      } else {\n        this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance\n        this.instance._trigger(\"deactivate\", event, uiSortable);\n      }\n\n    });\n\n  },\n  drag: function(event, ui) {\n\n    var inst = $(this).data(\"ui-draggable\"), that = this;\n\n    $.each(inst.sortables, function() {\n\n      var innermostIntersecting = false,\n        thisSortable = this;\n\n      //Copy over some variables to allow calling the sortable's native _intersectsWith\n      this.instance.positionAbs = inst.positionAbs;\n      this.instance.helperProportions = inst.helperProportions;\n      this.instance.offset.click = inst.offset.click;\n\n      if(this.instance._intersectsWith(this.instance.containerCache)) {\n        innermostIntersecting = true;\n        $.each(inst.sortables, function () {\n          this.instance.positionAbs = inst.positionAbs;\n          this.instance.helperProportions = inst.helperProportions;\n          this.instance.offset.click = inst.offset.click;\n          if (this !== thisSortable &&\n            this.instance._intersectsWith(this.instance.containerCache) &&\n            $.contains(thisSortable.instance.element[0], this.instance.element[0])\n          ) {\n            innermostIntersecting = false;\n          }\n          return innermostIntersecting;\n        });\n      }\n\n\n      if(innermostIntersecting) {\n        //If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once\n        if(!this.instance.isOver) {\n\n          this.instance.isOver = 1;\n          //Now we fake the start of dragging for the sortable instance,\n          //by cloning the list group item, appending it to the sortable and using it as inst.currentItem\n          //We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)\n          this.instance.currentItem = $(that).clone().removeAttr(\"id\").appendTo(this.instance.element).data(\"ui-sortable-item\", true);\n          this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it\n          this.instance.options.helper = function() { return ui.helper[0]; };\n\n          event.target = this.instance.currentItem[0];\n          this.instance._mouseCapture(event, true);\n          this.instance._mouseStart(event, true, true);\n\n          //Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes\n          this.instance.offset.click.top = inst.offset.click.top;\n          this.instance.offset.click.left = inst.offset.click.left;\n          this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;\n          this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;\n\n          inst._trigger(\"toSortable\", event);\n          inst.dropped = this.instance.element; //draggable revert needs that\n          //hack so receive/update callbacks work (mostly)\n          inst.currentItem = inst.element;\n          this.instance.fromOutside = inst;\n\n        }\n\n        //Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable\n        if(this.instance.currentItem) {\n          this.instance._mouseDrag(event);\n        }\n\n      } else {\n\n        //If it doesn't intersect with the sortable, and it intersected before,\n        //we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval\n        if(this.instance.isOver) {\n\n          this.instance.isOver = 0;\n          this.instance.cancelHelperRemoval = true;\n\n          //Prevent reverting on this forced stop\n          this.instance.options.revert = false;\n\n          // The out event needs to be triggered independently\n          this.instance._trigger(\"out\", event, this.instance._uiHash(this.instance));\n\n          this.instance._mouseStop(event, true);\n          this.instance.options.helper = this.instance.options._helper;\n\n          //Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size\n          this.instance.currentItem.remove();\n          if(this.instance.placeholder) {\n            this.instance.placeholder.remove();\n          }\n\n          inst._trigger(\"fromSortable\", event);\n          inst.dropped = false; //draggable revert needs that\n        }\n\n      }\n\n    });\n\n  }\n});\n\n$.ui.plugin.add(\"draggable\", \"cursor\", {\n  start: function() {\n    var t = $(\"body\"), o = $(this).data(\"ui-draggable\").options;\n    if (t.css(\"cursor\")) {\n      o._cursor = t.css(\"cursor\");\n    }\n    t.css(\"cursor\", o.cursor);\n  },\n  stop: function() {\n    var o = $(this).data(\"ui-draggable\").options;\n    if (o._cursor) {\n      $(\"body\").css(\"cursor\", o._cursor);\n    }\n  }\n});\n\n$.ui.plugin.add(\"draggable\", \"opacity\", {\n  start: function(event, ui) {\n    var t = $(ui.helper), o = $(this).data(\"ui-draggable\").options;\n    if(t.css(\"opacity\")) {\n      o._opacity = t.css(\"opacity\");\n    }\n    t.css(\"opacity\", o.opacity);\n  },\n  stop: function(event, ui) {\n    var o = $(this).data(\"ui-draggable\").options;\n    if(o._opacity) {\n      $(ui.helper).css(\"opacity\", o._opacity);\n    }\n  }\n});\n\n$.ui.plugin.add(\"draggable\", \"scroll\", {\n  start: function() {\n    var i = $(this).data(\"ui-draggable\");\n    if(i.scrollParent[0] !== document && i.scrollParent[0].tagName !== \"HTML\") {\n      i.overflowOffset = i.scrollParent.offset();\n    }\n  },\n  drag: function( event ) {\n\n    var i = $(this).data(\"ui-draggable\"), o = i.options, scrolled = false;\n\n    if(i.scrollParent[0] !== document && i.scrollParent[0].tagName !== \"HTML\") {\n\n      if(!o.axis || o.axis !== \"x\") {\n        if((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {\n          i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;\n        } else if(event.pageY - i.overflowOffset.top < o.scrollSensitivity) {\n          i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;\n        }\n      }\n\n      if(!o.axis || o.axis !== \"y\") {\n        if((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {\n          i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;\n        } else if(event.pageX - i.overflowOffset.left < o.scrollSensitivity) {\n          i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;\n        }\n      }\n\n    } else {\n\n      if(!o.axis || o.axis !== \"x\") {\n        if(event.pageY - $(document).scrollTop() < o.scrollSensitivity) {\n          scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);\n        } else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {\n          scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);\n        }\n      }\n\n      if(!o.axis || o.axis !== \"y\") {\n        if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {\n          scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);\n        } else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {\n          scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);\n        }\n      }\n\n    }\n\n    if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {\n      $.ui.ddmanager.prepareOffsets(i, event);\n    }\n\n  }\n});\n\n$.ui.plugin.add(\"draggable\", \"snap\", {\n  start: function() {\n\n    var i = $(this).data(\"ui-draggable\"),\n      o = i.options;\n\n    i.snapElements = [];\n\n    $(o.snap.constructor !== String ? ( o.snap.items || \":data(ui-draggable)\" ) : o.snap).each(function() {\n      var $t = $(this),\n        $o = $t.offset();\n      if(this !== i.element[0]) {\n        i.snapElements.push({\n          item: this,\n          width: $t.outerWidth(), height: $t.outerHeight(),\n          top: $o.top, left: $o.left\n        });\n      }\n    });\n\n  },\n  drag: function(event, ui) {\n\n    var ts, bs, ls, rs, l, r, t, b, i, first,\n      inst = $(this).data(\"ui-draggable\"),\n      o = inst.options,\n      d = o.snapTolerance,\n      x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,\n      y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;\n\n    for (i = inst.snapElements.length - 1; i >= 0; i--){\n\n      l = inst.snapElements[i].left;\n      r = l + inst.snapElements[i].width;\n      t = inst.snapElements[i].top;\n      b = t + inst.snapElements[i].height;\n\n      //Yes, I know, this is insane ;)\n      if(!((l-d < x1 && x1 < r+d && t-d < y1 && y1 < b+d) || (l-d < x1 && x1 < r+d && t-d < y2 && y2 < b+d) || (l-d < x2 && x2 < r+d && t-d < y1 && y1 < b+d) || (l-d < x2 && x2 < r+d && t-d < y2 && y2 < b+d))) {\n        if(inst.snapElements[i].snapping) {\n          (inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));\n        }\n        inst.snapElements[i].snapping = false;\n        continue;\n      }\n\n      if(o.snapMode !== \"inner\") {\n        ts = Math.abs(t - y2) <= d;\n        bs = Math.abs(b - y1) <= d;\n        ls = Math.abs(l - x2) <= d;\n        rs = Math.abs(r - x1) <= d;\n        if(ts) {\n          ui.position.top = inst._convertPositionTo(\"relative\", { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;\n        }\n        if(bs) {\n          ui.position.top = inst._convertPositionTo(\"relative\", { top: b, left: 0 }).top - inst.margins.top;\n        }\n        if(ls) {\n          ui.position.left = inst._convertPositionTo(\"relative\", { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;\n        }\n        if(rs) {\n          ui.position.left = inst._convertPositionTo(\"relative\", { top: 0, left: r }).left - inst.margins.left;\n        }\n      }\n\n      first = (ts || bs || ls || rs);\n\n      if(o.snapMode !== \"outer\") {\n        ts = Math.abs(t - y1) <= d;\n        bs = Math.abs(b - y2) <= d;\n        ls = Math.abs(l - x1) <= d;\n        rs = Math.abs(r - x2) <= d;\n        if(ts) {\n          ui.position.top = inst._convertPositionTo(\"relative\", { top: t, left: 0 }).top - inst.margins.top;\n        }\n        if(bs) {\n          ui.position.top = inst._convertPositionTo(\"relative\", { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;\n        }\n        if(ls) {\n          ui.position.left = inst._convertPositionTo(\"relative\", { top: 0, left: l }).left - inst.margins.left;\n        }\n        if(rs) {\n          ui.position.left = inst._convertPositionTo(\"relative\", { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;\n        }\n      }\n\n      if(!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {\n        (inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));\n      }\n      inst.snapElements[i].snapping = (ts || bs || ls || rs || first);\n\n    }\n\n  }\n});\n\n$.ui.plugin.add(\"draggable\", \"stack\", {\n  start: function() {\n    var min,\n      o = this.data(\"ui-draggable\").options,\n      group = $.makeArray($(o.stack)).sort(function(a,b) {\n        return (parseInt($(a).css(\"zIndex\"),10) || 0) - (parseInt($(b).css(\"zIndex\"),10) || 0);\n      });\n\n    if (!group.length) { return; }\n\n    min = parseInt($(group[0]).css(\"zIndex\"), 10) || 0;\n    $(group).each(function(i) {\n      $(this).css(\"zIndex\", min + i);\n    });\n    this.css(\"zIndex\", (min + group.length));\n  }\n});\n\n$.ui.plugin.add(\"draggable\", \"zIndex\", {\n  start: function(event, ui) {\n    var t = $(ui.helper), o = $(this).data(\"ui-draggable\").options;\n    if(t.css(\"zIndex\")) {\n      o._zIndex = t.css(\"zIndex\");\n    }\n    t.css(\"zIndex\", o.zIndex);\n  },\n  stop: function(event, ui) {\n    var o = $(this).data(\"ui-draggable\").options;\n    if(o._zIndex) {\n      $(ui.helper).css(\"zIndex\", o._zIndex);\n    }\n  }\n});\n\n})(jQuery);\n(function( $, undefined ) {\n\nfunction isOverAxis( x, reference, size ) {\n  return ( x > reference ) && ( x < ( reference + size ) );\n}\n\n$.widget(\"ui.droppable\", {\n  version: \"1.10.1\",\n  widgetEventPrefix: \"drop\",\n  options: {\n    accept: \"*\",\n    activeClass: false,\n    addClasses: true,\n    greedy: false,\n    hoverClass: false,\n    scope: \"default\",\n    tolerance: \"intersect\",\n\n    // callbacks\n    activate: null,\n    deactivate: null,\n    drop: null,\n    out: null,\n    over: null\n  },\n  _create: function() {\n\n    var o = this.options,\n      accept = o.accept;\n\n    this.isover = false;\n    this.isout = true;\n\n    this.accept = $.isFunction(accept) ? accept : function(d) {\n      return d.is(accept);\n    };\n\n    //Store the droppable's proportions\n    this.proportions = { width: this.element[0].offsetWidth, height: this.element[0].offsetHeight };\n\n    // Add the reference and positions to the manager\n    $.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];\n    $.ui.ddmanager.droppables[o.scope].push(this);\n\n    (o.addClasses && this.element.addClass(\"ui-droppable\"));\n\n  },\n\n  _destroy: function() {\n    var i = 0,\n      drop = $.ui.ddmanager.droppables[this.options.scope];\n\n    for ( ; i < drop.length; i++ ) {\n      if ( drop[i] === this ) {\n        drop.splice(i, 1);\n      }\n    }\n\n    this.element.removeClass(\"ui-droppable ui-droppable-disabled\");\n  },\n\n  _setOption: function(key, value) {\n\n    if(key === \"accept\") {\n      this.accept = $.isFunction(value) ? value : function(d) {\n        return d.is(value);\n      };\n    }\n    $.Widget.prototype._setOption.apply(this, arguments);\n  },\n\n  _activate: function(event) {\n    var draggable = $.ui.ddmanager.current;\n    if(this.options.activeClass) {\n      this.element.addClass(this.options.activeClass);\n    }\n    if(draggable){\n      this._trigger(\"activate\", event, this.ui(draggable));\n    }\n  },\n\n  _deactivate: function(event) {\n    var draggable = $.ui.ddmanager.current;\n    if(this.options.activeClass) {\n      this.element.removeClass(this.options.activeClass);\n    }\n    if(draggable){\n      this._trigger(\"deactivate\", event, this.ui(draggable));\n    }\n  },\n\n  _over: function(event) {\n\n    var draggable = $.ui.ddmanager.current;\n\n    // Bail if draggable and droppable are same element\n    if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {\n      return;\n    }\n\n    if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {\n      if(this.options.hoverClass) {\n        this.element.addClass(this.options.hoverClass);\n      }\n      this._trigger(\"over\", event, this.ui(draggable));\n    }\n\n  },\n\n  _out: function(event) {\n\n    var draggable = $.ui.ddmanager.current;\n\n    // Bail if draggable and droppable are same element\n    if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {\n      return;\n    }\n\n    if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {\n      if(this.options.hoverClass) {\n        this.element.removeClass(this.options.hoverClass);\n      }\n      this._trigger(\"out\", event, this.ui(draggable));\n    }\n\n  },\n\n  _drop: function(event,custom) {\n\n    var draggable = custom || $.ui.ddmanager.current,\n      childrenIntersection = false;\n\n    // Bail if draggable and droppable are same element\n    if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {\n      return false;\n    }\n\n    this.element.find(\":data(ui-droppable)\").not(\".ui-draggable-dragging\").each(function() {\n      var inst = $.data(this, \"ui-droppable\");\n      if(\n        inst.options.greedy &&\n        !inst.options.disabled &&\n        inst.options.scope === draggable.options.scope &&\n        inst.accept.call(inst.element[0], (draggable.currentItem || draggable.element)) &&\n        $.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance)\n      ) { childrenIntersection = true; return false; }\n    });\n    if(childrenIntersection) {\n      return false;\n    }\n\n    if(this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {\n      if(this.options.activeClass) {\n        this.element.removeClass(this.options.activeClass);\n      }\n      if(this.options.hoverClass) {\n        this.element.removeClass(this.options.hoverClass);\n      }\n      this._trigger(\"drop\", event, this.ui(draggable));\n      return this.element;\n    }\n\n    return false;\n\n  },\n\n  ui: function(c) {\n    return {\n      draggable: (c.currentItem || c.element),\n      helper: c.helper,\n      position: c.position,\n      offset: c.positionAbs\n    };\n  }\n\n});\n\n$.ui.intersect = function(draggable, droppable, toleranceMode) {\n\n  if (!droppable.offset) {\n    return false;\n  }\n\n  var draggableLeft, draggableTop,\n    x1 = (draggable.positionAbs || draggable.position.absolute).left, x2 = x1 + draggable.helperProportions.width,\n    y1 = (draggable.positionAbs || draggable.position.absolute).top, y2 = y1 + draggable.helperProportions.height,\n    l = droppable.offset.left, r = l + droppable.proportions.width,\n    t = droppable.offset.top, b = t + droppable.proportions.height;\n\n  switch (toleranceMode) {\n    case \"fit\":\n      return (l <= x1 && x2 <= r && t <= y1 && y2 <= b);\n    case \"intersect\":\n      return (l < x1 + (draggable.helperProportions.width / 2) && // Right Half\n        x2 - (draggable.helperProportions.width / 2) < r && // Left Half\n        t < y1 + (draggable.helperProportions.height / 2) && // Bottom Half\n        y2 - (draggable.helperProportions.height / 2) < b ); // Top Half\n    case \"pointer\":\n      draggableLeft = ((draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left);\n      draggableTop = ((draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top);\n      return isOverAxis( draggableTop, t, droppable.proportions.height ) && isOverAxis( draggableLeft, l, droppable.proportions.width );\n    case \"touch\":\n      return (\n        (y1 >= t && y1 <= b) ||  // Top edge touching\n        (y2 >= t && y2 <= b) ||  // Bottom edge touching\n        (y1 < t && y2 > b)    // Surrounded vertically\n      ) && (\n        (x1 >= l && x1 <= r) ||  // Left edge touching\n        (x2 >= l && x2 <= r) ||  // Right edge touching\n        (x1 < l && x2 > r)    // Surrounded horizontally\n      );\n    default:\n      return false;\n    }\n\n};\n\n/*\n  This manager tracks offsets of draggables and droppables\n*/\n$.ui.ddmanager = {\n  current: null,\n  droppables: { \"default\": [] },\n  prepareOffsets: function(t, event) {\n\n    var i, j,\n      m = $.ui.ddmanager.droppables[t.options.scope] || [],\n      type = event ? event.type : null, // workaround for #2317\n      list = (t.currentItem || t.element).find(\":data(ui-droppable)\").addBack();\n\n    droppablesLoop: for (i = 0; i < m.length; i++) {\n\n      //No disabled and non-accepted\n      if(m[i].options.disabled || (t && !m[i].accept.call(m[i].element[0],(t.currentItem || t.element)))) {\n        continue;\n      }\n\n      // Filter out elements in the current dragged item\n      for (j=0; j < list.length; j++) {\n        if(list[j] === m[i].element[0]) {\n          m[i].proportions.height = 0;\n          continue droppablesLoop;\n        }\n      }\n\n      m[i].visible = m[i].element.css(\"display\") !== \"none\";\n      if(!m[i].visible) {\n        continue;\n      }\n\n      //Activate the droppable if used directly from draggables\n      if(type === \"mousedown\") {\n        m[i]._activate.call(m[i], event);\n      }\n\n      m[i].offset = m[i].element.offset();\n      m[i].proportions = { width: m[i].element[0].offsetWidth, height: m[i].element[0].offsetHeight };\n\n    }\n\n  },\n  drop: function(draggable, event) {\n\n    var dropped = false;\n    $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {\n\n      if(!this.options) {\n        return;\n      }\n      if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance)) {\n        dropped = this._drop.call(this, event) || dropped;\n      }\n\n      if (!this.options.disabled && this.visible && this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {\n        this.isout = true;\n        this.isover = false;\n        this._deactivate.call(this, event);\n      }\n\n    });\n    return dropped;\n\n  },\n  dragStart: function( draggable, event ) {\n    //Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)\n    draggable.element.parentsUntil( \"body\" ).bind( \"scroll.droppable\", function() {\n      if( !draggable.options.refreshPositions ) {\n        $.ui.ddmanager.prepareOffsets( draggable, event );\n      }\n    });\n  },\n  drag: function(draggable, event) {\n\n    //If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.\n    if(draggable.options.refreshPositions) {\n      $.ui.ddmanager.prepareOffsets(draggable, event);\n    }\n\n    //Run through all droppables and check their positions based on specific tolerance options\n    $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {\n\n      if(this.options.disabled || this.greedyChild || !this.visible) {\n        return;\n      }\n\n      var parentInstance, scope, parent,\n        intersects = $.ui.intersect(draggable, this, this.options.tolerance),\n        c = !intersects && this.isover ? \"isout\" : (intersects && !this.isover ? \"isover\" : null);\n      if(!c) {\n        return;\n      }\n\n      if (this.options.greedy) {\n        // find droppable parents with same scope\n        scope = this.options.scope;\n        parent = this.element.parents(\":data(ui-droppable)\").filter(function () {\n          return $.data(this, \"ui-droppable\").options.scope === scope;\n        });\n\n        if (parent.length) {\n          parentInstance = $.data(parent[0], \"ui-droppable\");\n          parentInstance.greedyChild = (c === \"isover\");\n        }\n      }\n\n      // we just moved into a greedy child\n      if (parentInstance && c === \"isover\") {\n        parentInstance.isover = false;\n        parentInstance.isout = true;\n        parentInstance._out.call(parentInstance, event);\n      }\n\n      this[c] = true;\n      this[c === \"isout\" ? \"isover\" : \"isout\"] = false;\n      this[c === \"isover\" ? \"_over\" : \"_out\"].call(this, event);\n\n      // we just moved out of a greedy child\n      if (parentInstance && c === \"isout\") {\n        parentInstance.isout = false;\n        parentInstance.isover = true;\n        parentInstance._over.call(parentInstance, event);\n      }\n    });\n\n  },\n  dragStop: function( draggable, event ) {\n    draggable.element.parentsUntil( \"body\" ).unbind( \"scroll.droppable\" );\n    //Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)\n    if( !draggable.options.refreshPositions ) {\n      $.ui.ddmanager.prepareOffsets( draggable, event );\n    }\n  }\n};\n\n})(jQuery);\n(function( $, undefined ) {\n\n/*jshint loopfunc: true */\n\nfunction isOverAxis( x, reference, size ) {\n  return ( x > reference ) && ( x < ( reference + size ) );\n}\n\n$.widget(\"ui.sortable\", $.ui.mouse, {\n  version: \"1.10.1\",\n  widgetEventPrefix: \"sort\",\n  ready: false,\n  options: {\n    appendTo: \"parent\",\n    axis: false,\n    connectWith: false,\n    containment: false,\n    cursor: \"auto\",\n    cursorAt: false,\n    dropOnEmpty: true,\n    forcePlaceholderSize: false,\n    forceHelperSize: false,\n    grid: false,\n    handle: false,\n    helper: \"original\",\n    items: \"> *\",\n    opacity: false,\n    placeholder: false,\n    revert: false,\n    scroll: true,\n    scrollSensitivity: 20,\n    scrollSpeed: 20,\n    scope: \"default\",\n    tolerance: \"intersect\",\n    zIndex: 1000,\n\n    // callbacks\n    activate: null,\n    beforeStop: null,\n    change: null,\n    deactivate: null,\n    out: null,\n    over: null,\n    receive: null,\n    remove: null,\n    sort: null,\n    start: null,\n    stop: null,\n    update: null\n  },\n  _create: function() {\n\n    var o = this.options;\n    this.containerCache = {};\n    this.element.addClass(\"ui-sortable\");\n\n    //Get the items\n    this.refresh();\n\n    //Let's determine if the items are being displayed horizontally\n    this.floating = this.items.length ? o.axis === \"x\" || (/left|right/).test(this.items[0].item.css(\"float\")) || (/inline|table-cell/).test(this.items[0].item.css(\"display\")) : false;\n\n    //Let's determine the parent's offset\n    this.offset = this.element.offset();\n\n    //Initialize mouse events for interaction\n    this._mouseInit();\n\n    //We're ready to go\n    this.ready = true;\n\n  },\n\n  _destroy: function() {\n    this.element\n      .removeClass(\"ui-sortable ui-sortable-disabled\");\n    this._mouseDestroy();\n\n    for ( var i = this.items.length - 1; i >= 0; i-- ) {\n      this.items[i].item.removeData(this.widgetName + \"-item\");\n    }\n\n    return this;\n  },\n\n  _setOption: function(key, value){\n    if ( key === \"disabled\" ) {\n      this.options[ key ] = value;\n\n      this.widget().toggleClass( \"ui-sortable-disabled\", !!value );\n    } else {\n      // Don't call widget base _setOption for disable as it adds ui-state-disabled class\n      $.Widget.prototype._setOption.apply(this, arguments);\n    }\n  },\n\n  _mouseCapture: function(event, overrideHandle) {\n    var currentItem = null,\n      validHandle = false,\n      that = this;\n\n    if (this.reverting) {\n      return false;\n    }\n\n    if(this.options.disabled || this.options.type === \"static\") {\n      return false;\n    }\n\n    //We have to refresh the items data once first\n    this._refreshItems(event);\n\n    //Find out if the clicked node (or one of its parents) is a actual item in this.items\n    $(event.target).parents().each(function() {\n      if($.data(this, that.widgetName + \"-item\") === that) {\n        currentItem = $(this);\n        return false;\n      }\n    });\n    if($.data(event.target, that.widgetName + \"-item\") === that) {\n      currentItem = $(event.target);\n    }\n\n    if(!currentItem) {\n      return false;\n    }\n    if(this.options.handle && !overrideHandle) {\n      $(this.options.handle, currentItem).find(\"*\").addBack().each(function() {\n        if(this === event.target) {\n          validHandle = true;\n        }\n      });\n      if(!validHandle) {\n        return false;\n      }\n    }\n\n    this.currentItem = currentItem;\n    this._removeCurrentsFromItems();\n    return true;\n\n  },\n\n  _mouseStart: function(event, overrideHandle, noActivation) {\n\n    var i,\n      o = this.options;\n\n    this.currentContainer = this;\n\n    //We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture\n    this.refreshPositions();\n\n    //Create and append the visible helper\n    this.helper = this._createHelper(event);\n\n    //Cache the helper size\n    this._cacheHelperProportions();\n\n    /*\n     * - Position generation -\n     * This block generates everything position related - it's the core of draggables.\n     */\n\n    //Cache the margins of the original element\n    this._cacheMargins();\n\n    //Get the next scrolling parent\n    this.scrollParent = this.helper.scrollParent();\n\n    //The element's absolute position on the page minus margins\n    this.offset = this.currentItem.offset();\n    this.offset = {\n      top: this.offset.top - this.margins.top,\n      left: this.offset.left - this.margins.left\n    };\n\n    $.extend(this.offset, {\n      click: { //Where the click happened, relative to the element\n        left: event.pageX - this.offset.left,\n        top: event.pageY - this.offset.top\n      },\n      parent: this._getParentOffset(),\n      relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper\n    });\n\n    // Only after we got the offset, we can change the helper's position to absolute\n    // TODO: Still need to figure out a way to make relative sorting possible\n    this.helper.css(\"position\", \"absolute\");\n    this.cssPosition = this.helper.css(\"position\");\n\n    //Generate the original position\n    this.originalPosition = this._generatePosition(event);\n    this.originalPageX = event.pageX;\n    this.originalPageY = event.pageY;\n\n    //Adjust the mouse offset relative to the helper if \"cursorAt\" is supplied\n    (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));\n\n    //Cache the former DOM position\n    this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };\n\n    //If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way\n    if(this.helper[0] !== this.currentItem[0]) {\n      this.currentItem.hide();\n    }\n\n    //Create the placeholder\n    this._createPlaceholder();\n\n    //Set a containment if given in the options\n    if(o.containment) {\n      this._setContainment();\n    }\n\n    if(o.cursor) { // cursor option\n      if ($(\"body\").css(\"cursor\")) {\n        this._storedCursor = $(\"body\").css(\"cursor\");\n      }\n      $(\"body\").css(\"cursor\", o.cursor);\n    }\n\n    if(o.opacity) { // opacity option\n      if (this.helper.css(\"opacity\")) {\n        this._storedOpacity = this.helper.css(\"opacity\");\n      }\n      this.helper.css(\"opacity\", o.opacity);\n    }\n\n    if(o.zIndex) { // zIndex option\n      if (this.helper.css(\"zIndex\")) {\n        this._storedZIndex = this.helper.css(\"zIndex\");\n      }\n      this.helper.css(\"zIndex\", o.zIndex);\n    }\n\n    //Prepare scrolling\n    if(this.scrollParent[0] !== document && this.scrollParent[0].tagName !== \"HTML\") {\n      this.overflowOffset = this.scrollParent.offset();\n    }\n\n    //Call callbacks\n    this._trigger(\"start\", event, this._uiHash());\n\n    //Recache the helper size\n    if(!this._preserveHelperProportions) {\n      this._cacheHelperProportions();\n    }\n\n\n    //Post \"activate\" events to possible containers\n    if( !noActivation ) {\n      for ( i = this.containers.length - 1; i >= 0; i-- ) {\n        this.containers[ i ]._trigger( \"activate\", event, this._uiHash( this ) );\n      }\n    }\n\n    //Prepare possible droppables\n    if($.ui.ddmanager) {\n      $.ui.ddmanager.current = this;\n    }\n\n    if ($.ui.ddmanager && !o.dropBehaviour) {\n      $.ui.ddmanager.prepareOffsets(this, event);\n    }\n\n    this.dragging = true;\n\n    this.helper.addClass(\"ui-sortable-helper\");\n    this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position\n    return true;\n\n  },\n\n  _mouseDrag: function(event) {\n    var i, item, itemElement, intersection,\n      o = this.options,\n      scrolled = false;\n\n    //Compute the helpers position\n    this.position = this._generatePosition(event);\n    this.positionAbs = this._convertPositionTo(\"absolute\");\n\n    if (!this.lastPositionAbs) {\n      this.lastPositionAbs = this.positionAbs;\n    }\n\n    //Do scrolling\n    if(this.options.scroll) {\n      if(this.scrollParent[0] !== document && this.scrollParent[0].tagName !== \"HTML\") {\n\n        if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {\n          this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;\n        } else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity) {\n          this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;\n        }\n\n        if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {\n          this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;\n        } else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity) {\n          this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;\n        }\n\n      } else {\n\n        if(event.pageY - $(document).scrollTop() < o.scrollSensitivity) {\n          scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);\n        } else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {\n          scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);\n        }\n\n        if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {\n          scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);\n        } else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {\n          scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);\n        }\n\n      }\n\n      if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {\n        $.ui.ddmanager.prepareOffsets(this, event);\n      }\n    }\n\n    //Regenerate the absolute position used for position checks\n    this.positionAbs = this._convertPositionTo(\"absolute\");\n\n    //Set the helper position\n    if(!this.options.axis || this.options.axis !== \"y\") {\n      this.helper[0].style.left = this.position.left+\"px\";\n    }\n    if(!this.options.axis || this.options.axis !== \"x\") {\n      this.helper[0].style.top = this.position.top+\"px\";\n    }\n\n    //Rearrange\n    for (i = this.items.length - 1; i >= 0; i--) {\n\n      //Cache variables and intersection, continue if no intersection\n      item = this.items[i];\n      itemElement = item.item[0];\n      intersection = this._intersectsWithPointer(item);\n      if (!intersection) {\n        continue;\n      }\n\n      // Only put the placeholder inside the current Container, skip all\n      // items form other containers. This works because when moving\n      // an item from one container to another the\n      // currentContainer is switched before the placeholder is moved.\n      //\n      // Without this moving items in \"sub-sortables\" can cause the placeholder to jitter\n      // beetween the outer and inner container.\n      if (item.instance !== this.currentContainer) {\n        continue;\n      }\n\n      // cannot intersect with itself\n      // no useless actions that have been done before\n      // no action if the item moved is the parent of the item checked\n      if (itemElement !== this.currentItem[0] &&\n        this.placeholder[intersection === 1 ? \"next\" : \"prev\"]()[0] !== itemElement &&\n        !$.contains(this.placeholder[0], itemElement) &&\n        (this.options.type === \"semi-dynamic\" ? !$.contains(this.element[0], itemElement) : true)\n      ) {\n\n        this.direction = intersection === 1 ? \"down\" : \"up\";\n\n        if (this.options.tolerance === \"pointer\" || this._intersectsWithSides(item)) {\n          this._rearrange(event, item);\n        } else {\n          break;\n        }\n\n        this._trigger(\"change\", event, this._uiHash());\n        break;\n      }\n    }\n\n    //Post events to containers\n    this._contactContainers(event);\n\n    //Interconnect with droppables\n    if($.ui.ddmanager) {\n      $.ui.ddmanager.drag(this, event);\n    }\n\n    //Call callbacks\n    this._trigger(\"sort\", event, this._uiHash());\n\n    this.lastPositionAbs = this.positionAbs;\n    return false;\n\n  },\n\n  _mouseStop: function(event, noPropagation) {\n\n    if(!event) {\n      return;\n    }\n\n    //If we are using droppables, inform the manager about the drop\n    if ($.ui.ddmanager && !this.options.dropBehaviour) {\n      $.ui.ddmanager.drop(this, event);\n    }\n\n    if(this.options.revert) {\n      var that = this,\n        cur = this.placeholder.offset();\n\n      this.reverting = true;\n\n      $(this.helper).animate({\n        left: cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollLeft),\n        top: cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollTop)\n      }, parseInt(this.options.revert, 10) || 500, function() {\n        that._clear(event);\n      });\n    } else {\n      this._clear(event, noPropagation);\n    }\n\n    return false;\n\n  },\n\n  cancel: function() {\n\n    if(this.dragging) {\n\n      this._mouseUp({ target: null });\n\n      if(this.options.helper === \"original\") {\n        this.currentItem.css(this._storedCSS).removeClass(\"ui-sortable-helper\");\n      } else {\n        this.currentItem.show();\n      }\n\n      //Post deactivating events to containers\n      for (var i = this.containers.length - 1; i >= 0; i--){\n        this.containers[i]._trigger(\"deactivate\", null, this._uiHash(this));\n        if(this.containers[i].containerCache.over) {\n          this.containers[i]._trigger(\"out\", null, this._uiHash(this));\n          this.containers[i].containerCache.over = 0;\n        }\n      }\n\n    }\n\n    if (this.placeholder) {\n      //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!\n      if(this.placeholder[0].parentNode) {\n        this.placeholder[0].parentNode.removeChild(this.placeholder[0]);\n      }\n      if(this.options.helper !== \"original\" && this.helper && this.helper[0].parentNode) {\n        this.helper.remove();\n      }\n\n      $.extend(this, {\n        helper: null,\n        dragging: false,\n        reverting: false,\n        _noFinalSort: null\n      });\n\n      if(this.domPosition.prev) {\n        $(this.domPosition.prev).after(this.currentItem);\n      } else {\n        $(this.domPosition.parent).prepend(this.currentItem);\n      }\n    }\n\n    return this;\n\n  },\n\n  serialize: function(o) {\n\n    var items = this._getItemsAsjQuery(o && o.connected),\n      str = [];\n    o = o || {};\n\n    $(items).each(function() {\n      var res = ($(o.item || this).attr(o.attribute || \"id\") || \"\").match(o.expression || (/(.+)[\\-=_](.+)/));\n      if (res) {\n        str.push((o.key || res[1]+\"[]\")+\"=\"+(o.key && o.expression ? res[1] : res[2]));\n      }\n    });\n\n    if(!str.length && o.key) {\n      str.push(o.key + \"=\");\n    }\n\n    return str.join(\"&\");\n\n  },\n\n  toArray: function(o) {\n\n    var items = this._getItemsAsjQuery(o && o.connected),\n      ret = [];\n\n    o = o || {};\n\n    items.each(function() { ret.push($(o.item || this).attr(o.attribute || \"id\") || \"\"); });\n    return ret;\n\n  },\n\n  /* Be careful with the following core functions */\n  _intersectsWith: function(item) {\n\n    var x1 = this.positionAbs.left,\n      x2 = x1 + this.helperProportions.width,\n      y1 = this.positionAbs.top,\n      y2 = y1 + this.helperProportions.height,\n      l = item.left,\n      r = l + item.width,\n      t = item.top,\n      b = t + item.height,\n      dyClick = this.offset.click.top,\n      dxClick = this.offset.click.left,\n      isOverElement = (y1 + dyClick) > t && (y1 + dyClick) < b && (x1 + dxClick) > l && (x1 + dxClick) < r;\n\n    if ( this.options.tolerance === \"pointer\" ||\n      this.options.forcePointerForContainers ||\n      (this.options.tolerance !== \"pointer\" && this.helperProportions[this.floating ? \"width\" : \"height\"] > item[this.floating ? \"width\" : \"height\"])\n    ) {\n      return isOverElement;\n    } else {\n\n      return (l < x1 + (this.helperProportions.width / 2) && // Right Half\n        x2 - (this.helperProportions.width / 2) < r && // Left Half\n        t < y1 + (this.helperProportions.height / 2) && // Bottom Half\n        y2 - (this.helperProportions.height / 2) < b ); // Top Half\n\n    }\n  },\n\n  _intersectsWithPointer: function(item) {\n\n    var isOverElementHeight = (this.options.axis === \"x\") || isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),\n      isOverElementWidth = (this.options.axis === \"y\") || isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),\n      isOverElement = isOverElementHeight && isOverElementWidth,\n      verticalDirection = this._getDragVerticalDirection(),\n      horizontalDirection = this._getDragHorizontalDirection();\n\n    if (!isOverElement) {\n      return false;\n    }\n\n    return this.floating ?\n      ( ((horizontalDirection && horizontalDirection === \"right\") || verticalDirection === \"down\") ? 2 : 1 )\n      : ( verticalDirection && (verticalDirection === \"down\" ? 2 : 1) );\n\n  },\n\n  _intersectsWithSides: function(item) {\n\n    var isOverBottomHalf = isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),\n      isOverRightHalf = isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),\n      verticalDirection = this._getDragVerticalDirection(),\n      horizontalDirection = this._getDragHorizontalDirection();\n\n    if (this.floating && horizontalDirection) {\n      return ((horizontalDirection === \"right\" && isOverRightHalf) || (horizontalDirection === \"left\" && !isOverRightHalf));\n    } else {\n      return verticalDirection && ((verticalDirection === \"down\" && isOverBottomHalf) || (verticalDirection === \"up\" && !isOverBottomHalf));\n    }\n\n  },\n\n  _getDragVerticalDirection: function() {\n    var delta = this.positionAbs.top - this.lastPositionAbs.top;\n    return delta !== 0 && (delta > 0 ? \"down\" : \"up\");\n  },\n\n  _getDragHorizontalDirection: function() {\n    var delta = this.positionAbs.left - this.lastPositionAbs.left;\n    return delta !== 0 && (delta > 0 ? \"right\" : \"left\");\n  },\n\n  refresh: function(event) {\n    this._refreshItems(event);\n    this.refreshPositions();\n    return this;\n  },\n\n  _connectWith: function() {\n    var options = this.options;\n    return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;\n  },\n\n  _getItemsAsjQuery: function(connected) {\n\n    var i, j, cur, inst,\n      items = [],\n      queries = [],\n      connectWith = this._connectWith();\n\n    if(connectWith && connected) {\n      for (i = connectWith.length - 1; i >= 0; i--){\n        cur = $(connectWith[i]);\n        for ( j = cur.length - 1; j >= 0; j--){\n          inst = $.data(cur[j], this.widgetFullName);\n          if(inst && inst !== this && !inst.options.disabled) {\n            queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(\".ui-sortable-helper\").not(\".ui-sortable-placeholder\"), inst]);\n          }\n        }\n      }\n    }\n\n    queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(\".ui-sortable-helper\").not(\".ui-sortable-placeholder\"), this]);\n\n    for (i = queries.length - 1; i >= 0; i--){\n      queries[i][0].each(function() {\n        items.push(this);\n      });\n    }\n\n    return $(items);\n\n  },\n\n  _removeCurrentsFromItems: function() {\n\n    var list = this.currentItem.find(\":data(\" + this.widgetName + \"-item)\");\n\n    this.items = $.grep(this.items, function (item) {\n      for (var j=0; j < list.length; j++) {\n        if(list[j] === item.item[0]) {\n          return false;\n        }\n      }\n      return true;\n    });\n\n  },\n\n  _refreshItems: function(event) {\n\n    this.items = [];\n    this.containers = [this];\n\n    var i, j, cur, inst, targetData, _queries, item, queriesLength,\n      items = this.items,\n      queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]],\n      connectWith = this._connectWith();\n\n    if(connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down\n      for (i = connectWith.length - 1; i >= 0; i--){\n        cur = $(connectWith[i]);\n        for (j = cur.length - 1; j >= 0; j--){\n          inst = $.data(cur[j], this.widgetFullName);\n          if(inst && inst !== this && !inst.options.disabled) {\n            queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);\n            this.containers.push(inst);\n          }\n        }\n      }\n    }\n\n    for (i = queries.length - 1; i >= 0; i--) {\n      targetData = queries[i][1];\n      _queries = queries[i][0];\n\n      for (j=0, queriesLength = _queries.length; j < queriesLength; j++) {\n        item = $(_queries[j]);\n\n        item.data(this.widgetName + \"-item\", targetData); // Data for target checking (mouse manager)\n\n        items.push({\n          item: item,\n          instance: targetData,\n          width: 0, height: 0,\n          left: 0, top: 0\n        });\n      }\n    }\n\n  },\n\n  refreshPositions: function(fast) {\n\n    //This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change\n    if(this.offsetParent && this.helper) {\n      this.offset.parent = this._getParentOffset();\n    }\n\n    var i, item, t, p;\n\n    for (i = this.items.length - 1; i >= 0; i--){\n      item = this.items[i];\n\n      //We ignore calculating positions of all connected containers when we're not over them\n      if(item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {\n        continue;\n      }\n\n      t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;\n\n      if (!fast) {\n        item.width = t.outerWidth();\n        item.height = t.outerHeight();\n      }\n\n      p = t.offset();\n      item.left = p.left;\n      item.top = p.top;\n    }\n\n    if(this.options.custom && this.options.custom.refreshContainers) {\n      this.options.custom.refreshContainers.call(this);\n    } else {\n      for (i = this.containers.length - 1; i >= 0; i--){\n        p = this.containers[i].element.offset();\n        this.containers[i].containerCache.left = p.left;\n        this.containers[i].containerCache.top = p.top;\n        this.containers[i].containerCache.width  = this.containers[i].element.outerWidth();\n        this.containers[i].containerCache.height = this.containers[i].element.outerHeight();\n      }\n    }\n\n    return this;\n  },\n\n  _createPlaceholder: function(that) {\n    that = that || this;\n    var className,\n      o = that.options;\n\n    if(!o.placeholder || o.placeholder.constructor === String) {\n      className = o.placeholder;\n      o.placeholder = {\n        element: function() {\n\n          var el = $(document.createElement(that.currentItem[0].nodeName))\n            .addClass(className || that.currentItem[0].className+\" ui-sortable-placeholder\")\n            .removeClass(\"ui-sortable-helper\")[0];\n\n          if(!className) {\n            el.style.visibility = \"hidden\";\n          }\n\n          return el;\n        },\n        update: function(container, p) {\n\n          // 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that\n          // 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified\n          if(className && !o.forcePlaceholderSize) {\n            return;\n          }\n\n          //If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item\n          if(!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css(\"paddingTop\")||0, 10) - parseInt(that.currentItem.css(\"paddingBottom\")||0, 10)); }\n          if(!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css(\"paddingLeft\")||0, 10) - parseInt(that.currentItem.css(\"paddingRight\")||0, 10)); }\n        }\n      };\n    }\n\n    //Create the placeholder\n    that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));\n\n    //Append it after the actual current item\n    that.currentItem.after(that.placeholder);\n\n    //Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)\n    o.placeholder.update(that, that.placeholder);\n\n  },\n\n  _contactContainers: function(event) {\n    var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, base, cur, nearBottom,\n      innermostContainer = null,\n      innermostIndex = null;\n\n    // get innermost container that intersects with item\n    for (i = this.containers.length - 1; i >= 0; i--) {\n\n      // never consider a container that's located within the item itself\n      if($.contains(this.currentItem[0], this.containers[i].element[0])) {\n        continue;\n      }\n\n      if(this._intersectsWith(this.containers[i].containerCache)) {\n\n        // if we've already found a container and it's more \"inner\" than this, then continue\n        if(innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {\n          continue;\n        }\n\n        innermostContainer = this.containers[i];\n        innermostIndex = i;\n\n      } else {\n        // container doesn't intersect. trigger \"out\" event if necessary\n        if(this.containers[i].containerCache.over) {\n          this.containers[i]._trigger(\"out\", event, this._uiHash(this));\n          this.containers[i].containerCache.over = 0;\n        }\n      }\n\n    }\n\n    // if no intersecting containers found, return\n    if(!innermostContainer) {\n      return;\n    }\n\n    // move the item into the container if it's not there already\n    if(this.containers.length === 1) {\n      this.containers[innermostIndex]._trigger(\"over\", event, this._uiHash(this));\n      this.containers[innermostIndex].containerCache.over = 1;\n    } else {\n\n      //When entering a new container, we will find the item with the least distance and append our item near it\n      dist = 10000;\n      itemWithLeastDistance = null;\n      posProperty = this.containers[innermostIndex].floating ? \"left\" : \"top\";\n      sizeProperty = this.containers[innermostIndex].floating ? \"width\" : \"height\";\n      base = this.positionAbs[posProperty] + this.offset.click[posProperty];\n      for (j = this.items.length - 1; j >= 0; j--) {\n        if(!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {\n          continue;\n        }\n        if(this.items[j].item[0] === this.currentItem[0]) {\n          continue;\n        }\n        cur = this.items[j].item.offset()[posProperty];\n        nearBottom = false;\n        if(Math.abs(cur - base) > Math.abs(cur + this.items[j][sizeProperty] - base)){\n          nearBottom = true;\n          cur += this.items[j][sizeProperty];\n        }\n\n        if(Math.abs(cur - base) < dist) {\n          dist = Math.abs(cur - base); itemWithLeastDistance = this.items[j];\n          this.direction = nearBottom ? \"up\": \"down\";\n        }\n      }\n\n      //Check if dropOnEmpty is enabled\n      if(!itemWithLeastDistance && !this.options.dropOnEmpty) {\n        return;\n      }\n\n      this.currentContainer = this.containers[innermostIndex];\n      itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);\n      this._trigger(\"change\", event, this._uiHash());\n      this.containers[innermostIndex]._trigger(\"change\", event, this._uiHash(this));\n\n      //Update the placeholder\n      this.options.placeholder.update(this.currentContainer, this.placeholder);\n\n      this.containers[innermostIndex]._trigger(\"over\", event, this._uiHash(this));\n      this.containers[innermostIndex].containerCache.over = 1;\n    }\n\n\n  },\n\n  _createHelper: function(event) {\n\n    var o = this.options,\n      helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper === \"clone\" ? this.currentItem.clone() : this.currentItem);\n\n    //Add the helper to the DOM if that didn't happen already\n    if(!helper.parents(\"body\").length) {\n      $(o.appendTo !== \"parent\" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);\n    }\n\n    if(helper[0] === this.currentItem[0]) {\n      this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css(\"position\"), top: this.currentItem.css(\"top\"), left: this.currentItem.css(\"left\") };\n    }\n\n    if(!helper[0].style.width || o.forceHelperSize) {\n      helper.width(this.currentItem.width());\n    }\n    if(!helper[0].style.height || o.forceHelperSize) {\n      helper.height(this.currentItem.height());\n    }\n\n    return helper;\n\n  },\n\n  _adjustOffsetFromHelper: function(obj) {\n    if (typeof obj === \"string\") {\n      obj = obj.split(\" \");\n    }\n    if ($.isArray(obj)) {\n      obj = {left: +obj[0], top: +obj[1] || 0};\n    }\n    if (\"left\" in obj) {\n      this.offset.click.left = obj.left + this.margins.left;\n    }\n    if (\"right\" in obj) {\n      this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;\n    }\n    if (\"top\" in obj) {\n      this.offset.click.top = obj.top + this.margins.top;\n    }\n    if (\"bottom\" in obj) {\n      this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;\n    }\n  },\n\n  _getParentOffset: function() {\n\n\n    //Get the offsetParent and cache its position\n    this.offsetParent = this.helper.offsetParent();\n    var po = this.offsetParent.offset();\n\n    // This is a special case where we need to modify a offset calculated on start, since the following happened:\n    // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent\n    // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that\n    //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag\n    if(this.cssPosition === \"absolute\" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {\n      po.left += this.scrollParent.scrollLeft();\n      po.top += this.scrollParent.scrollTop();\n    }\n\n    // This needs to be actually done for all browsers, since pageX/pageY includes this information\n    // with an ugly IE fix\n    if( this.offsetParent[0] === document.body || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === \"html\" && $.ui.ie)) {\n      po = { top: 0, left: 0 };\n    }\n\n    return {\n      top: po.top + (parseInt(this.offsetParent.css(\"borderTopWidth\"),10) || 0),\n      left: po.left + (parseInt(this.offsetParent.css(\"borderLeftWidth\"),10) || 0)\n    };\n\n  },\n\n  _getRelativeOffset: function() {\n\n    if(this.cssPosition === \"relative\") {\n      var p = this.currentItem.position();\n      return {\n        top: p.top - (parseInt(this.helper.css(\"top\"),10) || 0) + this.scrollParent.scrollTop(),\n        left: p.left - (parseInt(this.helper.css(\"left\"),10) || 0) + this.scrollParent.scrollLeft()\n      };\n    } else {\n      return { top: 0, left: 0 };\n    }\n\n  },\n\n  _cacheMargins: function() {\n    this.margins = {\n      left: (parseInt(this.currentItem.css(\"marginLeft\"),10) || 0),\n      top: (parseInt(this.currentItem.css(\"marginTop\"),10) || 0)\n    };\n  },\n\n  _cacheHelperProportions: function() {\n    this.helperProportions = {\n      width: this.helper.outerWidth(),\n      height: this.helper.outerHeight()\n    };\n  },\n\n  _setContainment: function() {\n\n    var ce, co, over,\n      o = this.options;\n    if(o.containment === \"parent\") {\n      o.containment = this.helper[0].parentNode;\n    }\n    if(o.containment === \"document\" || o.containment === \"window\") {\n      this.containment = [\n        0 - this.offset.relative.left - this.offset.parent.left,\n        0 - this.offset.relative.top - this.offset.parent.top,\n        $(o.containment === \"document\" ? document : window).width() - this.helperProportions.width - this.margins.left,\n        ($(o.containment === \"document\" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top\n      ];\n    }\n\n    if(!(/^(document|window|parent)$/).test(o.containment)) {\n      ce = $(o.containment)[0];\n      co = $(o.containment).offset();\n      over = ($(ce).css(\"overflow\") !== \"hidden\");\n\n      this.containment = [\n        co.left + (parseInt($(ce).css(\"borderLeftWidth\"),10) || 0) + (parseInt($(ce).css(\"paddingLeft\"),10) || 0) - this.margins.left,\n        co.top + (parseInt($(ce).css(\"borderTopWidth\"),10) || 0) + (parseInt($(ce).css(\"paddingTop\"),10) || 0) - this.margins.top,\n        co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css(\"borderLeftWidth\"),10) || 0) - (parseInt($(ce).css(\"paddingRight\"),10) || 0) - this.helperProportions.width - this.margins.left,\n        co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css(\"borderTopWidth\"),10) || 0) - (parseInt($(ce).css(\"paddingBottom\"),10) || 0) - this.helperProportions.height - this.margins.top\n      ];\n    }\n\n  },\n\n  _convertPositionTo: function(d, pos) {\n\n    if(!pos) {\n      pos = this.position;\n    }\n    var mod = d === \"absolute\" ? 1 : -1,\n      scroll = this.cssPosition === \"absolute\" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,\n      scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);\n\n    return {\n      top: (\n        pos.top  +                                // The absolute mouse position\n        this.offset.relative.top * mod +                    // Only for relative positioned nodes: Relative offset from element to offset parent\n        this.offset.parent.top * mod -                      // The offsetParent's offset without borders (offset + border)\n        ( ( this.cssPosition === \"fixed\" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)\n      ),\n      left: (\n        pos.left +                                // The absolute mouse position\n        this.offset.relative.left * mod +                    // Only for relative positioned nodes: Relative offset from element to offset parent\n        this.offset.parent.left * mod  -                    // The offsetParent's offset without borders (offset + border)\n        ( ( this.cssPosition === \"fixed\" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)\n      )\n    };\n\n  },\n\n  _generatePosition: function(event) {\n\n    var top, left,\n      o = this.options,\n      pageX = event.pageX,\n      pageY = event.pageY,\n      scroll = this.cssPosition === \"absolute\" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);\n\n    // This is another very weird special case that only happens for relative elements:\n    // 1. If the css position is relative\n    // 2. and the scroll parent is the document or similar to the offset parent\n    // we have to refresh the relative offset during the scroll so there are no jumps\n    if(this.cssPosition === \"relative\" && !(this.scrollParent[0] !== document && this.scrollParent[0] !== this.offsetParent[0])) {\n      this.offset.relative = this._getRelativeOffset();\n    }\n\n    /*\n     * - Position constraining -\n     * Constrain the position to a mix of grid, containment.\n     */\n\n    if(this.originalPosition) { //If we are not dragging yet, we won't check for options\n\n      if(this.containment) {\n        if(event.pageX - this.offset.click.left < this.containment[0]) {\n          pageX = this.containment[0] + this.offset.click.left;\n        }\n        if(event.pageY - this.offset.click.top < this.containment[1]) {\n          pageY = this.containment[1] + this.offset.click.top;\n        }\n        if(event.pageX - this.offset.click.left > this.containment[2]) {\n          pageX = this.containment[2] + this.offset.click.left;\n        }\n        if(event.pageY - this.offset.click.top > this.containment[3]) {\n          pageY = this.containment[3] + this.offset.click.top;\n        }\n      }\n\n      if(o.grid) {\n        top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];\n        pageY = this.containment ? ( (top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3]) ? top : ((top - this.offset.click.top >= this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;\n\n        left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];\n        pageX = this.containment ? ( (left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2]) ? left : ((left - this.offset.click.left >= this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;\n      }\n\n    }\n\n    return {\n      top: (\n        pageY -                                // The absolute mouse position\n        this.offset.click.top -                          // Click offset (relative to the element)\n        this.offset.relative.top  -                      // Only for relative positioned nodes: Relative offset from element to offset parent\n        this.offset.parent.top +                        // The offsetParent's offset without borders (offset + border)\n        ( ( this.cssPosition === \"fixed\" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))\n      ),\n      left: (\n        pageX -                                // The absolute mouse position\n        this.offset.click.left -                        // Click offset (relative to the element)\n        this.offset.relative.left  -                      // Only for relative positioned nodes: Relative offset from element to offset parent\n        this.offset.parent.left +                        // The offsetParent's offset without borders (offset + border)\n        ( ( this.cssPosition === \"fixed\" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))\n      )\n    };\n\n  },\n\n  _rearrange: function(event, i, a, hardRefresh) {\n\n    a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction === \"down\" ? i.item[0] : i.item[0].nextSibling));\n\n    //Various things done here to improve the performance:\n    // 1. we create a setTimeout, that calls refreshPositions\n    // 2. on the instance, we have a counter variable, that get's higher after every append\n    // 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same\n    // 4. this lets only the last addition to the timeout stack through\n    this.counter = this.counter ? ++this.counter : 1;\n    var counter = this.counter;\n\n    this._delay(function() {\n      if(counter === this.counter) {\n        this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove\n      }\n    });\n\n  },\n\n  _clear: function(event, noPropagation) {\n\n    this.reverting = false;\n    // We delay all events that have to be triggered to after the point where the placeholder has been removed and\n    // everything else normalized again\n    var i,\n      delayedTriggers = [];\n\n    // We first have to update the dom position of the actual currentItem\n    // Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)\n    if(!this._noFinalSort && this.currentItem.parent().length) {\n      this.placeholder.before(this.currentItem);\n    }\n    this._noFinalSort = null;\n\n    if(this.helper[0] === this.currentItem[0]) {\n      for(i in this._storedCSS) {\n        if(this._storedCSS[i] === \"auto\" || this._storedCSS[i] === \"static\") {\n          this._storedCSS[i] = \"\";\n        }\n      }\n      this.currentItem.css(this._storedCSS).removeClass(\"ui-sortable-helper\");\n    } else {\n      this.currentItem.show();\n    }\n\n    if(this.fromOutside && !noPropagation) {\n      delayedTriggers.push(function(event) { this._trigger(\"receive\", event, this._uiHash(this.fromOutside)); });\n    }\n    if((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(\".ui-sortable-helper\")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {\n      delayedTriggers.push(function(event) { this._trigger(\"update\", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed\n    }\n\n    // Check if the items Container has Changed and trigger appropriate\n    // events.\n    if (this !== this.currentContainer) {\n      if(!noPropagation) {\n        delayedTriggers.push(function(event) { this._trigger(\"remove\", event, this._uiHash()); });\n        delayedTriggers.push((function(c) { return function(event) { c._trigger(\"receive\", event, this._uiHash(this)); };  }).call(this, this.currentContainer));\n        delayedTriggers.push((function(c) { return function(event) { c._trigger(\"update\", event, this._uiHash(this));  }; }).call(this, this.currentContainer));\n      }\n    }\n\n\n    //Post events to containers\n    for (i = this.containers.length - 1; i >= 0; i--){\n      if(!noPropagation) {\n        delayedTriggers.push((function(c) { return function(event) { c._trigger(\"deactivate\", event, this._uiHash(this)); };  }).call(this, this.containers[i]));\n      }\n      if(this.containers[i].containerCache.over) {\n        delayedTriggers.push((function(c) { return function(event) { c._trigger(\"out\", event, this._uiHash(this)); };  }).call(this, this.containers[i]));\n        this.containers[i].containerCache.over = 0;\n      }\n    }\n\n    //Do what was originally in plugins\n    if(this._storedCursor) {\n      $(\"body\").css(\"cursor\", this._storedCursor);\n    }\n    if(this._storedOpacity) {\n      this.helper.css(\"opacity\", this._storedOpacity);\n    }\n    if(this._storedZIndex) {\n      this.helper.css(\"zIndex\", this._storedZIndex === \"auto\" ? \"\" : this._storedZIndex);\n    }\n\n    this.dragging = false;\n    if(this.cancelHelperRemoval) {\n      if(!noPropagation) {\n        this._trigger(\"beforeStop\", event, this._uiHash());\n        for (i=0; i < delayedTriggers.length; i++) {\n          delayedTriggers[i].call(this, event);\n        } //Trigger all delayed events\n        this._trigger(\"stop\", event, this._uiHash());\n      }\n\n      this.fromOutside = false;\n      return false;\n    }\n\n    if(!noPropagation) {\n      this._trigger(\"beforeStop\", event, this._uiHash());\n    }\n\n    //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!\n    this.placeholder[0].parentNode.removeChild(this.placeholder[0]);\n\n    if(this.helper[0] !== this.currentItem[0]) {\n      this.helper.remove();\n    }\n    this.helper = null;\n\n    if(!noPropagation) {\n      for (i=0; i < delayedTriggers.length; i++) {\n        delayedTriggers[i].call(this, event);\n      } //Trigger all delayed events\n      this._trigger(\"stop\", event, this._uiHash());\n    }\n\n    this.fromOutside = false;\n    return true;\n\n  },\n\n  _trigger: function() {\n    if ($.Widget.prototype._trigger.apply(this, arguments) === false) {\n      this.cancel();\n    }\n  },\n\n  _uiHash: function(_inst) {\n    var inst = _inst || this;\n    return {\n      helper: inst.helper,\n      placeholder: inst.placeholder || $([]),\n      position: inst.position,\n      originalPosition: inst.originalPosition,\n      offset: inst.positionAbs,\n      item: inst.currentItem,\n      sender: _inst ? _inst.element : null\n    };\n  }\n\n});\n\n})(jQuery);\n;\n/*!\n * jQuery UI Touch Punch 0.2.2\n *\n * Copyright 2011, Dave Furfero\n * Dual licensed under the MIT or GPL Version 2 licenses.\n *\n * Depends:\n *  jquery.ui.widget.js\n *  jquery.ui.mouse.js\n */\n(function ($) {\n\n  // Detect touch support\n  $.support.touch = 'ontouchend' in document;\n\n  // Ignore browsers without touch support\n  if (!$.support.touch) {\n    return;\n  }\n\n  var mouseProto = $.ui.mouse.prototype,\n      _mouseInit = mouseProto._mouseInit,\n      touchHandled;\n\n  /**\n   * Simulate a mouse event based on a corresponding touch event\n   * @param {Object} event A touch event\n   * @param {String} simulatedType The corresponding mouse event\n   */\n  function simulateMouseEvent (event, simulatedType) {\n\n    // Ignore multi-touch events\n    if (event.originalEvent.touches.length > 1) {\n      return;\n    }\n\n    event.preventDefault();\n\n    var touch = event.originalEvent.changedTouches[0],\n        simulatedEvent = document.createEvent('MouseEvents');\n    \n    // Initialize the simulated mouse event using the touch event's coordinates\n    simulatedEvent.initMouseEvent(\n      simulatedType,    // type\n      true,             // bubbles                    \n      true,             // cancelable                 \n      window,           // view                       \n      1,                // detail                     \n      touch.screenX,    // screenX                    \n      touch.screenY,    // screenY                    \n      touch.clientX,    // clientX                    \n      touch.clientY,    // clientY                    \n      false,            // ctrlKey                    \n      false,            // altKey                     \n      false,            // shiftKey                   \n      false,            // metaKey                    \n      0,                // button                     \n      null              // relatedTarget              \n    );\n\n    // Dispatch the simulated event to the target element\n    event.target.dispatchEvent(simulatedEvent);\n  }\n\n  /**\n   * Handle the jQuery UI widget's touchstart events\n   * @param {Object} event The widget element's touchstart event\n   */\n  mouseProto._touchStart = function (event) {\n\n    var self = this;\n\n    // Ignore the event if another widget is already being handled\n    if (touchHandled || !self._mouseCapture(event.originalEvent.changedTouches[0])) {\n      return;\n    }\n\n    // Set the flag to prevent other widgets from inheriting the touch event\n    touchHandled = true;\n\n    // Track movement to determine if interaction was a click\n    self._touchMoved = false;\n\n    // Simulate the mouseover event\n    simulateMouseEvent(event, 'mouseover');\n\n    // Simulate the mousemove event\n    simulateMouseEvent(event, 'mousemove');\n\n    // Simulate the mousedown event\n    simulateMouseEvent(event, 'mousedown');\n  };\n\n  /**\n   * Handle the jQuery UI widget's touchmove events\n   * @param {Object} event The document's touchmove event\n   */\n  mouseProto._touchMove = function (event) {\n\n    // Ignore event if not handled\n    if (!touchHandled) {\n      return;\n    }\n\n    // Interaction was not a click\n    this._touchMoved = true;\n\n    // Simulate the mousemove event\n    simulateMouseEvent(event, 'mousemove');\n  };\n\n  /**\n   * Handle the jQuery UI widget's touchend events\n   * @param {Object} event The document's touchend event\n   */\n  mouseProto._touchEnd = function (event) {\n\n    // Ignore event if not handled\n    if (!touchHandled) {\n      return;\n    }\n\n    // Simulate the mouseup event\n    simulateMouseEvent(event, 'mouseup');\n\n    // Simulate the mouseout event\n    simulateMouseEvent(event, 'mouseout');\n\n    // If the touch interaction did not move, it should trigger a click\n    if (!this._touchMoved) {\n\n      // Simulate the click event\n      simulateMouseEvent(event, 'click');\n    }\n\n    // Unset the flag to allow other widgets to inherit the touch event\n    touchHandled = false;\n  };\n\n  /**\n   * A duck punch of the $.ui.mouse _mouseInit method to support touch events.\n   * This method extends the widget with bound touch event handlers that\n   * translate touch events to mouse events and pass them to the widget's\n   * original mouse event handling methods.\n   */\n  mouseProto._mouseInit = function () {\n    \n    var self = this;\n\n    // Delegate the touch handlers to the widget's element\n    self.element\n      .bind('touchstart', $.proxy(self, '_touchStart'))\n      .bind('touchmove', $.proxy(self, '_touchMove'))\n      .bind('touchend', $.proxy(self, '_touchEnd'));\n\n    // Call the original $.ui.mouse init method\n    _mouseInit.call(self);\n  };\n\n})(jQuery);\n\n//@ sourceURL=/node_modules/sortable/ui.js"
));

require.define("/node_modules/sortable/node_modules/jquery-browserify/package.json",Function(['require','module','exports','__dirname','__filename','process','global'],"module.exports = {\"main\":\"./lib/jquery.js\",\"browserify\":{\"dependencies\":\"\",\"main\":\"lib/jquery.js\"}}\n//@ sourceURL=/node_modules/sortable/node_modules/jquery-browserify/package.json"
));

require.define("/node_modules/sortable/node_modules/jquery-browserify/lib/jquery.js",Function(['require','module','exports','__dirname','__filename','process','global'],"// Uses Node, AMD or browser globals to create a module.\n\n// If you want something that will work in other stricter CommonJS environments,\n// or if you need to create a circular dependency, see commonJsStrict.js\n\n// Defines a module \"returnExports\" that depends another module called \"b\".\n// Note that the name of the module is implied by the file name. It is best\n// if the file name and the exported global have matching names.\n\n// If the 'b' module also uses this type of boilerplate, then\n// in the browser, it will create a global .b that is used below.\n\n// If you do not want to support the browser global path, then you\n// can remove the `root` use and the passing `this` as the first arg to\n// the top function.\n\n(function (root, factory) {\n    if (typeof exports === 'object') {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like enviroments that support module.exports,\n        // like Node.\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], factory);\n    } else {\n        // Browser globals\n        root.returnExports = factory();\n    }\n}(this, function () {/*!\n * jQuery JavaScript Library v1.8.1\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright 2012 jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: Thu Aug 30 2012 17:17:22 GMT-0400 (Eastern Daylight Time)\n */\nreturn (function( window, undefined ) {\nvar\n\t// A central reference to the root jQuery(document)\n\trootjQuery,\n\n\t// The deferred used on DOM ready\n\treadyList,\n\n\t// Use the correct document accordingly with window argument (sandbox)\n\tdocument = window.document,\n\tlocation = window.location,\n\tnavigator = window.navigator,\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$,\n\n\t// Save a reference to some core methods\n\tcore_push = Array.prototype.push,\n\tcore_slice = Array.prototype.slice,\n\tcore_indexOf = Array.prototype.indexOf,\n\tcore_toString = Object.prototype.toString,\n\tcore_hasOwn = Object.prototype.hasOwnProperty,\n\tcore_trim = String.prototype.trim,\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\treturn new jQuery.fn.init( selector, context, rootjQuery );\n\t},\n\n\t// Used for matching numbers\n\tcore_pnum = /[\\-+]?(?:\\d*\\.|)\\d+(?:[eE][\\-+]?\\d+|)/.source,\n\n\t// Used for detecting and trimming whitespace\n\tcore_rnotwhite = /\\S/,\n\tcore_rspace = /\\s+/,\n\n\t// Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\trquickExpr = /^(?:[^#<]*(<[\\w\\W]+>)[^>]*$|#([\\w\\-]*)$)/,\n\n\t// Match a standalone tag\n\trsingleTag = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\n\n\t// JSON RegExp\n\trvalidchars = /^[\\],:{}\\s]*$/,\n\trvalidbraces = /(?:^|:|,)(?:\\s*\\[)+/g,\n\trvalidescape = /\\\\(?:[\"\\\\\\/bfnrt]|u[\\da-fA-F]{4})/g,\n\trvalidtokens = /\"[^\"\\\\\\r\\n]*\"|true|false|null|-?(?:\\d\\d*\\.|)\\d+(?:[eE][\\-+]?\\d+|)/g,\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\trdashAlpha = /-([\\da-z])/gi,\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function( all, letter ) {\n\t\treturn ( letter + \"\" ).toUpperCase();\n\t},\n\n\t// The ready event handler and self cleanup method\n\tDOMContentLoaded = function() {\n\t\tif ( document.addEventListener ) {\n\t\t\tdocument.removeEventListener( \"DOMContentLoaded\", DOMContentLoaded, false );\n\t\t\tjQuery.ready();\n\t\t} else if ( document.readyState === \"complete\" ) {\n\t\t\t// we're here because readyState === \"complete\" in oldIE\n\t\t\t// which is good enough for us to call the dom ready!\n\t\t\tdocument.detachEvent( \"onreadystatechange\", DOMContentLoaded );\n\t\t\tjQuery.ready();\n\t\t}\n\t},\n\n\t// [[Class]] -> type pairs\n\tclass2type = {};\n\njQuery.fn = jQuery.prototype = {\n\tconstructor: jQuery,\n\tinit: function( selector, context, rootjQuery ) {\n\t\tvar match, elem, ret, doc;\n\n\t\t// Handle $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Handle $(DOMElement)\n\t\tif ( selector.nodeType ) {\n\t\t\tthis.context = this[0] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\t\t}\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector.charAt(0) === \"<\" && selector.charAt( selector.length - 1 ) === \">\" && selector.length >= 3 ) {\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && (match[1] || !context) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[1] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[0] : context;\n\t\t\t\t\tdoc = ( context && context.nodeType ? context.ownerDocument || context : document );\n\n\t\t\t\t\t// scripts is true for back-compat\n\t\t\t\t\tselector = jQuery.parseHTML( match[1], doc, true );\n\t\t\t\t\tif ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tthis.attr.call( selector, context, true );\n\t\t\t\t\t}\n\n\t\t\t\t\treturn jQuery.merge( this, selector );\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[2] );\n\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Handle the case where IE and Opera return items\n\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\tif ( elem.id !== match[2] ) {\n\t\t\t\t\t\t\treturn rootjQuery.find( selector );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Otherwise, we inject the element directly into the jQuery object\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t\tthis[0] = elem;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.context = document;\n\t\t\t\t\tthis.selector = selector;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || rootjQuery ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn rootjQuery.ready( selector );\n\t\t}\n\n\t\tif ( selector.selector !== undefined ) {\n\t\t\tthis.selector = selector.selector;\n\t\t\tthis.context = selector.context;\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t},\n\n\t// Start with an empty selector\n\tselector: \"\",\n\n\t// The current version of jQuery being used\n\tjquery: \"1.8.1\",\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\t// The number of elements contained in the matched element set\n\tsize: function() {\n\t\treturn this.length;\n\t},\n\n\ttoArray: function() {\n\t\treturn core_slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\t\treturn num == null ?\n\n\t\t\t// Return a 'clean' array\n\t\t\tthis.toArray() :\n\n\t\t\t// Return just the object\n\t\t\t( num < 0 ? this[ this.length + num ] : this[ num ] );\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems, name, selector ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\n\t\tret.context = this.context;\n\n\t\tif ( name === \"find\" ) {\n\t\t\tret.selector = this.selector + ( this.selector ? \" \" : \"\" ) + selector;\n\t\t} else if ( name ) {\n\t\t\tret.selector = this.selector + \".\" + name + \"(\" + selector + \")\";\n\t\t}\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\t// (You can seed the arguments with an array of args, but this is\n\t// only used internally.)\n\teach: function( callback, args ) {\n\t\treturn jQuery.each( this, callback, args );\n\t},\n\n\tready: function( fn ) {\n\t\t// Add the callback\n\t\tjQuery.ready.promise().done( fn );\n\n\t\treturn this;\n\t},\n\n\teq: function( i ) {\n\t\ti = +i;\n\t\treturn i === -1 ?\n\t\t\tthis.slice( i ) :\n\t\t\tthis.slice( i, i + 1 );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( core_slice.apply( this, arguments ),\n\t\t\t\"slice\", core_slice.call(arguments).join(\",\") );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map(this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t}));\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor(null);\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: core_push,\n\tsort: [].sort,\n\tsplice: [].splice\n};\n\n// Give the init function the jQuery prototype for later instantiation\njQuery.fn.init.prototype = jQuery.fn;\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[0] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n\t\ttarget = {};\n\t}\n\n\t// extend jQuery itself if only one argument is passed\n\tif ( length === i ) {\n\t\ttarget = this;\n\t\t--i;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\t\t// Only deal with non-null/undefined values\n\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && jQuery.isArray(src) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend({\n\tnoConflict: function( deep ) {\n\t\tif ( window.$ === jQuery ) {\n\t\t\twindow.$ = _$;\n\t\t}\n\n\t\tif ( deep && window.jQuery === jQuery ) {\n\t\t\twindow.jQuery = _jQuery;\n\t\t}\n\n\t\treturn jQuery;\n\t},\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Hold (or release) the ready event\n\tholdReady: function( hold ) {\n\t\tif ( hold ) {\n\t\t\tjQuery.readyWait++;\n\t\t} else {\n\t\t\tjQuery.ready( true );\n\t\t}\n\t},\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n\t\tif ( !document.body ) {\n\t\t\treturn setTimeout( jQuery.ready, 1 );\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\n\t\t// Trigger any bound ready events\n\t\tif ( jQuery.fn.trigger ) {\n\t\t\tjQuery( document ).trigger(\"ready\").off(\"ready\");\n\t\t}\n\t},\n\n\t// See test/unit/core.js for details concerning isFunction.\n\t// Since version 1.3, DOM methods and functions like alert\n\t// aren't supported. They return false on IE (#2968).\n\tisFunction: function( obj ) {\n\t\treturn jQuery.type(obj) === \"function\";\n\t},\n\n\tisArray: Array.isArray || function( obj ) {\n\t\treturn jQuery.type(obj) === \"array\";\n\t},\n\n\tisWindow: function( obj ) {\n\t\treturn obj != null && obj == obj.window;\n\t},\n\n\tisNumeric: function( obj ) {\n\t\treturn !isNaN( parseFloat(obj) ) && isFinite( obj );\n\t},\n\n\ttype: function( obj ) {\n\t\treturn obj == null ?\n\t\t\tString( obj ) :\n\t\t\tclass2type[ core_toString.call(obj) ] || \"object\";\n\t},\n\n\tisPlainObject: function( obj ) {\n\t\t// Must be an Object.\n\t\t// Because of IE, we also have to check the presence of the constructor property.\n\t\t// Make sure that DOM nodes and window objects don't pass through, as well\n\t\tif ( !obj || jQuery.type(obj) !== \"object\" || obj.nodeType || jQuery.isWindow( obj ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\ttry {\n\t\t\t// Not own constructor property must be Object\n\t\t\tif ( obj.constructor &&\n\t\t\t\t!core_hasOwn.call(obj, \"constructor\") &&\n\t\t\t\t!core_hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\") ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} catch ( e ) {\n\t\t\t// IE8,9 Will throw exceptions on certain host objects #9897\n\t\t\treturn false;\n\t\t}\n\n\t\t// Own properties are enumerated firstly, so to speed up,\n\t\t// if last one is own, then all properties are own.\n\n\t\tvar key;\n\t\tfor ( key in obj ) {}\n\n\t\treturn key === undefined || core_hasOwn.call( obj, key );\n\t},\n\n\tisEmptyObject: function( obj ) {\n\t\tvar name;\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\t// data: string of html\n\t// context (optional): If specified, the fragment will be created in this context, defaults to document\n\t// scripts (optional): If true, will include scripts passed in the html string\n\tparseHTML: function( data, context, scripts ) {\n\t\tvar parsed;\n\t\tif ( !data || typeof data !== \"string\" ) {\n\t\t\treturn null;\n\t\t}\n\t\tif ( typeof context === \"boolean\" ) {\n\t\t\tscripts = context;\n\t\t\tcontext = 0;\n\t\t}\n\t\tcontext = context || document;\n\n\t\t// Single tag\n\t\tif ( (parsed = rsingleTag.exec( data )) ) {\n\t\t\treturn [ context.createElement( parsed[1] ) ];\n\t\t}\n\n\t\tparsed = jQuery.buildFragment( [ data ], context, scripts ? null : [] );\n\t\treturn jQuery.merge( [],\n\t\t\t(parsed.cacheable ? jQuery.clone( parsed.fragment ) : parsed.fragment).childNodes );\n\t},\n\n\tparseJSON: function( data ) {\n\t\tif ( !data || typeof data !== \"string\") {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Make sure leading/trailing whitespace is removed (IE can't handle it)\n\t\tdata = jQuery.trim( data );\n\n\t\t// Attempt to parse using the native JSON parser first\n\t\tif ( window.JSON && window.JSON.parse ) {\n\t\t\treturn window.JSON.parse( data );\n\t\t}\n\n\t\t// Make sure the incoming data is actual JSON\n\t\t// Logic borrowed from http://json.org/json2.js\n\t\tif ( rvalidchars.test( data.replace( rvalidescape, \"@\" )\n\t\t\t.replace( rvalidtokens, \"]\" )\n\t\t\t.replace( rvalidbraces, \"\")) ) {\n\n\t\t\treturn ( new Function( \"return \" + data ) )();\n\n\t\t}\n\t\tjQuery.error( \"Invalid JSON: \" + data );\n\t},\n\n\t// Cross-browser xml parsing\n\tparseXML: function( data ) {\n\t\tvar xml, tmp;\n\t\tif ( !data || typeof data !== \"string\" ) {\n\t\t\treturn null;\n\t\t}\n\t\ttry {\n\t\t\tif ( window.DOMParser ) { // Standard\n\t\t\t\ttmp = new DOMParser();\n\t\t\t\txml = tmp.parseFromString( data , \"text/xml\" );\n\t\t\t} else { // IE\n\t\t\t\txml = new ActiveXObject( \"Microsoft.XMLDOM\" );\n\t\t\t\txml.async = \"false\";\n\t\t\t\txml.loadXML( data );\n\t\t\t}\n\t\t} catch( e ) {\n\t\t\txml = undefined;\n\t\t}\n\t\tif ( !xml || !xml.documentElement || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\t\tjQuery.error( \"Invalid XML: \" + data );\n\t\t}\n\t\treturn xml;\n\t},\n\n\tnoop: function() {},\n\n\t// Evaluates a script in a global context\n\t// Workarounds based on findings by Jim Driscoll\n\t// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context\n\tglobalEval: function( data ) {\n\t\tif ( data && core_rnotwhite.test( data ) ) {\n\t\t\t// We use execScript on Internet Explorer\n\t\t\t// We use an anonymous function so that context is window\n\t\t\t// rather than jQuery in Firefox\n\t\t\t( window.execScript || function( data ) {\n\t\t\t\twindow[ \"eval\" ].call( window, data );\n\t\t\t} )( data );\n\t\t}\n\t},\n\n\t// Convert dashed to camelCase; used by the css and data modules\n\t// Microsoft forgot to hump their vendor prefix (#9572)\n\tcamelCase: function( string ) {\n\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t},\n\n\tnodeName: function( elem, name ) {\n\t\treturn elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();\n\t},\n\n\t// args is for internal usage only\n\teach: function( obj, callback, args ) {\n\t\tvar name,\n\t\t\ti = 0,\n\t\t\tlength = obj.length,\n\t\t\tisObj = length === undefined || jQuery.isFunction( obj );\n\n\t\tif ( args ) {\n\t\t\tif ( isObj ) {\n\t\t\t\tfor ( name in obj ) {\n\t\t\t\t\tif ( callback.apply( obj[ name ], args ) === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( ; i < length; ) {\n\t\t\t\t\tif ( callback.apply( obj[ i++ ], args ) === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// A special, fast, case for the most common use of each\n\t\t} else {\n\t\t\tif ( isObj ) {\n\t\t\t\tfor ( name in obj ) {\n\t\t\t\t\tif ( callback.call( obj[ name ], name, obj[ name ] ) === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( ; i < length; ) {\n\t\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i++ ] ) === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Use native String.trim function wherever possible\n\ttrim: core_trim && !core_trim.call(\"\\uFEFF\\xA0\") ?\n\t\tfunction( text ) {\n\t\t\treturn text == null ?\n\t\t\t\t\"\" :\n\t\t\t\tcore_trim.call( text );\n\t\t} :\n\n\t\t// Otherwise use our own trimming functionality\n\t\tfunction( text ) {\n\t\t\treturn text == null ?\n\t\t\t\t\"\" :\n\t\t\t\ttext.toString().replace( rtrim, \"\" );\n\t\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar type,\n\t\t\tret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\t// The window, strings (and functions) also have 'length'\n\t\t\t// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930\n\t\t\ttype = jQuery.type( arr );\n\n\t\t\tif ( arr.length == null || type === \"string\" || type === \"function\" || type === \"regexp\" || jQuery.isWindow( arr ) ) {\n\t\t\t\tcore_push.call( ret, arr );\n\t\t\t} else {\n\t\t\t\tjQuery.merge( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\tvar len;\n\n\t\tif ( arr ) {\n\t\t\tif ( core_indexOf ) {\n\t\t\t\treturn core_indexOf.call( arr, elem, i );\n\t\t\t}\n\n\t\t\tlen = arr.length;\n\t\t\ti = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t// Skip accessing in sparse arrays\n\t\t\t\tif ( i in arr && arr[ i ] === elem ) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t},\n\n\tmerge: function( first, second ) {\n\t\tvar l = second.length,\n\t\t\ti = first.length,\n\t\t\tj = 0;\n\n\t\tif ( typeof l === \"number\" ) {\n\t\t\tfor ( ; j < l; j++ ) {\n\t\t\t\tfirst[ i++ ] = second[ j ];\n\t\t\t}\n\n\t\t} else {\n\t\t\twhile ( second[j] !== undefined ) {\n\t\t\t\tfirst[ i++ ] = second[ j++ ];\n\t\t\t}\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, inv ) {\n\t\tvar retVal,\n\t\t\tret = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length;\n\t\tinv = !!inv;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tretVal = !!callback( elems[ i ], i );\n\t\t\tif ( inv !== retVal ) {\n\t\t\t\tret.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar value, key,\n\t\t\tret = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\t// jquery objects are treated as arrays\n\t\t\tisArray = elems instanceof jQuery || length !== undefined && typeof length === \"number\" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;\n\n\t\t// Go through the array, translating each of the items to their\n\t\tif ( isArray ) {\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret[ ret.length ] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( key in elems ) {\n\t\t\t\tvalue = callback( elems[ key ], key, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret[ ret.length ] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn ret.concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// Bind a function to a context, optionally partially applying any\n\t// arguments.\n\tproxy: function( fn, context ) {\n\t\tvar tmp, args, proxy;\n\n\t\tif ( typeof context === \"string\" ) {\n\t\t\ttmp = fn[ context ];\n\t\t\tcontext = fn;\n\t\t\tfn = tmp;\n\t\t}\n\n\t\t// Quick check to determine if target is callable, in the spec\n\t\t// this throws a TypeError, but we will just return undefined.\n\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Simulated bind\n\t\targs = core_slice.call( arguments, 2 );\n\t\tproxy = function() {\n\t\t\treturn fn.apply( context, args.concat( core_slice.call( arguments ) ) );\n\t\t};\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;\n\n\t\treturn proxy;\n\t},\n\n\t// Multifunctional method to get and set values of a collection\n\t// The value/s can optionally be executed if it's a function\n\taccess: function( elems, fn, key, value, chainable, emptyGet, pass ) {\n\t\tvar exec,\n\t\t\tbulk = key == null,\n\t\t\ti = 0,\n\t\t\tlength = elems.length;\n\n\t\t// Sets many values\n\t\tif ( key && typeof key === \"object\" ) {\n\t\t\tfor ( i in key ) {\n\t\t\t\tjQuery.access( elems, fn, i, key[i], 1, emptyGet, value );\n\t\t\t}\n\t\t\tchainable = 1;\n\n\t\t// Sets one value\n\t\t} else if ( value !== undefined ) {\n\t\t\t// Optionally, function values get executed if exec is true\n\t\t\texec = pass === undefined && jQuery.isFunction( value );\n\n\t\t\tif ( bulk ) {\n\t\t\t\t// Bulk operations only iterate when executing function values\n\t\t\t\tif ( exec ) {\n\t\t\t\t\texec = fn;\n\t\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\t\treturn exec.call( jQuery( elem ), value );\n\t\t\t\t\t};\n\n\t\t\t\t// Otherwise they run against the entire set\n\t\t\t\t} else {\n\t\t\t\t\tfn.call( elems, value );\n\t\t\t\t\tfn = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( fn ) {\n\t\t\t\tfor (; i < length; i++ ) {\n\t\t\t\t\tfn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchainable = 1;\n\t\t}\n\n\t\treturn chainable ?\n\t\t\telems :\n\n\t\t\t// Gets\n\t\t\tbulk ?\n\t\t\t\tfn.call( elems ) :\n\t\t\t\tlength ? fn( elems[0], key ) : emptyGet;\n\t},\n\n\tnow: function() {\n\t\treturn ( new Date() ).getTime();\n\t}\n});\n\njQuery.ready.promise = function( obj ) {\n\tif ( !readyList ) {\n\n\t\treadyList = jQuery.Deferred();\n\n\t\t// Catch cases where $(document).ready() is called after the browser event has already occurred.\n\t\t// we once tried to use readyState \"interactive\" here, but it caused issues like the one\n\t\t// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n\t\tif ( document.readyState === \"complete\" ) {\n\t\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\t\tsetTimeout( jQuery.ready, 1 );\n\n\t\t// Standards-based browsers support DOMContentLoaded\n\t\t} else if ( document.addEventListener ) {\n\t\t\t// Use the handy event callback\n\t\t\tdocument.addEventListener( \"DOMContentLoaded\", DOMContentLoaded, false );\n\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.addEventListener( \"load\", jQuery.ready, false );\n\n\t\t// If IE event model is used\n\t\t} else {\n\t\t\t// Ensure firing before onload, maybe late but safe also for iframes\n\t\t\tdocument.attachEvent( \"onreadystatechange\", DOMContentLoaded );\n\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.attachEvent( \"onload\", jQuery.ready );\n\n\t\t\t// If IE and not a frame\n\t\t\t// continually check to see if the document is ready\n\t\t\tvar top = false;\n\n\t\t\ttry {\n\t\t\t\ttop = window.frameElement == null && document.documentElement;\n\t\t\t} catch(e) {}\n\n\t\t\tif ( top && top.doScroll ) {\n\t\t\t\t(function doScrollCheck() {\n\t\t\t\t\tif ( !jQuery.isReady ) {\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// Use the trick by Diego Perini\n\t\t\t\t\t\t\t// http://javascript.nwbox.com/IEContentLoaded/\n\t\t\t\t\t\t\ttop.doScroll(\"left\");\n\t\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t\treturn setTimeout( doScrollCheck, 50 );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// and execute any waiting functions\n\t\t\t\t\t\tjQuery.ready();\n\t\t\t\t\t}\n\t\t\t\t})();\n\t\t\t}\n\t\t}\n\t}\n\treturn readyList.promise( obj );\n};\n\n// Populate the class2type map\njQuery.each(\"Boolean Number String Function Array Date RegExp Object\".split(\" \"), function(i, name) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n});\n\n// All jQuery objects should point back to these\nrootjQuery = jQuery(document);\n// String to Object options format cache\nvar optionsCache = {};\n\n// Convert String-formatted options into Object-formatted ones and store in cache\nfunction createOptions( options ) {\n\tvar object = optionsCache[ options ] = {};\n\tjQuery.each( options.split( core_rspace ), function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t});\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\t( optionsCache[ options ] || createOptions( options ) ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Last fire value (for non-forgettable lists)\n\t\tmemory,\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\t\t// Flag to know if list is currently firing\n\t\tfiring,\n\t\t// First callback to fire (used internally by add and fireWith)\n\t\tfiringStart,\n\t\t// End of the loop when firing\n\t\tfiringLength,\n\t\t// Index of currently firing callback (modified by remove if needed)\n\t\tfiringIndex,\n\t\t// Actual callback list\n\t\tlist = [],\n\t\t// Stack of fire calls for repeatable lists\n\t\tstack = !options.once && [],\n\t\t// Fire callbacks\n\t\tfire = function( data ) {\n\t\t\tmemory = options.memory && data;\n\t\t\tfired = true;\n\t\t\tfiringIndex = firingStart || 0;\n\t\t\tfiringStart = 0;\n\t\t\tfiringLength = list.length;\n\t\t\tfiring = true;\n\t\t\tfor ( ; list && firingIndex < firingLength; firingIndex++ ) {\n\t\t\t\tif ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n\t\t\t\t\tmemory = false; // To prevent further calls using add\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiring = false;\n\t\t\tif ( list ) {\n\t\t\t\tif ( stack ) {\n\t\t\t\t\tif ( stack.length ) {\n\t\t\t\t\t\tfire( stack.shift() );\n\t\t\t\t\t}\n\t\t\t\t} else if ( memory ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t} else {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// Actual Callbacks object\n\t\tself = {\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\t// First, we save the current length\n\t\t\t\t\tvar start = list.length;\n\t\t\t\t\t(function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tvar type = jQuery.type( arg );\n\t\t\t\t\t\t\tif ( type === \"function\" && ( !options.unique || !self.has( arg ) ) ) {\n\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t} else if ( arg && arg.length && type !== \"string\" ) {\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t})( arguments );\n\t\t\t\t\t// Do we need to add the callbacks to the\n\t\t\t\t\t// current firing batch?\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tfiringLength = list.length;\n\t\t\t\t\t// With memory, if we're not firing then\n\t\t\t\t\t// we should call right away\n\t\t\t\t\t} else if ( memory ) {\n\t\t\t\t\t\tfiringStart = start;\n\t\t\t\t\t\tfire( memory );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\twhile( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\t\tlist.splice( index, 1 );\n\t\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\t\t\tif ( index <= firingLength ) {\n\t\t\t\t\t\t\t\t\tfiringLength--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Control if a given callback is in the list\n\t\t\thas: function( fn ) {\n\t\t\t\treturn jQuery.inArray( fn, list ) > -1;\n\t\t\t},\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tlist = [];\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Have the list do nothing anymore\n\t\t\tdisable: function() {\n\t\t\t\tlist = stack = memory = undefined;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it disabled?\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\t\t\t// Lock the list in its current state\n\t\t\tlock: function() {\n\t\t\t\tstack = undefined;\n\t\t\t\tif ( !memory ) {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it locked?\n\t\t\tlocked: function() {\n\t\t\t\treturn !stack;\n\t\t\t},\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\targs = args || [];\n\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\tif ( list && ( !fired || stack ) ) {\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tstack.push( args );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfire( args );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\njQuery.extend({\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\t\t\t\t// action, add listener, listener list, final state\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\" ],\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks(\"memory\") ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\treturn jQuery.Deferred(function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\t\t\t\tvar action = tuple[ 0 ],\n\t\t\t\t\t\t\t\tfn = fns[ i ];\n\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\tdeferred[ tuple[1] ]( jQuery.isFunction( fn ) ?\n\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\tvar returned = fn.apply( this, arguments );\n\t\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject )\n\t\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify );\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tnewDefer[ action + \"With\" ]( this === deferred ? newDefer : this, [ returned ] );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} :\n\t\t\t\t\t\t\t\tnewDefer[ action ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t}).promise();\n\t\t\t\t},\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn typeof obj === \"object\" ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Keep pipe for back-compat\n\t\tpromise.pipe = promise.then;\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 3 ];\n\n\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\tpromise[ tuple[1] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(function() {\n\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\tstate = stateString;\n\n\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n\t\t\t}\n\n\t\t\t// deferred[ resolve | reject | notify ] = list.fire\n\t\t\tdeferred[ tuple[0] ] = list.fire;\n\t\t\tdeferred[ tuple[0] + \"With\" ] = list.fireWith;\n\t\t});\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( subordinate /* , ..., subordinateN */ ) {\n\t\tvar i = 0,\n\t\t\tresolveValues = core_slice.call( arguments ),\n\t\t\tlength = resolveValues.length,\n\n\t\t\t// the count of uncompleted subordinates\n\t\t\tremaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n\t\t\t// the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n\t\t\t// Update function for both resolve and progress values\n\t\t\tupdateFunc = function( i, contexts, values ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tcontexts[ i ] = this;\n\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;\n\t\t\t\t\tif( values === progressValues ) {\n\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\n\t\t\t\t\t} else if ( !( --remaining ) ) {\n\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\tprogressValues, progressContexts, resolveContexts;\n\n\t\t// add listeners to Deferred subordinates; treat others as resolved\n\t\tif ( length > 1 ) {\n\t\t\tprogressValues = new Array( length );\n\t\t\tprogressContexts = new Array( length );\n\t\t\tresolveContexts = new Array( length );\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n\t\t\t\t\tresolveValues[ i ].promise()\n\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\n\t\t\t\t\t\t.fail( deferred.reject )\n\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) );\n\t\t\t\t} else {\n\t\t\t\t\t--remaining;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// if we're not waiting on anything, resolve the master\n\t\tif ( !remaining ) {\n\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\n\t\t}\n\n\t\treturn deferred.promise();\n\t}\n});\njQuery.support = (function() {\n\n\tvar support,\n\t\tall,\n\t\ta,\n\t\tselect,\n\t\topt,\n\t\tinput,\n\t\tfragment,\n\t\teventName,\n\t\ti,\n\t\tisSupported,\n\t\tclickFn,\n\t\tdiv = document.createElement(\"div\");\n\n\t// Preliminary tests\n\tdiv.setAttribute( \"className\", \"t\" );\n\tdiv.innerHTML = \"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\";\n\n\tall = div.getElementsByTagName(\"*\");\n\ta = div.getElementsByTagName(\"a\")[ 0 ];\n\ta.style.cssText = \"top:1px;float:left;opacity:.5\";\n\n\t// Can't get basic test support\n\tif ( !all || !all.length || !a ) {\n\t\treturn {};\n\t}\n\n\t// First batch of supports tests\n\tselect = document.createElement(\"select\");\n\topt = select.appendChild( document.createElement(\"option\") );\n\tinput = div.getElementsByTagName(\"input\")[ 0 ];\n\n\tsupport = {\n\t\t// IE strips leading whitespace when .innerHTML is used\n\t\tleadingWhitespace: ( div.firstChild.nodeType === 3 ),\n\n\t\t// Make sure that tbody elements aren't automatically inserted\n\t\t// IE will insert them into empty tables\n\t\ttbody: !div.getElementsByTagName(\"tbody\").length,\n\n\t\t// Make sure that link elements get serialized correctly by innerHTML\n\t\t// This requires a wrapper element in IE\n\t\thtmlSerialize: !!div.getElementsByTagName(\"link\").length,\n\n\t\t// Get the style information from getAttribute\n\t\t// (IE uses .cssText instead)\n\t\tstyle: /top/.test( a.getAttribute(\"style\") ),\n\n\t\t// Make sure that URLs aren't manipulated\n\t\t// (IE normalizes it by default)\n\t\threfNormalized: ( a.getAttribute(\"href\") === \"/a\" ),\n\n\t\t// Make sure that element opacity exists\n\t\t// (IE uses filter instead)\n\t\t// Use a regex to work around a WebKit issue. See #5145\n\t\topacity: /^0.5/.test( a.style.opacity ),\n\n\t\t// Verify style float existence\n\t\t// (IE uses styleFloat instead of cssFloat)\n\t\tcssFloat: !!a.style.cssFloat,\n\n\t\t// Make sure that if no value is specified for a checkbox\n\t\t// that it defaults to \"on\".\n\t\t// (WebKit defaults to \"\" instead)\n\t\tcheckOn: ( input.value === \"on\" ),\n\n\t\t// Make sure that a selected-by-default option has a working selected property.\n\t\t// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)\n\t\toptSelected: opt.selected,\n\n\t\t// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)\n\t\tgetSetAttribute: div.className !== \"t\",\n\n\t\t// Tests for enctype support on a form(#6743)\n\t\tenctype: !!document.createElement(\"form\").enctype,\n\n\t\t// Makes sure cloning an html5 element does not cause problems\n\t\t// Where outerHTML is undefined, this still works\n\t\thtml5Clone: document.createElement(\"nav\").cloneNode( true ).outerHTML !== \"<:nav></:nav>\",\n\n\t\t// jQuery.support.boxModel DEPRECATED in 1.8 since we don't support Quirks Mode\n\t\tboxModel: ( document.compatMode === \"CSS1Compat\" ),\n\n\t\t// Will be defined later\n\t\tsubmitBubbles: true,\n\t\tchangeBubbles: true,\n\t\tfocusinBubbles: false,\n\t\tdeleteExpando: true,\n\t\tnoCloneEvent: true,\n\t\tinlineBlockNeedsLayout: false,\n\t\tshrinkWrapBlocks: false,\n\t\treliableMarginRight: true,\n\t\tboxSizingReliable: true,\n\t\tpixelPosition: false\n\t};\n\n\t// Make sure checked status is properly cloned\n\tinput.checked = true;\n\tsupport.noCloneChecked = input.cloneNode( true ).checked;\n\n\t// Make sure that the options inside disabled selects aren't marked as disabled\n\t// (WebKit marks them as disabled)\n\tselect.disabled = true;\n\tsupport.optDisabled = !opt.disabled;\n\n\t// Test to see if it's possible to delete an expando from an element\n\t// Fails in Internet Explorer\n\ttry {\n\t\tdelete div.test;\n\t} catch( e ) {\n\t\tsupport.deleteExpando = false;\n\t}\n\n\tif ( !div.addEventListener && div.attachEvent && div.fireEvent ) {\n\t\tdiv.attachEvent( \"onclick\", clickFn = function() {\n\t\t\t// Cloning a node shouldn't copy over any\n\t\t\t// bound event handlers (IE does this)\n\t\t\tsupport.noCloneEvent = false;\n\t\t});\n\t\tdiv.cloneNode( true ).fireEvent(\"onclick\");\n\t\tdiv.detachEvent( \"onclick\", clickFn );\n\t}\n\n\t// Check if a radio maintains its value\n\t// after being appended to the DOM\n\tinput = document.createElement(\"input\");\n\tinput.value = \"t\";\n\tinput.setAttribute( \"type\", \"radio\" );\n\tsupport.radioValue = input.value === \"t\";\n\n\tinput.setAttribute( \"checked\", \"checked\" );\n\n\t// #11217 - WebKit loses check when the name is after the checked attribute\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tdiv.appendChild( input );\n\tfragment = document.createDocumentFragment();\n\tfragment.appendChild( div.lastChild );\n\n\t// WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Check if a disconnected checkbox will retain its checked\n\t// value of true after appended to the DOM (IE6/7)\n\tsupport.appendChecked = input.checked;\n\n\tfragment.removeChild( input );\n\tfragment.appendChild( div );\n\n\t// Technique from Juriy Zaytsev\n\t// http://perfectionkills.com/detecting-event-support-without-browser-sniffing/\n\t// We only care about the case where non-standard event systems\n\t// are used, namely in IE. Short-circuiting here helps us to\n\t// avoid an eval call (in setAttribute) which can cause CSP\n\t// to go haywire. See: https://developer.mozilla.org/en/Security/CSP\n\tif ( div.attachEvent ) {\n\t\tfor ( i in {\n\t\t\tsubmit: true,\n\t\t\tchange: true,\n\t\t\tfocusin: true\n\t\t}) {\n\t\t\teventName = \"on\" + i;\n\t\t\tisSupported = ( eventName in div );\n\t\t\tif ( !isSupported ) {\n\t\t\t\tdiv.setAttribute( eventName, \"return;\" );\n\t\t\t\tisSupported = ( typeof div[ eventName ] === \"function\" );\n\t\t\t}\n\t\t\tsupport[ i + \"Bubbles\" ] = isSupported;\n\t\t}\n\t}\n\n\t// Run tests that need a body at doc ready\n\tjQuery(function() {\n\t\tvar container, div, tds, marginDiv,\n\t\t\tdivReset = \"padding:0;margin:0;border:0;display:block;overflow:hidden;\",\n\t\t\tbody = document.getElementsByTagName(\"body\")[0];\n\n\t\tif ( !body ) {\n\t\t\t// Return for frameset docs that don't have a body\n\t\t\treturn;\n\t\t}\n\n\t\tcontainer = document.createElement(\"div\");\n\t\tcontainer.style.cssText = \"visibility:hidden;border:0;width:0;height:0;position:static;top:0;margin-top:1px\";\n\t\tbody.insertBefore( container, body.firstChild );\n\n\t\t// Construct the test element\n\t\tdiv = document.createElement(\"div\");\n\t\tcontainer.appendChild( div );\n\n\t\t// Check if table cells still have offsetWidth/Height when they are set\n\t\t// to display:none and there are still other visible table cells in a\n\t\t// table row; if so, offsetWidth/Height are not reliable for use when\n\t\t// determining if an element has been hidden directly using\n\t\t// display:none (it is still safe to use offsets if a parent element is\n\t\t// hidden; don safety goggles and see bug #4512 for more information).\n\t\t// (only IE 8 fails this test)\n\t\tdiv.innerHTML = \"<table><tr><td></td><td>t</td></tr></table>\";\n\t\ttds = div.getElementsByTagName(\"td\");\n\t\ttds[ 0 ].style.cssText = \"padding:0;margin:0;border:0;display:none\";\n\t\tisSupported = ( tds[ 0 ].offsetHeight === 0 );\n\n\t\ttds[ 0 ].style.display = \"\";\n\t\ttds[ 1 ].style.display = \"none\";\n\n\t\t// Check if empty table cells still have offsetWidth/Height\n\t\t// (IE <= 8 fail this test)\n\t\tsupport.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );\n\n\t\t// Check box-sizing and margin behavior\n\t\tdiv.innerHTML = \"\";\n\t\tdiv.style.cssText = \"box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;\";\n\t\tsupport.boxSizing = ( div.offsetWidth === 4 );\n\t\tsupport.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== 1 );\n\n\t\t// NOTE: To any future maintainer, we've window.getComputedStyle\n\t\t// because jsdom on node.js will break without it.\n\t\tif ( window.getComputedStyle ) {\n\t\t\tsupport.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== \"1%\";\n\t\t\tsupport.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: \"4px\" } ).width === \"4px\";\n\n\t\t\t// Check if div with explicit width and no margin-right incorrectly\n\t\t\t// gets computed margin-right based on width of container. For more\n\t\t\t// info see bug #3333\n\t\t\t// Fails in WebKit before Feb 2011 nightlies\n\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\tmarginDiv = document.createElement(\"div\");\n\t\t\tmarginDiv.style.cssText = div.style.cssText = divReset;\n\t\t\tmarginDiv.style.marginRight = marginDiv.style.width = \"0\";\n\t\t\tdiv.style.width = \"1px\";\n\t\t\tdiv.appendChild( marginDiv );\n\t\t\tsupport.reliableMarginRight =\n\t\t\t\t!parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );\n\t\t}\n\n\t\tif ( typeof div.style.zoom !== \"undefined\" ) {\n\t\t\t// Check if natively block-level elements act like inline-block\n\t\t\t// elements when setting their display to 'inline' and giving\n\t\t\t// them layout\n\t\t\t// (IE < 8 does this)\n\t\t\tdiv.innerHTML = \"\";\n\t\t\tdiv.style.cssText = divReset + \"width:1px;padding:1px;display:inline;zoom:1\";\n\t\t\tsupport.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );\n\n\t\t\t// Check if elements with layout shrink-wrap their children\n\t\t\t// (IE 6 does this)\n\t\t\tdiv.style.display = \"block\";\n\t\t\tdiv.style.overflow = \"visible\";\n\t\t\tdiv.innerHTML = \"<div></div>\";\n\t\t\tdiv.firstChild.style.width = \"5px\";\n\t\t\tsupport.shrinkWrapBlocks = ( div.offsetWidth !== 3 );\n\n\t\t\tcontainer.style.zoom = 1;\n\t\t}\n\n\t\t// Null elements to avoid leaks in IE\n\t\tbody.removeChild( container );\n\t\tcontainer = div = tds = marginDiv = null;\n\t});\n\n\t// Null elements to avoid leaks in IE\n\tfragment.removeChild( div );\n\tall = a = select = opt = input = fragment = div = null;\n\n\treturn support;\n})();\nvar rbrace = /(?:\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\])$/,\n\trmultiDash = /([A-Z])/g;\n\njQuery.extend({\n\tcache: {},\n\n\tdeletedIds: [],\n\n\t// Please use with caution\n\tuuid: 0,\n\n\t// Unique for each copy of jQuery on the page\n\t// Non-digits removed to match rinlinejQuery\n\texpando: \"jQuery\" + ( jQuery.fn.jquery + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// The following elements throw uncatchable exceptions if you\n\t// attempt to add expando properties to them.\n\tnoData: {\n\t\t\"embed\": true,\n\t\t// Ban all objects except for Flash (which handle expandos)\n\t\t\"object\": \"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\",\n\t\t\"applet\": true\n\t},\n\n\thasData: function( elem ) {\n\t\telem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];\n\t\treturn !!elem && !isEmptyDataObject( elem );\n\t},\n\n\tdata: function( elem, name, data, pvt /* Internal Use Only */ ) {\n\t\tif ( !jQuery.acceptData( elem ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar thisCache, ret,\n\t\t\tinternalKey = jQuery.expando,\n\t\t\tgetByName = typeof name === \"string\",\n\n\t\t\t// We have to handle DOM nodes and JS objects differently because IE6-7\n\t\t\t// can't GC object references properly across the DOM-JS boundary\n\t\t\tisNode = elem.nodeType,\n\n\t\t\t// Only DOM nodes need the global jQuery cache; JS object data is\n\t\t\t// attached directly to the object so GC can occur automatically\n\t\t\tcache = isNode ? jQuery.cache : elem,\n\n\t\t\t// Only defining an ID for JS objects if its cache already exists allows\n\t\t\t// the code to shortcut on the same path as a DOM node with no cache\n\t\t\tid = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;\n\n\t\t// Avoid doing any more work than we need to when trying to get data on an\n\t\t// object that has no data at all\n\t\tif ( (!id || !cache[id] || (!pvt && !cache[id].data)) && getByName && data === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !id ) {\n\t\t\t// Only DOM nodes need a new unique ID for each element since their data\n\t\t\t// ends up in the global cache\n\t\t\tif ( isNode ) {\n\t\t\t\telem[ internalKey ] = id = jQuery.deletedIds.pop() || ++jQuery.uuid;\n\t\t\t} else {\n\t\t\t\tid = internalKey;\n\t\t\t}\n\t\t}\n\n\t\tif ( !cache[ id ] ) {\n\t\t\tcache[ id ] = {};\n\n\t\t\t// Avoids exposing jQuery metadata on plain JS objects when the object\n\t\t\t// is serialized using JSON.stringify\n\t\t\tif ( !isNode ) {\n\t\t\t\tcache[ id ].toJSON = jQuery.noop;\n\t\t\t}\n\t\t}\n\n\t\t// An object can be passed to jQuery.data instead of a key/value pair; this gets\n\t\t// shallow copied over onto the existing cache\n\t\tif ( typeof name === \"object\" || typeof name === \"function\" ) {\n\t\t\tif ( pvt ) {\n\t\t\t\tcache[ id ] = jQuery.extend( cache[ id ], name );\n\t\t\t} else {\n\t\t\t\tcache[ id ].data = jQuery.extend( cache[ id ].data, name );\n\t\t\t}\n\t\t}\n\n\t\tthisCache = cache[ id ];\n\n\t\t// jQuery data() is stored in a separate object inside the object's internal data\n\t\t// cache in order to avoid key collisions between internal data and user-defined\n\t\t// data.\n\t\tif ( !pvt ) {\n\t\t\tif ( !thisCache.data ) {\n\t\t\t\tthisCache.data = {};\n\t\t\t}\n\n\t\t\tthisCache = thisCache.data;\n\t\t}\n\n\t\tif ( data !== undefined ) {\n\t\t\tthisCache[ jQuery.camelCase( name ) ] = data;\n\t\t}\n\n\t\t// Check for both converted-to-camel and non-converted data property names\n\t\t// If a data property was specified\n\t\tif ( getByName ) {\n\n\t\t\t// First Try to find as-is property data\n\t\t\tret = thisCache[ name ];\n\n\t\t\t// Test for null|undefined property data\n\t\t\tif ( ret == null ) {\n\n\t\t\t\t// Try to find the camelCased property\n\t\t\t\tret = thisCache[ jQuery.camelCase( name ) ];\n\t\t\t}\n\t\t} else {\n\t\t\tret = thisCache;\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tremoveData: function( elem, name, pvt /* Internal Use Only */ ) {\n\t\tif ( !jQuery.acceptData( elem ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar thisCache, i, l,\n\n\t\t\tisNode = elem.nodeType,\n\n\t\t\t// See jQuery.data for more information\n\t\t\tcache = isNode ? jQuery.cache : elem,\n\t\t\tid = isNode ? elem[ jQuery.expando ] : jQuery.expando;\n\n\t\t// If there is already no cache entry for this object, there is no\n\t\t// purpose in continuing\n\t\tif ( !cache[ id ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( name ) {\n\n\t\t\tthisCache = pvt ? cache[ id ] : cache[ id ].data;\n\n\t\t\tif ( thisCache ) {\n\n\t\t\t\t// Support array or space separated string names for data keys\n\t\t\t\tif ( !jQuery.isArray( name ) ) {\n\n\t\t\t\t\t// try the string as a key before any manipulation\n\t\t\t\t\tif ( name in thisCache ) {\n\t\t\t\t\t\tname = [ name ];\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// split the camel cased version by spaces unless a key with the spaces exists\n\t\t\t\t\t\tname = jQuery.camelCase( name );\n\t\t\t\t\t\tif ( name in thisCache ) {\n\t\t\t\t\t\t\tname = [ name ];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tname = name.split(\" \");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0, l = name.length; i < l; i++ ) {\n\t\t\t\t\tdelete thisCache[ name[i] ];\n\t\t\t\t}\n\n\t\t\t\t// If there is no data left in the cache, we want to continue\n\t\t\t\t// and let the cache object itself get destroyed\n\t\t\t\tif ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// See jQuery.data for more information\n\t\tif ( !pvt ) {\n\t\t\tdelete cache[ id ].data;\n\n\t\t\t// Don't destroy the parent cache unless the internal data object\n\t\t\t// had been the only thing left in it\n\t\t\tif ( !isEmptyDataObject( cache[ id ] ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Destroy the cache\n\t\tif ( isNode ) {\n\t\t\tjQuery.cleanData( [ elem ], true );\n\n\t\t// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)\n\t\t} else if ( jQuery.support.deleteExpando || cache != cache.window ) {\n\t\t\tdelete cache[ id ];\n\n\t\t// When all else fails, null\n\t\t} else {\n\t\t\tcache[ id ] = null;\n\t\t}\n\t},\n\n\t// For internal use only.\n\t_data: function( elem, name, data ) {\n\t\treturn jQuery.data( elem, name, data, true );\n\t},\n\n\t// A method for determining if a DOM node can handle the data expando\n\tacceptData: function( elem ) {\n\t\tvar noData = elem.nodeName && jQuery.noData[ elem.nodeName.toLowerCase() ];\n\n\t\t// nodes accept data unless otherwise specified; rejection can be conditional\n\t\treturn !noData || noData !== true && elem.getAttribute(\"classid\") === noData;\n\t}\n});\n\njQuery.fn.extend({\n\tdata: function( key, value ) {\n\t\tvar parts, part, attr, name, l,\n\t\t\telem = this[0],\n\t\t\ti = 0,\n\t\t\tdata = null;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = jQuery.data( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !jQuery._data( elem, \"parsedAttrs\" ) ) {\n\t\t\t\t\tattr = elem.attributes;\n\t\t\t\t\tfor ( l = attr.length; i < l; i++ ) {\n\t\t\t\t\t\tname = attr[i].name;\n\n\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\tname = jQuery.camelCase( name.substring(5) );\n\n\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tjQuery._data( elem, \"parsedAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tjQuery.data( this, key );\n\t\t\t});\n\t\t}\n\n\t\tparts = key.split( \".\", 2 );\n\t\tparts[1] = parts[1] ? \".\" + parts[1] : \"\";\n\t\tpart = parts[1] + \"!\";\n\n\t\treturn jQuery.access( this, function( value ) {\n\n\t\t\tif ( value === undefined ) {\n\t\t\t\tdata = this.triggerHandler( \"getData\" + part, [ parts[0] ] );\n\n\t\t\t\t// Try to fetch any internally stored data first\n\t\t\t\tif ( data === undefined && elem ) {\n\t\t\t\t\tdata = jQuery.data( elem, key );\n\t\t\t\t\tdata = dataAttr( elem, key, data );\n\t\t\t\t}\n\n\t\t\t\treturn data === undefined && parts[1] ?\n\t\t\t\t\tthis.data( parts[0] ) :\n\t\t\t\t\tdata;\n\t\t\t}\n\n\t\t\tparts[1] = value;\n\t\t\tthis.each(function() {\n\t\t\t\tvar self = jQuery( this );\n\n\t\t\t\tself.triggerHandler( \"setData\" + part, parts );\n\t\t\t\tjQuery.data( this, key, value );\n\t\t\t\tself.triggerHandler( \"changeData\" + part, parts );\n\t\t\t});\n\t\t}, null, value, arguments.length > 1, null, false );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.removeData( this, key );\n\t\t});\n\t}\n});\n\nfunction dataAttr( elem, key, data ) {\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\n\t\tvar name = \"data-\" + key.replace( rmultiDash, \"-$1\" ).toLowerCase();\n\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = data === \"true\" ? true :\n\t\t\t\tdata === \"false\" ? false :\n\t\t\t\tdata === \"null\" ? null :\n\t\t\t\t// Only convert to a number if it doesn't change the string\n\t\t\t\t+data + \"\" === data ? +data :\n\t\t\t\trbrace.test( data ) ? jQuery.parseJSON( data ) :\n\t\t\t\t\tdata;\n\t\t\t} catch( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tjQuery.data( elem, key, data );\n\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\n\treturn data;\n}\n\n// checks a cache object for emptiness\nfunction isEmptyDataObject( obj ) {\n\tvar name;\n\tfor ( name in obj ) {\n\n\t\t// if the public data object is empty, the private is still empty\n\t\tif ( name === \"data\" && jQuery.isEmptyObject( obj[name] ) ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( name !== \"toJSON\" ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\njQuery.extend({\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = jQuery._data( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || jQuery.isArray(data) ) {\n\t\t\t\t\tqueue = jQuery._data( elem, type, jQuery.makeArray(data) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// not intended for public consumption - generates a queueHooks object, or returns the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn jQuery._data( elem, key ) || jQuery._data( elem, key, {\n\t\t\tempty: jQuery.Callbacks(\"once memory\").add(function() {\n\t\t\t\tjQuery.removeData( elem, type + \"queue\", true );\n\t\t\t\tjQuery.removeData( elem, key, true );\n\t\t\t})\n\t\t});\n\t}\n});\n\njQuery.fn.extend({\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[0], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each(function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[0] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t});\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t});\n\t},\n\t// Based off of the plugin by Clint Helfers, with permission.\n\t// http://blindsignals.com/index.php/2009/07/jquery-delay/\n\tdelay: function( time, type ) {\n\t\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\t\ttype = type || \"fx\";\n\n\t\treturn this.queue( type, function( next, hooks ) {\n\t\t\tvar timeout = setTimeout( next, time );\n\t\t\thooks.stop = function() {\n\t\t\t\tclearTimeout( timeout );\n\t\t\t};\n\t\t});\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile( i-- ) {\n\t\t\ttmp = jQuery._data( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n});\nvar nodeHook, boolHook, fixSpecified,\n\trclass = /[\\t\\r\\n]/g,\n\trreturn = /\\r/g,\n\trtype = /^(?:button|input)$/i,\n\trfocusable = /^(?:button|input|object|select|textarea)$/i,\n\trclickable = /^a(?:rea|)$/i,\n\trboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,\n\tgetSetAttribute = jQuery.support.getSetAttribute;\n\njQuery.fn.extend({\n\tattr: function( name, value ) {\n\t\treturn jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t});\n\t},\n\n\tprop: function( name, value ) {\n\t\treturn jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\tname = jQuery.propFix[ name ] || name;\n\t\treturn this.each(function() {\n\t\t\t// try/catch handles cases where IE balks (such as removing a property on window)\n\t\t\ttry {\n\t\t\t\tthis[ name ] = undefined;\n\t\t\t\tdelete this[ name ];\n\t\t\t} catch( e ) {}\n\t\t});\n\t},\n\n\taddClass: function( value ) {\n\t\tvar classNames, i, l, elem,\n\t\t\tsetClass, c, cl;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call(this, j, this.className) );\n\t\t\t});\n\t\t}\n\n\t\tif ( value && typeof value === \"string\" ) {\n\t\t\tclassNames = value.split( core_rspace );\n\n\t\t\tfor ( i = 0, l = this.length; i < l; i++ ) {\n\t\t\t\telem = this[ i ];\n\n\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\tif ( !elem.className && classNames.length === 1 ) {\n\t\t\t\t\t\telem.className = value;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsetClass = \" \" + elem.className + \" \";\n\n\t\t\t\t\t\tfor ( c = 0, cl = classNames.length; c < cl; c++ ) {\n\t\t\t\t\t\t\tif ( !~setClass.indexOf( \" \" + classNames[ c ] + \" \" ) ) {\n\t\t\t\t\t\t\t\tsetClass += classNames[ c ] + \" \";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telem.className = jQuery.trim( setClass );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar removes, className, elem, c, cl, i, l;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call(this, j, this.className) );\n\t\t\t});\n\t\t}\n\t\tif ( (value && typeof value === \"string\") || value === undefined ) {\n\t\t\tremoves = ( value || \"\" ).split( core_rspace );\n\n\t\t\tfor ( i = 0, l = this.length; i < l; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\tif ( elem.nodeType === 1 && elem.className ) {\n\n\t\t\t\t\tclassName = (\" \" + elem.className + \" \").replace( rclass, \" \" );\n\n\t\t\t\t\t// loop over each item in the removal list\n\t\t\t\t\tfor ( c = 0, cl = removes.length; c < cl; c++ ) {\n\t\t\t\t\t\t// Remove until there is nothing to remove,\n\t\t\t\t\t\twhile ( className.indexOf(\" \" + removes[ c ] + \" \") > -1 ) {\n\t\t\t\t\t\t\tclassName = className.replace( \" \" + removes[ c ] + \" \" , \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telem.className = value ? jQuery.trim( className ) : \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value,\n\t\t\tisBool = typeof stateVal === \"boolean\";\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( type === \"string\" ) {\n\t\t\t\t// toggle individual class names\n\t\t\t\tvar className,\n\t\t\t\t\ti = 0,\n\t\t\t\t\tself = jQuery( this ),\n\t\t\t\t\tstate = stateVal,\n\t\t\t\t\tclassNames = value.split( core_rspace );\n\n\t\t\t\twhile ( (className = classNames[ i++ ]) ) {\n\t\t\t\t\t// check each className given, space separated list\n\t\t\t\t\tstate = isBool ? state : !self.hasClass( className );\n\t\t\t\t\tself[ state ? \"addClass\" : \"removeClass\" ]( className );\n\t\t\t\t}\n\n\t\t\t} else if ( type === \"undefined\" || type === \"boolean\" ) {\n\t\t\t\tif ( this.className ) {\n\t\t\t\t\t// store className if set\n\t\t\t\t\tjQuery._data( this, \"__className__\", this.className );\n\t\t\t\t}\n\n\t\t\t\t// toggle whole className\n\t\t\t\tthis.className = this.className || value === false ? \"\" : jQuery._data( this, \"__className__\" ) || \"\";\n\t\t\t}\n\t\t});\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className = \" \" + selector + \" \",\n\t\t\ti = 0,\n\t\t\tl = this.length;\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tif ( this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf( className ) > -1 ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t},\n\n\tval: function( value ) {\n\t\tvar hooks, ret, isFunction,\n\t\t\telem = this[0];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, \"value\" )) !== undefined ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\treturn typeof ret === \"string\" ?\n\t\t\t\t\t// handle most common string cases\n\t\t\t\t\tret.replace(rreturn, \"\") :\n\t\t\t\t\t// handle cases where value is null/undef or number\n\t\t\t\t\tret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tisFunction = jQuery.isFunction( value );\n\n\t\treturn this.each(function( i ) {\n\t\t\tvar val,\n\t\t\t\tself = jQuery(this);\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isFunction ) {\n\t\t\t\tval = value.call( this, i, self.val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\tval = jQuery.map(val, function ( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t});\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !(\"set\" in hooks) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\t\t\t\t// attributes.value is undefined in Blackberry 4.7 but\n\t\t\t\t// uses .value. See #6932\n\t\t\t\tvar val = elem.attributes.value;\n\t\t\t\treturn !val || val.specified ? elem.value : elem.text;\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, i, max, option,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tvalues = [],\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tone = elem.type === \"select-one\";\n\n\t\t\t\t// Nothing was selected\n\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\ti = one ? index : 0;\n\t\t\t\tmax = one ? index + 1 : options.length;\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\tif ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute(\"disabled\") === null) &&\n\t\t\t\t\t\t\t(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, \"optgroup\" )) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Fixes Bug #2551 -- select.val() broken in IE after form.reset()\n\t\t\t\tif ( one && !values.length && options.length ) {\n\t\t\t\t\treturn jQuery( options[ index ] ).val();\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar values = jQuery.makeArray( value );\n\n\t\t\t\tjQuery(elem).find(\"option\").each(function() {\n\t\t\t\t\tthis.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;\n\t\t\t\t});\n\n\t\t\t\tif ( !values.length ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t},\n\n\t// Unused in 1.8, left in so attrFn-stabbers won't die; remove in 1.9\n\tattrFn: {},\n\n\tattr: function( elem, name, value, pass ) {\n\t\tvar ret, hooks, notxml,\n\t\t\tnType = elem.nodeType;\n\n\t\t// don't get/set attributes on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( pass && jQuery.isFunction( jQuery.fn[ name ] ) ) {\n\t\t\treturn jQuery( elem )[ name ]( value );\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\tnotxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n\n\t\t// All attributes are lowercase\n\t\t// Grab necessary hook if one is defined\n\t\tif ( notxml ) {\n\t\t\tname = name.toLowerCase();\n\t\t\thooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\treturn;\n\n\t\t\t} else if ( hooks && \"set\" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {\n\t\t\t\treturn ret;\n\n\t\t\t} else {\n\t\t\t\telem.setAttribute( name, \"\" + value );\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t} else if ( hooks && \"get\" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {\n\t\t\treturn ret;\n\n\t\t} else {\n\n\t\t\tret = elem.getAttribute( name );\n\n\t\t\t// Non-existent attributes return null, we normalize to undefined\n\t\t\treturn ret === null ?\n\t\t\t\tundefined :\n\t\t\t\tret;\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar propName, attrNames, name, isBool,\n\t\t\ti = 0;\n\n\t\tif ( value && elem.nodeType === 1 ) {\n\n\t\t\tattrNames = value.split( core_rspace );\n\n\t\t\tfor ( ; i < attrNames.length; i++ ) {\n\t\t\t\tname = attrNames[ i ];\n\n\t\t\t\tif ( name ) {\n\t\t\t\t\tpropName = jQuery.propFix[ name ] || name;\n\t\t\t\t\tisBool = rboolean.test( name );\n\n\t\t\t\t\t// See #9699 for explanation of this approach (setting first, then removal)\n\t\t\t\t\t// Do not do this for boolean attributes (see #10870)\n\t\t\t\t\tif ( !isBool ) {\n\t\t\t\t\t\tjQuery.attr( elem, name, \"\" );\n\t\t\t\t\t}\n\t\t\t\t\telem.removeAttribute( getSetAttribute ? name : propName );\n\n\t\t\t\t\t// Set corresponding property to false for boolean attributes\n\t\t\t\t\tif ( isBool && propName in elem ) {\n\t\t\t\t\t\telem[ propName ] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\t// We can't allow the type property to be changed (since it causes problems in IE)\n\t\t\t\tif ( rtype.test( elem.nodeName ) && elem.parentNode ) {\n\t\t\t\t\tjQuery.error( \"type property can't be changed\" );\n\t\t\t\t} else if ( !jQuery.support.radioValue && value === \"radio\" && jQuery.nodeName(elem, \"input\") ) {\n\t\t\t\t\t// Setting the type on a radio button after the value resets the value in IE6-9\n\t\t\t\t\t// Reset value to it's default in case type is set after value\n\t\t\t\t\t// This is for element creation\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// Use the value property for back compat\n\t\t// Use the nodeHook for button elements in IE6/7 (#1954)\n\t\tvalue: {\n\t\t\tget: function( elem, name ) {\n\t\t\t\tif ( nodeHook && jQuery.nodeName( elem, \"button\" ) ) {\n\t\t\t\t\treturn nodeHook.get( elem, name );\n\t\t\t\t}\n\t\t\t\treturn name in elem ?\n\t\t\t\t\telem.value :\n\t\t\t\t\tnull;\n\t\t\t},\n\t\t\tset: function( elem, value, name ) {\n\t\t\t\tif ( nodeHook && jQuery.nodeName( elem, \"button\" ) ) {\n\t\t\t\t\treturn nodeHook.set( elem, value, name );\n\t\t\t\t}\n\t\t\t\t// Does not return so that setAttribute is also used\n\t\t\t\telem.value = value;\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\ttabindex: \"tabIndex\",\n\t\treadonly: \"readOnly\",\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\",\n\t\tmaxlength: \"maxLength\",\n\t\tcellspacing: \"cellSpacing\",\n\t\tcellpadding: \"cellPadding\",\n\t\trowspan: \"rowSpan\",\n\t\tcolspan: \"colSpan\",\n\t\tusemap: \"useMap\",\n\t\tframeborder: \"frameBorder\",\n\t\tcontenteditable: \"contentEditable\"\n\t},\n\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks, notxml,\n\t\t\tnType = elem.nodeType;\n\n\t\t// don't get/set properties on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tnotxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n\n\t\tif ( notxml ) {\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\n\t\t\t\treturn ret;\n\n\t\t\t} else {\n\t\t\t\treturn ( elem[ name ] = value );\n\t\t\t}\n\n\t\t} else {\n\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ) {\n\t\t\t\treturn ret;\n\n\t\t\t} else {\n\t\t\t\treturn elem[ name ];\n\t\t\t}\n\t\t}\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\t\t\t\t// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set\n\t\t\t\t// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\tvar attributeNode = elem.getAttributeNode(\"tabindex\");\n\n\t\t\t\treturn attributeNode && attributeNode.specified ?\n\t\t\t\t\tparseInt( attributeNode.value, 10 ) :\n\t\t\t\t\trfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?\n\t\t\t\t\t\t0 :\n\t\t\t\t\t\tundefined;\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Hook for boolean attributes\nboolHook = {\n\tget: function( elem, name ) {\n\t\t// Align boolean attributes with corresponding properties\n\t\t// Fall back to attribute presence where some booleans are not supported\n\t\tvar attrNode,\n\t\t\tproperty = jQuery.prop( elem, name );\n\t\treturn property === true || typeof property !== \"boolean\" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?\n\t\t\tname.toLowerCase() :\n\t\t\tundefined;\n\t},\n\tset: function( elem, value, name ) {\n\t\tvar propName;\n\t\tif ( value === false ) {\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\t// value is true since we know at this point it's type boolean and not false\n\t\t\t// Set boolean attributes to the same name and set the DOM property\n\t\t\tpropName = jQuery.propFix[ name ] || name;\n\t\t\tif ( propName in elem ) {\n\t\t\t\t// Only set the IDL specifically if it already exists on the element\n\t\t\t\telem[ propName ] = true;\n\t\t\t}\n\n\t\t\telem.setAttribute( name, name.toLowerCase() );\n\t\t}\n\t\treturn name;\n\t}\n};\n\n// IE6/7 do not support getting/setting some attributes with get/setAttribute\nif ( !getSetAttribute ) {\n\n\tfixSpecified = {\n\t\tname: true,\n\t\tid: true,\n\t\tcoords: true\n\t};\n\n\t// Use this for any attribute in IE6/7\n\t// This fixes almost every IE6/7 issue\n\tnodeHook = jQuery.valHooks.button = {\n\t\tget: function( elem, name ) {\n\t\t\tvar ret;\n\t\t\tret = elem.getAttributeNode( name );\n\t\t\treturn ret && ( fixSpecified[ name ] ? ret.value !== \"\" : ret.specified ) ?\n\t\t\t\tret.value :\n\t\t\t\tundefined;\n\t\t},\n\t\tset: function( elem, value, name ) {\n\t\t\t// Set the existing or create a new attribute node\n\t\t\tvar ret = elem.getAttributeNode( name );\n\t\t\tif ( !ret ) {\n\t\t\t\tret = document.createAttribute( name );\n\t\t\t\telem.setAttributeNode( ret );\n\t\t\t}\n\t\t\treturn ( ret.value = value + \"\" );\n\t\t}\n\t};\n\n\t// Set width and height to auto instead of 0 on empty string( Bug #8150 )\n\t// This is for removals\n\tjQuery.each([ \"width\", \"height\" ], function( i, name ) {\n\t\tjQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( value === \"\" ) {\n\t\t\t\t\telem.setAttribute( name, \"auto\" );\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n\n\t// Set contenteditable to false on removals(#10429)\n\t// Setting to empty string throws an error as an invalid value\n\tjQuery.attrHooks.contenteditable = {\n\t\tget: nodeHook.get,\n\t\tset: function( elem, value, name ) {\n\t\t\tif ( value === \"\" ) {\n\t\t\t\tvalue = \"false\";\n\t\t\t}\n\t\t\tnodeHook.set( elem, value, name );\n\t\t}\n\t};\n}\n\n\n// Some attributes require a special call on IE\nif ( !jQuery.support.hrefNormalized ) {\n\tjQuery.each([ \"href\", \"src\", \"width\", \"height\" ], function( i, name ) {\n\t\tjQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar ret = elem.getAttribute( name, 2 );\n\t\t\t\treturn ret === null ? undefined : ret;\n\t\t\t}\n\t\t});\n\t});\n}\n\nif ( !jQuery.support.style ) {\n\tjQuery.attrHooks.style = {\n\t\tget: function( elem ) {\n\t\t\t// Return undefined in the case of empty string\n\t\t\t// Normalize to lowercase since IE uppercases css property names\n\t\t\treturn elem.style.cssText.toLowerCase() || undefined;\n\t\t},\n\t\tset: function( elem, value ) {\n\t\t\treturn ( elem.style.cssText = \"\" + value );\n\t\t}\n\t};\n}\n\n// Safari mis-reports the default selected property of an option\n// Accessing the parent's selectedIndex property fixes it\nif ( !jQuery.support.optSelected ) {\n\tjQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {\n\t\tget: function( elem ) {\n\t\t\tvar parent = elem.parentNode;\n\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\t// Make sure that it also works with optgroups, see #5701\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t});\n}\n\n// IE6/7 call enctype encoding\nif ( !jQuery.support.enctype ) {\n\tjQuery.propFix.enctype = \"encoding\";\n}\n\n// Radios and checkboxes getter/setter\nif ( !jQuery.support.checkOn ) {\n\tjQuery.each([ \"radio\", \"checkbox\" ], function() {\n\t\tjQuery.valHooks[ this ] = {\n\t\t\tget: function( elem ) {\n\t\t\t\t// Handle the case where in Webkit \"\" is returned instead of \"on\" if a value isn't specified\n\t\t\t\treturn elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n\t\t\t}\n\t\t};\n\t});\n}\njQuery.each([ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {\n\t\tset: function( elem, value ) {\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );\n\t\t\t}\n\t\t}\n\t});\n});\nvar rformElems = /^(?:textarea|input|select)$/i,\n\trtypenamespace = /^([^\\.]*|)(?:\\.(.+)|)$/,\n\trhoverHack = /(?:^|\\s)hover(\\.\\S+|)\\b/,\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|contextmenu)|click/,\n\trfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\thoverHack = function( events ) {\n\t\treturn jQuery.event.special.hover ? events : events.replace( rhoverHack, \"mouseenter$1 mouseleave$1\" );\n\t};\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar elemData, eventHandle, events,\n\t\t\tt, tns, type, namespaces, handleObj,\n\t\t\thandleObjIn, handlers, special;\n\n\t\t// Don't attach events to noData or text/comment nodes (allow plain objects tho)\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tevents = elemData.events;\n\t\tif ( !events ) {\n\t\t\telemData.events = events = {};\n\t\t}\n\t\teventHandle = elemData.handle;\n\t\tif ( !eventHandle ) {\n\t\t\telemData.handle = eventHandle = function( e ) {\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== \"undefined\" && (!e || jQuery.event.triggered !== e.type) ?\n\t\t\t\t\tjQuery.event.dispatch.apply( eventHandle.elem, arguments ) :\n\t\t\t\t\tundefined;\n\t\t\t};\n\t\t\t// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events\n\t\t\teventHandle.elem = elem;\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\t// jQuery(...).bind(\"mouseover mouseout\", fn);\n\t\ttypes = jQuery.trim( hoverHack(types) ).split( \" \" );\n\t\tfor ( t = 0; t < types.length; t++ ) {\n\n\t\t\ttns = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = tns[1];\n\t\t\tnamespaces = ( tns[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend({\n\t\t\t\ttype: type,\n\t\t\t\torigType: tns[1],\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tnamespace: namespaces.join(\".\")\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\thandlers = events[ type ];\n\t\t\tif ( !handlers ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener/attachEvent if the special events handler returns false\n\t\t\t\tif ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\t\t\t\t\t// Bind the global event handler to the element\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle, false );\n\n\t\t\t\t\t} else if ( elem.attachEvent ) {\n\t\t\t\t\t\telem.attachEvent( \"on\" + type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t\t// Nullify elem to prevent memory leaks in IE\n\t\telem = null;\n\t},\n\n\tglobal: {},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar t, tns, type, origType, namespaces, origCount,\n\t\t\tj, events, special, eventType, handleObj,\n\t\t\telemData = jQuery.hasData( elem ) && jQuery._data( elem );\n\n\t\tif ( !elemData || !(events = elemData.events) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = jQuery.trim( hoverHack( types || \"\" ) ).split(\" \");\n\t\tfor ( t = 0; t < types.length; t++ ) {\n\t\t\ttns = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tns[1];\n\t\t\tnamespaces = tns[2];\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector? special.delegateType : special.bindType ) || type;\n\t\t\teventType = events[ type ] || [];\n\t\t\torigCount = eventType.length;\n\t\t\tnamespaces = namespaces ? new RegExp(\"(^|\\\\.)\" + namespaces.split(\".\").sort().join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null;\n\n\t\t\t// Remove matching events\n\t\t\tfor ( j = 0; j < eventType.length; j++ ) {\n\t\t\t\thandleObj = eventType[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t ( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t ( !namespaces || namespaces.test( handleObj.namespace ) ) &&\n\t\t\t\t\t ( !selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\teventType.splice( j--, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\teventType.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( eventType.length === 0 && origCount !== eventType.length ) {\n\t\t\t\tif ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdelete elemData.handle;\n\n\t\t\t// removeData also checks for emptiness and clears the expando if empty\n\t\t\t// so use it instead of delete\n\t\t\tjQuery.removeData( elem, \"events\", true );\n\t\t}\n\t},\n\n\t// Events that are safe to short-circuit if no handlers are attached.\n\t// Native DOM events should not be added, they may have inline handlers.\n\tcustomEvent: {\n\t\t\"getData\": true,\n\t\t\"setData\": true,\n\t\t\"changeData\": true\n\t},\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Event object or event type\n\t\tvar cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType,\n\t\t\ttype = event.type || event,\n\t\t\tnamespaces = [];\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf( \"!\" ) >= 0 ) {\n\t\t\t// Exclusive events trigger only for the exact event (no namespaces)\n\t\t\ttype = type.slice(0, -1);\n\t\t\texclusive = true;\n\t\t}\n\n\t\tif ( type.indexOf( \".\" ) >= 0 ) {\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split(\".\");\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\n\t\tif ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {\n\t\t\t// No jQuery handlers for this event type, and it can't have inline handlers\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an Event, Object, or just an event type string\n\t\tevent = typeof event === \"object\" ?\n\t\t\t// jQuery.Event object\n\t\t\tevent[ jQuery.expando ] ? event :\n\t\t\t// Object literal\n\t\t\tnew jQuery.Event( type, event ) :\n\t\t\t// Just the event type (string)\n\t\t\tnew jQuery.Event( type );\n\n\t\tevent.type = type;\n\t\tevent.isTrigger = true;\n\t\tevent.exclusive = exclusive;\n\t\tevent.namespace = namespaces.join( \".\" );\n\t\tevent.namespace_re = event.namespace? new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null;\n\t\tontype = type.indexOf( \":\" ) < 0 ? \"on\" + type : \"\";\n\n\t\t// Handle a global trigger\n\t\tif ( !elem ) {\n\n\t\t\t// TODO: Stop taunting the data cache; remove global events and always attach to document\n\t\t\tcache = jQuery.cache;\n\t\t\tfor ( i in cache ) {\n\t\t\t\tif ( cache[ i ].events && cache[ i ].events[ type ] ) {\n\t\t\t\t\tjQuery.event.trigger( event, data, cache[ i ].handle.elem, true );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data != null ? jQuery.makeArray( data ) : [];\n\t\tdata.unshift( event );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\teventPath = [[ elem, special.bindType || type ]];\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tcur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;\n\t\t\tfor ( old = elem; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push([ cur, bubbleType ]);\n\t\t\t\told = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( old === (elem.ownerDocument || document) ) {\n\t\t\t\teventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\tfor ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {\n\n\t\t\tcur = eventPath[i][0];\n\t\t\tevent.type = eventPath[i][1];\n\n\t\t\thandle = ( jQuery._data( cur, \"events\" ) || {} )[ event.type ] && jQuery._data( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\t\t\t// Note that this is a bare JS function and not a jQuery handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && jQuery.acceptData( cur ) && handle.apply( cur, data ) === false ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&\n\t\t\t\t!(type === \"click\" && jQuery.nodeName( elem, \"a\" )) && jQuery.acceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name name as the event.\n\t\t\t\t// Can't use an .isFunction() check here because IE6/7 fails that test.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\t// IE<9 dies on focus/blur to hidden element (#1486)\n\t\t\t\tif ( ontype && elem[ type ] && ((type !== \"focus\" && type !== \"blur\") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\told = elem[ ontype ];\n\n\t\t\t\t\tif ( old ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\telem[ type ]();\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( old ) {\n\t\t\t\t\t\telem[ ontype ] = old;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\tdispatch: function( event ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tevent = jQuery.event.fix( event || window.event );\n\n\t\tvar i, j, cur, ret, selMatch, matched, matches, handleObj, sel, related,\n\t\t\thandlers = ( (jQuery._data( this, \"events\" ) || {} )[ event.type ] || []),\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\targs = [].slice.call( arguments ),\n\t\t\trun_all = !event.exclusive && !event.namespace,\n\t\t\tspecial = jQuery.event.special[ event.type ] || {},\n\t\t\thandlerQueue = [];\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[0] = event;\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers that should run if there are delegated events\n\t\t// Avoid non-left-click bubbling in Firefox (#3861)\n\t\tif ( delegateCount && !(event.button && event.type === \"click\") ) {\n\n\t\t\tfor ( cur = event.target; cur != this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't process clicks (ONLY) on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.disabled !== true || event.type !== \"click\" ) {\n\t\t\t\t\tselMatch = {};\n\t\t\t\t\tmatches = [];\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\t\t\t\t\t\tsel = handleObj.selector;\n\n\t\t\t\t\t\tif ( selMatch[ sel ] === undefined ) {\n\t\t\t\t\t\t\tselMatch[ sel ] = jQuery( sel, this ).index( cur ) >= 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( selMatch[ sel ] ) {\n\t\t\t\t\t\t\tmatches.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matches.length ) {\n\t\t\t\t\t\thandlerQueue.push({ elem: cur, matches: matches });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tif ( handlers.length > delegateCount ) {\n\t\t\thandlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });\n\t\t}\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\tfor ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {\n\t\t\tmatched = handlerQueue[ i ];\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tfor ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {\n\t\t\t\thandleObj = matched.matches[ j ];\n\n\t\t\t\t// Triggered event must either 1) be non-exclusive and have no namespace, or\n\t\t\t\t// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.data = handleObj.data;\n\t\t\t\t\tevent.handleObj = handleObj;\n\n\t\t\t\t\tret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )\n\t\t\t\t\t\t\t.apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tevent.result = ret;\n\t\t\t\t\t\tif ( ret === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\t// Includes some event props shared by KeyEvent and MouseEvent\n\t// *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***\n\tprops: \"attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n\n\tfixHooks: {},\n\n\tkeyHooks: {\n\t\tprops: \"char charCode key keyCode\".split(\" \"),\n\t\tfilter: function( event, original ) {\n\n\t\t\t// Add which for key events\n\t\t\tif ( event.which == null ) {\n\t\t\t\tevent.which = original.charCode != null ? original.charCode : original.keyCode;\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tmouseHooks: {\n\t\tprops: \"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n\t\tfilter: function( event, original ) {\n\t\t\tvar eventDoc, doc, body,\n\t\t\t\tbutton = original.button,\n\t\t\t\tfromElement = original.fromElement;\n\n\t\t\t// Calculate pageX/Y if missing and clientX/Y available\n\t\t\tif ( event.pageX == null && original.clientX != null ) {\n\t\t\t\teventDoc = event.target.ownerDocument || document;\n\t\t\t\tdoc = eventDoc.documentElement;\n\t\t\t\tbody = eventDoc.body;\n\n\t\t\t\tevent.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );\n\t\t\t\tevent.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );\n\t\t\t}\n\n\t\t\t// Add relatedTarget, if necessary\n\t\t\tif ( !event.relatedTarget && fromElement ) {\n\t\t\t\tevent.relatedTarget = fromElement === event.target ? original.toElement : fromElement;\n\t\t\t}\n\n\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t\t// Note: button is not normalized, so don't use it\n\t\t\tif ( !event.which && button !== undefined ) {\n\t\t\t\tevent.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tfix: function( event ) {\n\t\tif ( event[ jQuery.expando ] ) {\n\t\t\treturn event;\n\t\t}\n\n\t\t// Create a writable copy of the event object and normalize some properties\n\t\tvar i, prop,\n\t\t\toriginalEvent = event,\n\t\t\tfixHook = jQuery.event.fixHooks[ event.type ] || {},\n\t\t\tcopy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\n\n\t\tevent = jQuery.Event( originalEvent );\n\n\t\tfor ( i = copy.length; i; ) {\n\t\t\tprop = copy[ --i ];\n\t\t\tevent[ prop ] = originalEvent[ prop ];\n\t\t}\n\n\t\t// Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)\n\t\tif ( !event.target ) {\n\t\t\tevent.target = originalEvent.srcElement || document;\n\t\t}\n\n\t\t// Target should not be a text node (#504, Safari)\n\t\tif ( event.target.nodeType === 3 ) {\n\t\t\tevent.target = event.target.parentNode;\n\t\t}\n\n\t\t// For mouse/key events, metaKey==false if it's undefined (#3368, #11328; IE6/7/8)\n\t\tevent.metaKey = !!event.metaKey;\n\n\t\treturn fixHook.filter? fixHook.filter( event, originalEvent ) : event;\n\t},\n\n\tspecial: {\n\t\tload: {\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\n\t\tfocus: {\n\t\t\tdelegateType: \"focusin\"\n\t\t},\n\t\tblur: {\n\t\t\tdelegateType: \"focusout\"\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tsetup: function( data, namespaces, eventHandle ) {\n\t\t\t\t// We only want to do this special case on windows\n\t\t\t\tif ( jQuery.isWindow( this ) ) {\n\t\t\t\t\tthis.onbeforeunload = eventHandle;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tteardown: function( namespaces, eventHandle ) {\n\t\t\t\tif ( this.onbeforeunload === eventHandle ) {\n\t\t\t\t\tthis.onbeforeunload = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tsimulate: function( type, elem, event, bubble ) {\n\t\t// Piggyback on a donor event to simulate a different one.\n\t\t// Fake originalEvent to avoid donor's stopPropagation, but if the\n\t\t// simulated event prevents default then we do the same on the donor.\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{ type: type,\n\t\t\t\tisSimulated: true,\n\t\t\t\toriginalEvent: {}\n\t\t\t}\n\t\t);\n\t\tif ( bubble ) {\n\t\t\tjQuery.event.trigger( e, null, elem );\n\t\t} else {\n\t\t\tjQuery.event.dispatch.call( elem, e );\n\t\t}\n\t\tif ( e.isDefaultPrevented() ) {\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n};\n\n// Some plugins are using, but it's undocumented/deprecated and will be removed.\n// The 1.7 special event interface should provide all the hooks needed now.\njQuery.event.handle = jQuery.event.dispatch;\n\njQuery.removeEvent = document.removeEventListener ?\n\tfunction( elem, type, handle ) {\n\t\tif ( elem.removeEventListener ) {\n\t\t\telem.removeEventListener( type, handle, false );\n\t\t}\n\t} :\n\tfunction( elem, type, handle ) {\n\t\tvar name = \"on\" + type;\n\n\t\tif ( elem.detachEvent ) {\n\n\t\t\t// #8545, #7054, preventing memory leaks for custom events in IE6-8 –\n\t\t\t// detachEvent needed property on element, by name of that event, to properly expose it to GC\n\t\t\tif ( typeof elem[ name ] === \"undefined\" ) {\n\t\t\t\telem[ name ] = null;\n\t\t\t}\n\n\t\t\telem.detachEvent( name, handle );\n\t\t}\n\t};\n\njQuery.Event = function( src, props ) {\n\t// Allow instantiation without the 'new' keyword\n\tif ( !(this instanceof jQuery.Event) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||\n\t\t\tsrc.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\nfunction returnFalse() {\n\treturn false;\n}\nfunction returnTrue() {\n\treturn true;\n}\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tpreventDefault: function() {\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tvar e = this.originalEvent;\n\t\tif ( !e ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// if preventDefault exists run it on the original event\n\t\tif ( e.preventDefault ) {\n\t\t\te.preventDefault();\n\n\t\t// otherwise set the returnValue property of the original event to false (IE)\n\t\t} else {\n\t\t\te.returnValue = false;\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tvar e = this.originalEvent;\n\t\tif ( !e ) {\n\t\t\treturn;\n\t\t}\n\t\t// if stopPropagation exists run it on the original event\n\t\tif ( e.stopPropagation ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t\t// otherwise set the cancelBubble property of the original event to true (IE)\n\t\te.cancelBubble = true;\n\t},\n\tstopImmediatePropagation: function() {\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\t\tthis.stopPropagation();\n\t},\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse\n};\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\njQuery.each({\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj,\n\t\t\t\tselector = handleObj.selector;\n\n\t\t\t// For mousenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || (related !== target && !jQuery.contains( target, related )) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n});\n\n// IE submit delegation\nif ( !jQuery.support.submitBubbles ) {\n\n\tjQuery.event.special.submit = {\n\t\tsetup: function() {\n\t\t\t// Only need this for delegated form submit events\n\t\t\tif ( jQuery.nodeName( this, \"form\" ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Lazy-add a submit handler when a descendant form may potentially be submitted\n\t\t\tjQuery.event.add( this, \"click._submit keypress._submit\", function( e ) {\n\t\t\t\t// Node name check avoids a VML-related crash in IE (#9807)\n\t\t\t\tvar elem = e.target,\n\t\t\t\t\tform = jQuery.nodeName( elem, \"input\" ) || jQuery.nodeName( elem, \"button\" ) ? elem.form : undefined;\n\t\t\t\tif ( form && !jQuery._data( form, \"_submit_attached\" ) ) {\n\t\t\t\t\tjQuery.event.add( form, \"submit._submit\", function( event ) {\n\t\t\t\t\t\tevent._submit_bubble = true;\n\t\t\t\t\t});\n\t\t\t\t\tjQuery._data( form, \"_submit_attached\", true );\n\t\t\t\t}\n\t\t\t});\n\t\t\t// return undefined since we don't need an event listener\n\t\t},\n\n\t\tpostDispatch: function( event ) {\n\t\t\t// If form was submitted by the user, bubble the event up the tree\n\t\t\tif ( event._submit_bubble ) {\n\t\t\t\tdelete event._submit_bubble;\n\t\t\t\tif ( this.parentNode && !event.isTrigger ) {\n\t\t\t\t\tjQuery.event.simulate( \"submit\", this.parentNode, event, true );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tteardown: function() {\n\t\t\t// Only need this for delegated form submit events\n\t\t\tif ( jQuery.nodeName( this, \"form\" ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Remove delegated handlers; cleanData eventually reaps submit handlers attached above\n\t\t\tjQuery.event.remove( this, \"._submit\" );\n\t\t}\n\t};\n}\n\n// IE change delegation and checkbox/radio fix\nif ( !jQuery.support.changeBubbles ) {\n\n\tjQuery.event.special.change = {\n\n\t\tsetup: function() {\n\n\t\t\tif ( rformElems.test( this.nodeName ) ) {\n\t\t\t\t// IE doesn't fire change on a check/radio until blur; trigger it on click\n\t\t\t\t// after a propertychange. Eat the blur-change in special.change.handle.\n\t\t\t\t// This still fires onchange a second time for check/radio after blur.\n\t\t\t\tif ( this.type === \"checkbox\" || this.type === \"radio\" ) {\n\t\t\t\t\tjQuery.event.add( this, \"propertychange._change\", function( event ) {\n\t\t\t\t\t\tif ( event.originalEvent.propertyName === \"checked\" ) {\n\t\t\t\t\t\t\tthis._just_changed = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tjQuery.event.add( this, \"click._change\", function( event ) {\n\t\t\t\t\t\tif ( this._just_changed && !event.isTrigger ) {\n\t\t\t\t\t\t\tthis._just_changed = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Allow triggered, simulated change events (#11500)\n\t\t\t\t\t\tjQuery.event.simulate( \"change\", this, event, true );\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// Delegated event; lazy-add a change handler on descendant inputs\n\t\t\tjQuery.event.add( this, \"beforeactivate._change\", function( e ) {\n\t\t\t\tvar elem = e.target;\n\n\t\t\t\tif ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, \"_change_attached\" ) ) {\n\t\t\t\t\tjQuery.event.add( elem, \"change._change\", function( event ) {\n\t\t\t\t\t\tif ( this.parentNode && !event.isSimulated && !event.isTrigger ) {\n\t\t\t\t\t\t\tjQuery.event.simulate( \"change\", this.parentNode, event, true );\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tjQuery._data( elem, \"_change_attached\", true );\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\thandle: function( event ) {\n\t\t\tvar elem = event.target;\n\n\t\t\t// Swallow native change events from checkbox/radio, we already triggered them above\n\t\t\tif ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== \"radio\" && elem.type !== \"checkbox\") ) {\n\t\t\t\treturn event.handleObj.handler.apply( this, arguments );\n\t\t\t}\n\t\t},\n\n\t\tteardown: function() {\n\t\t\tjQuery.event.remove( this, \"._change\" );\n\n\t\t\treturn !rformElems.test( this.nodeName );\n\t\t}\n\t};\n}\n\n// Create \"bubbling\" focus and blur events\nif ( !jQuery.support.focusinBubbles ) {\n\tjQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler while someone wants focusin/focusout\n\t\tvar attaches = 0,\n\t\t\thandler = function( event ) {\n\t\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );\n\t\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tif ( attaches++ === 0 ) {\n\t\t\t\t\tdocument.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tif ( --attaches === 0 ) {\n\t\t\t\t\tdocument.removeEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n}\n\njQuery.fn.extend({\n\n\ton: function( types, selector, data, fn, /*INTERNAL*/ one ) {\n\t\tvar origFn, type;\n\n\t\t// Types can be a map of types/handlers\n\t\tif ( typeof types === \"object\" ) {\n\t\t\t// ( types-Object, selector, data )\n\t\t\tif ( typeof selector !== \"string\" ) { // && selector != null\n\t\t\t\t// ( types-Object, data )\n\t\t\t\tdata = data || selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.on( type, selector, data, types[ type ], one );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( data == null && fn == null ) {\n\t\t\t// ( types, fn )\n\t\t\tfn = selector;\n\t\t\tdata = selector = undefined;\n\t\t} else if ( fn == null ) {\n\t\t\tif ( typeof selector === \"string\" ) {\n\t\t\t\t// ( types, selector, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = undefined;\n\t\t\t} else {\n\t\t\t\t// ( types, data, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t} else if ( !fn ) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( one === 1 ) {\n\t\t\torigFn = fn;\n\t\t\tfn = function( event ) {\n\t\t\t\t// Can use an empty set, since event contains the info\n\t\t\t\tjQuery().off( event );\n\t\t\t\treturn origFn.apply( this, arguments );\n\t\t\t};\n\t\t\t// Use same guid so caller can remove using origFn\n\t\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.add( this, types, fn, data, selector );\n\t\t});\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn this.on( types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t});\n\t},\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tlive: function( types, data, fn ) {\n\t\tjQuery( this.context ).on( types, this.selector, data, fn );\n\t\treturn this;\n\t},\n\tdie: function( types, fn ) {\n\t\tjQuery( this.context ).off( types, this.selector || \"**\", fn );\n\t\treturn this;\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length == 1? this.off( selector, \"**\" ) : this.off( types, selector || \"**\", fn );\n\t},\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t});\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tif ( this[0] ) {\n\t\t\treturn jQuery.event.trigger( type, data, this[0], true );\n\t\t}\n\t},\n\n\ttoggle: function( fn ) {\n\t\t// Save reference to arguments for access in closure\n\t\tvar args = arguments,\n\t\t\tguid = fn.guid || jQuery.guid++,\n\t\t\ti = 0,\n\t\t\ttoggler = function( event ) {\n\t\t\t\t// Figure out which function to execute\n\t\t\t\tvar lastToggle = ( jQuery._data( this, \"lastToggle\" + fn.guid ) || 0 ) % i;\n\t\t\t\tjQuery._data( this, \"lastToggle\" + fn.guid, lastToggle + 1 );\n\n\t\t\t\t// Make sure that clicks stop\n\t\t\t\tevent.preventDefault();\n\n\t\t\t\t// and execute the function\n\t\t\t\treturn args[ lastToggle ].apply( this, arguments ) || false;\n\t\t\t};\n\n\t\t// link all the functions, so any of them can unbind this click handler\n\t\ttoggler.guid = guid;\n\t\twhile ( i < args.length ) {\n\t\t\targs[ i++ ].guid = guid;\n\t\t}\n\n\t\treturn this.click( toggler );\n\t},\n\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t}\n});\n\njQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\tif ( fn == null ) {\n\t\t\tfn = data;\n\t\t\tdata = null;\n\t\t}\n\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n\n\tif ( rkeyEvent.test( name ) ) {\n\t\tjQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;\n\t}\n\n\tif ( rmouseEvent.test( name ) ) {\n\t\tjQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;\n\t}\n});\n/*!\r\n * Sizzle CSS Selector Engine\r\n *  Copyright 2012 jQuery Foundation and other contributors\r\n *  Released under the MIT license\r\n *  http://sizzlejs.com/\r\n */\r\n(function( window, undefined ) {\r\n\r\nvar dirruns,\r\n\tcachedruns,\r\n\tassertGetIdNotName,\r\n\tExpr,\r\n\tgetText,\r\n\tisXML,\r\n\tcontains,\r\n\tcompile,\r\n\tsortOrder,\r\n\thasDuplicate,\r\n\r\n\tbaseHasDuplicate = true,\r\n\tstrundefined = \"undefined\",\r\n\r\n\texpando = ( \"sizcache\" + Math.random() ).replace( \".\", \"\" ),\r\n\r\n\tdocument = window.document,\r\n\tdocElem = document.documentElement,\r\n\tdone = 0,\r\n\tslice = [].slice,\r\n\tpush = [].push,\r\n\r\n\t// Augment a function for special use by Sizzle\r\n\tmarkFunction = function( fn, value ) {\r\n\t\tfn[ expando ] = value || true;\r\n\t\treturn fn;\r\n\t},\r\n\r\n\tcreateCache = function() {\r\n\t\tvar cache = {},\r\n\t\t\tkeys = [];\r\n\r\n\t\treturn markFunction(function( key, value ) {\r\n\t\t\t// Only keep the most recent entries\r\n\t\t\tif ( keys.push( key ) > Expr.cacheLength ) {\r\n\t\t\t\tdelete cache[ keys.shift() ];\r\n\t\t\t}\r\n\r\n\t\t\treturn (cache[ key ] = value);\r\n\t\t}, cache );\r\n\t},\r\n\r\n\tclassCache = createCache(),\r\n\ttokenCache = createCache(),\r\n\tcompilerCache = createCache(),\r\n\r\n\t// Regex\r\n\r\n\t// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\r\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\r\n\t// http://www.w3.org/TR/css3-syntax/#characters\r\n\tcharacterEncoding = \"(?:\\\\\\\\.|[-\\\\w]|[^\\\\x00-\\\\xa0])+\",\r\n\r\n\t// Loosely modeled on CSS identifier characters\r\n\t// An unquoted value should be a CSS identifier (http://www.w3.org/TR/css3-selectors/#attribute-selectors)\r\n\t// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\r\n\tidentifier = characterEncoding.replace( \"w\", \"w#\" ),\r\n\r\n\t// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors\r\n\toperators = \"([*^$|!~]?=)\",\r\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + characterEncoding + \")\" + whitespace +\r\n\t\t\"*(?:\" + operators + whitespace + \"*(?:(['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|(\" + identifier + \")|)|)\" + whitespace + \"*\\\\]\",\r\n\r\n\t// Prefer arguments not in parens/brackets,\r\n\t//   then attribute selectors and non-pseudos (denoted by :),\r\n\t//   then anything else\r\n\t// These preferences are here to reduce the number of selectors\r\n\t//   needing tokenize in the PSEUDO preFilter\r\n\tpseudos = \":(\" + characterEncoding + \")(?:\\\\((?:(['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\2|([^()[\\\\]]*|(?:(?:\" + attributes + \")|[^:]|\\\\\\\\.)*|.*))\\\\)|)\",\r\n\r\n\t// For matchExpr.POS and matchExpr.needsContext\r\n\tpos = \":(nth|eq|gt|lt|first|last|even|odd)(?:\\\\(((?:-\\\\d)?\\\\d*)\\\\)|)(?=[^-]|$)\",\r\n\r\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\r\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\r\n\r\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\r\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([\\\\x20\\\\t\\\\r\\\\n\\\\f>+~])\" + whitespace + \"*\" ),\r\n\trpseudo = new RegExp( pseudos ),\r\n\r\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\r\n\trquickExpr = /^(?:#([\\w\\-]+)|(\\w+)|\\.([\\w\\-]+))$/,\r\n\r\n\trnot = /^:not/,\r\n\trsibling = /[\\x20\\t\\r\\n\\f]*[+~]/,\r\n\trendsWithNot = /:not\\($/,\r\n\r\n\trheader = /h\\d/i,\r\n\trinputs = /input|select|textarea|button/i,\r\n\r\n\trbackslash = /\\\\(?!\\\\)/g,\r\n\r\n\tmatchExpr = {\r\n\t\t\"ID\": new RegExp( \"^#(\" + characterEncoding + \")\" ),\r\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + characterEncoding + \")\" ),\r\n\t\t\"NAME\": new RegExp( \"^\\\\[name=['\\\"]?(\" + characterEncoding + \")['\\\"]?\\\\]\" ),\r\n\t\t\"TAG\": new RegExp( \"^(\" + characterEncoding.replace( \"w\", \"w*\" ) + \")\" ),\r\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\r\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\r\n\t\t\"CHILD\": new RegExp( \"^:(only|nth|last|first)-child(?:\\\\(\" + whitespace +\r\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\r\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\r\n\t\t\"POS\": new RegExp( pos, \"ig\" ),\r\n\t\t// For use in libraries implementing .is()\r\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|\" + pos, \"i\" )\r\n\t},\r\n\r\n\t// Support\r\n\r\n\t// Used for testing something on an element\r\n\tassert = function( fn ) {\r\n\t\tvar div = document.createElement(\"div\");\r\n\r\n\t\ttry {\r\n\t\t\treturn fn( div );\r\n\t\t} catch (e) {\r\n\t\t\treturn false;\r\n\t\t} finally {\r\n\t\t\t// release memory in IE\r\n\t\t\tdiv = null;\r\n\t\t}\r\n\t},\r\n\r\n\t// Check if getElementsByTagName(\"*\") returns only elements\r\n\tassertTagNameNoComments = assert(function( div ) {\r\n\t\tdiv.appendChild( document.createComment(\"\") );\r\n\t\treturn !div.getElementsByTagName(\"*\").length;\r\n\t}),\r\n\r\n\t// Check if getAttribute returns normalized href attributes\r\n\tassertHrefNotNormalized = assert(function( div ) {\r\n\t\tdiv.innerHTML = \"<a href='#'></a>\";\r\n\t\treturn div.firstChild && typeof div.firstChild.getAttribute !== strundefined &&\r\n\t\t\tdiv.firstChild.getAttribute(\"href\") === \"#\";\r\n\t}),\r\n\r\n\t// Check if attributes should be retrieved by attribute nodes\r\n\tassertAttributes = assert(function( div ) {\r\n\t\tdiv.innerHTML = \"<select></select>\";\r\n\t\tvar type = typeof div.lastChild.getAttribute(\"multiple\");\r\n\t\t// IE8 returns a string for some attributes even when not present\r\n\t\treturn type !== \"boolean\" && type !== \"string\";\r\n\t}),\r\n\r\n\t// Check if getElementsByClassName can be trusted\r\n\tassertUsableClassName = assert(function( div ) {\r\n\t\t// Opera can't find a second classname (in 9.6)\r\n\t\tdiv.innerHTML = \"<div class='hidden e'></div><div class='hidden'></div>\";\r\n\t\tif ( !div.getElementsByClassName || !div.getElementsByClassName(\"e\").length ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// Safari 3.2 caches class attributes and doesn't catch changes\r\n\t\tdiv.lastChild.className = \"e\";\r\n\t\treturn div.getElementsByClassName(\"e\").length === 2;\r\n\t}),\r\n\r\n\t// Check if getElementById returns elements by name\r\n\t// Check if getElementsByName privileges form controls or returns elements by ID\r\n\tassertUsableName = assert(function( div ) {\r\n\t\t// Inject content\r\n\t\tdiv.id = expando + 0;\r\n\t\tdiv.innerHTML = \"<a name='\" + expando + \"'></a><div name='\" + expando + \"'></div>\";\r\n\t\tdocElem.insertBefore( div, docElem.firstChild );\r\n\r\n\t\t// Test\r\n\t\tvar pass = document.getElementsByName &&\r\n\t\t\t// buggy browsers will return fewer than the correct 2\r\n\t\t\tdocument.getElementsByName( expando ).length === 2 +\r\n\t\t\t// buggy browsers will return more than the correct 0\r\n\t\t\tdocument.getElementsByName( expando + 0 ).length;\r\n\t\tassertGetIdNotName = !document.getElementById( expando );\r\n\r\n\t\t// Cleanup\r\n\t\tdocElem.removeChild( div );\r\n\r\n\t\treturn pass;\r\n\t});\r\n\r\n// If slice is not available, provide a backup\r\ntry {\r\n\tslice.call( docElem.childNodes, 0 )[0].nodeType;\r\n} catch ( e ) {\r\n\tslice = function( i ) {\r\n\t\tvar elem, results = [];\r\n\t\tfor ( ; (elem = this[i]); i++ ) {\r\n\t\t\tresults.push( elem );\r\n\t\t}\r\n\t\treturn results;\r\n\t};\r\n}\r\n\r\nfunction Sizzle( selector, context, results, seed ) {\r\n\tresults = results || [];\r\n\tcontext = context || document;\r\n\tvar match, elem, xml, m,\r\n\t\tnodeType = context.nodeType;\r\n\r\n\tif ( nodeType !== 1 && nodeType !== 9 ) {\r\n\t\treturn [];\r\n\t}\r\n\r\n\tif ( !selector || typeof selector !== \"string\" ) {\r\n\t\treturn results;\r\n\t}\r\n\r\n\txml = isXML( context );\r\n\r\n\tif ( !xml && !seed ) {\r\n\t\tif ( (match = rquickExpr.exec( selector )) ) {\r\n\t\t\t// Speed-up: Sizzle(\"#ID\")\r\n\t\t\tif ( (m = match[1]) ) {\r\n\t\t\t\tif ( nodeType === 9 ) {\r\n\t\t\t\t\telem = context.getElementById( m );\r\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\r\n\t\t\t\t\t// nodes that are no longer in the document #6963\r\n\t\t\t\t\tif ( elem && elem.parentNode ) {\r\n\t\t\t\t\t\t// Handle the case where IE, Opera, and Webkit return items\r\n\t\t\t\t\t\t// by name instead of ID\r\n\t\t\t\t\t\tif ( elem.id === m ) {\r\n\t\t\t\t\t\t\tresults.push( elem );\r\n\t\t\t\t\t\t\treturn results;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn results;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Context is not a document\r\n\t\t\t\t\tif ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&\r\n\t\t\t\t\t\tcontains( context, elem ) && elem.id === m ) {\r\n\t\t\t\t\t\tresults.push( elem );\r\n\t\t\t\t\t\treturn results;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t// Speed-up: Sizzle(\"TAG\")\r\n\t\t\t} else if ( match[2] ) {\r\n\t\t\t\tpush.apply( results, slice.call(context.getElementsByTagName( selector ), 0) );\r\n\t\t\t\treturn results;\r\n\r\n\t\t\t// Speed-up: Sizzle(\".CLASS\")\r\n\t\t\t} else if ( (m = match[3]) && assertUsableClassName && context.getElementsByClassName ) {\r\n\t\t\t\tpush.apply( results, slice.call(context.getElementsByClassName( m ), 0) );\r\n\t\t\t\treturn results;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// All others\r\n\treturn select( selector, context, results, seed, xml );\r\n}\r\n\r\nSizzle.matches = function( expr, elements ) {\r\n\treturn Sizzle( expr, null, null, elements );\r\n};\r\n\r\nSizzle.matchesSelector = function( elem, expr ) {\r\n\treturn Sizzle( expr, null, null, [ elem ] ).length > 0;\r\n};\r\n\r\n// Returns a function to use in pseudos for input types\r\nfunction createInputPseudo( type ) {\r\n\treturn function( elem ) {\r\n\t\tvar name = elem.nodeName.toLowerCase();\r\n\t\treturn name === \"input\" && elem.type === type;\r\n\t};\r\n}\r\n\r\n// Returns a function to use in pseudos for buttons\r\nfunction createButtonPseudo( type ) {\r\n\treturn function( elem ) {\r\n\t\tvar name = elem.nodeName.toLowerCase();\r\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\r\n\t};\r\n}\r\n\r\n/**\r\n * Utility function for retrieving the text value of an array of DOM nodes\r\n * @param {Array|Element} elem\r\n */\r\ngetText = Sizzle.getText = function( elem ) {\r\n\tvar node,\r\n\t\tret = \"\",\r\n\t\ti = 0,\r\n\t\tnodeType = elem.nodeType;\r\n\r\n\tif ( nodeType ) {\r\n\t\tif ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\r\n\t\t\t// Use textContent for elements\r\n\t\t\t// innerText usage removed for consistency of new lines (see #11153)\r\n\t\t\tif ( typeof elem.textContent === \"string\" ) {\r\n\t\t\t\treturn elem.textContent;\r\n\t\t\t} else {\r\n\t\t\t\t// Traverse its children\r\n\t\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\r\n\t\t\t\t\tret += getText( elem );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if ( nodeType === 3 || nodeType === 4 ) {\r\n\t\t\treturn elem.nodeValue;\r\n\t\t}\r\n\t\t// Do not include comment or processing instruction nodes\r\n\t} else {\r\n\r\n\t\t// If no nodeType, this is expected to be an array\r\n\t\tfor ( ; (node = elem[i]); i++ ) {\r\n\t\t\t// Do not traverse comment nodes\r\n\t\t\tret += getText( node );\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n};\r\n\r\nisXML = Sizzle.isXML = function isXML( elem ) {\r\n\t// documentElement is verified for cases where it doesn't yet exist\r\n\t// (such as loading iframes in IE - #4833)\r\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\r\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\r\n};\r\n\r\n// Element contains another\r\ncontains = Sizzle.contains = docElem.contains ?\r\n\tfunction( a, b ) {\r\n\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\r\n\t\t\tbup = b && b.parentNode;\r\n\t\treturn a === bup || !!( bup && bup.nodeType === 1 && adown.contains && adown.contains(bup) );\r\n\t} :\r\n\tdocElem.compareDocumentPosition ?\r\n\tfunction( a, b ) {\r\n\t\treturn b && !!( a.compareDocumentPosition( b ) & 16 );\r\n\t} :\r\n\tfunction( a, b ) {\r\n\t\twhile ( (b = b.parentNode) ) {\r\n\t\t\tif ( b === a ) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t};\r\n\r\nSizzle.attr = function( elem, name ) {\r\n\tvar attr,\r\n\t\txml = isXML( elem );\r\n\r\n\tif ( !xml ) {\r\n\t\tname = name.toLowerCase();\r\n\t}\r\n\tif ( Expr.attrHandle[ name ] ) {\r\n\t\treturn Expr.attrHandle[ name ]( elem );\r\n\t}\r\n\tif ( assertAttributes || xml ) {\r\n\t\treturn elem.getAttribute( name );\r\n\t}\r\n\tattr = elem.getAttributeNode( name );\r\n\treturn attr ?\r\n\t\ttypeof elem[ name ] === \"boolean\" ?\r\n\t\t\telem[ name ] ? name : null :\r\n\t\t\tattr.specified ? attr.value : null :\r\n\t\tnull;\r\n};\r\n\r\nExpr = Sizzle.selectors = {\r\n\r\n\t// Can be adjusted by the user\r\n\tcacheLength: 50,\r\n\r\n\tcreatePseudo: markFunction,\r\n\r\n\tmatch: matchExpr,\r\n\r\n\torder: new RegExp( \"ID|TAG\" +\r\n\t\t(assertUsableName ? \"|NAME\" : \"\") +\r\n\t\t(assertUsableClassName ? \"|CLASS\" : \"\")\r\n\t),\r\n\r\n\t// IE6/7 return a modified href\r\n\tattrHandle: assertHrefNotNormalized ?\r\n\t\t{} :\r\n\t\t{\r\n\t\t\t\"href\": function( elem ) {\r\n\t\t\t\treturn elem.getAttribute( \"href\", 2 );\r\n\t\t\t},\r\n\t\t\t\"type\": function( elem ) {\r\n\t\t\t\treturn elem.getAttribute(\"type\");\r\n\t\t\t}\r\n\t\t},\r\n\r\n\tfind: {\r\n\t\t\"ID\": assertGetIdNotName ?\r\n\t\t\tfunction( id, context, xml ) {\r\n\t\t\t\tif ( typeof context.getElementById !== strundefined && !xml ) {\r\n\t\t\t\t\tvar m = context.getElementById( id );\r\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\r\n\t\t\t\t\t// nodes that are no longer in the document #6963\r\n\t\t\t\t\treturn m && m.parentNode ? [m] : [];\r\n\t\t\t\t}\r\n\t\t\t} :\r\n\t\t\tfunction( id, context, xml ) {\r\n\t\t\t\tif ( typeof context.getElementById !== strundefined && !xml ) {\r\n\t\t\t\t\tvar m = context.getElementById( id );\r\n\r\n\t\t\t\t\treturn m ?\r\n\t\t\t\t\t\tm.id === id || typeof m.getAttributeNode !== strundefined && m.getAttributeNode(\"id\").value === id ?\r\n\t\t\t\t\t\t\t[m] :\r\n\t\t\t\t\t\t\tundefined :\r\n\t\t\t\t\t\t[];\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\"TAG\": assertTagNameNoComments ?\r\n\t\t\tfunction( tag, context ) {\r\n\t\t\t\tif ( typeof context.getElementsByTagName !== strundefined ) {\r\n\t\t\t\t\treturn context.getElementsByTagName( tag );\r\n\t\t\t\t}\r\n\t\t\t} :\r\n\t\t\tfunction( tag, context ) {\r\n\t\t\t\tvar results = context.getElementsByTagName( tag );\r\n\r\n\t\t\t\t// Filter out possible comments\r\n\t\t\t\tif ( tag === \"*\" ) {\r\n\t\t\t\t\tvar elem,\r\n\t\t\t\t\t\ttmp = [],\r\n\t\t\t\t\t\ti = 0;\r\n\r\n\t\t\t\t\tfor ( ; (elem = results[i]); i++ ) {\r\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\r\n\t\t\t\t\t\t\ttmp.push( elem );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn tmp;\r\n\t\t\t\t}\r\n\t\t\t\treturn results;\r\n\t\t\t},\r\n\r\n\t\t\"NAME\": function( tag, context ) {\r\n\t\t\tif ( typeof context.getElementsByName !== strundefined ) {\r\n\t\t\t\treturn context.getElementsByName( name );\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t\"CLASS\": function( className, context, xml ) {\r\n\t\t\tif ( typeof context.getElementsByClassName !== strundefined && !xml ) {\r\n\t\t\t\treturn context.getElementsByClassName( className );\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\trelative: {\r\n\t\t\">\": { dir: \"parentNode\", first: true },\r\n\t\t\" \": { dir: \"parentNode\" },\r\n\t\t\"+\": { dir: \"previousSibling\", first: true },\r\n\t\t\"~\": { dir: \"previousSibling\" }\r\n\t},\r\n\r\n\tpreFilter: {\r\n\t\t\"ATTR\": function( match ) {\r\n\t\t\tmatch[1] = match[1].replace( rbackslash, \"\" );\r\n\r\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\r\n\t\t\tmatch[3] = ( match[4] || match[5] || \"\" ).replace( rbackslash, \"\" );\r\n\r\n\t\t\tif ( match[2] === \"~=\" ) {\r\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\r\n\t\t\t}\r\n\r\n\t\t\treturn match.slice( 0, 4 );\r\n\t\t},\r\n\r\n\t\t\"CHILD\": function( match ) {\r\n\t\t\t/* matches from matchExpr.CHILD\r\n\t\t\t\t1 type (only|nth|...)\r\n\t\t\t\t2 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\r\n\t\t\t\t3 xn-component of xn+y argument ([+-]?\\d*n|)\r\n\t\t\t\t4 sign of xn-component\r\n\t\t\t\t5 x of xn-component\r\n\t\t\t\t6 sign of y-component\r\n\t\t\t\t7 y of y-component\r\n\t\t\t*/\r\n\t\t\tmatch[1] = match[1].toLowerCase();\r\n\r\n\t\t\tif ( match[1] === \"nth\" ) {\r\n\t\t\t\t// nth-child requires argument\r\n\t\t\t\tif ( !match[2] ) {\r\n\t\t\t\t\tSizzle.error( match[0] );\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\r\n\t\t\t\t// remember that false/true cast respectively to 0/1\r\n\t\t\t\tmatch[3] = +( match[3] ? match[4] + (match[5] || 1) : 2 * ( match[2] === \"even\" || match[2] === \"odd\" ) );\r\n\t\t\t\tmatch[4] = +( ( match[6] + match[7] ) || match[2] === \"odd\" );\r\n\r\n\t\t\t// other types prohibit arguments\r\n\t\t\t} else if ( match[2] ) {\r\n\t\t\t\tSizzle.error( match[0] );\r\n\t\t\t}\r\n\r\n\t\t\treturn match;\r\n\t\t},\r\n\r\n\t\t\"PSEUDO\": function( match, context, xml ) {\r\n\t\t\tvar unquoted, excess;\r\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\tif ( match[3] ) {\r\n\t\t\t\tmatch[2] = match[3];\r\n\t\t\t} else if ( (unquoted = match[4]) ) {\r\n\t\t\t\t// Only check arguments that contain a pseudo\r\n\t\t\t\tif ( rpseudo.test(unquoted) &&\r\n\t\t\t\t\t// Get excess from tokenize (recursively)\r\n\t\t\t\t\t(excess = tokenize( unquoted, context, xml, true )) &&\r\n\t\t\t\t\t// advance to the next closing parenthesis\r\n\t\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\r\n\r\n\t\t\t\t\t// excess is a negative index\r\n\t\t\t\t\tunquoted = unquoted.slice( 0, excess );\r\n\t\t\t\t\tmatch[0] = match[0].slice( 0, excess );\r\n\t\t\t\t}\r\n\t\t\t\tmatch[2] = unquoted;\r\n\t\t\t}\r\n\r\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\r\n\t\t\treturn match.slice( 0, 3 );\r\n\t\t}\r\n\t},\r\n\r\n\tfilter: {\r\n\t\t\"ID\": assertGetIdNotName ?\r\n\t\t\tfunction( id ) {\r\n\t\t\t\tid = id.replace( rbackslash, \"\" );\r\n\t\t\t\treturn function( elem ) {\r\n\t\t\t\t\treturn elem.getAttribute(\"id\") === id;\r\n\t\t\t\t};\r\n\t\t\t} :\r\n\t\t\tfunction( id ) {\r\n\t\t\t\tid = id.replace( rbackslash, \"\" );\r\n\t\t\t\treturn function( elem ) {\r\n\t\t\t\t\tvar node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode(\"id\");\r\n\t\t\t\t\treturn node && node.value === id;\r\n\t\t\t\t};\r\n\t\t\t},\r\n\r\n\t\t\"TAG\": function( nodeName ) {\r\n\t\t\tif ( nodeName === \"*\" ) {\r\n\t\t\t\treturn function() { return true; };\r\n\t\t\t}\r\n\t\t\tnodeName = nodeName.replace( rbackslash, \"\" ).toLowerCase();\r\n\r\n\t\t\treturn function( elem ) {\r\n\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\r\n\t\t\t};\r\n\t\t},\r\n\r\n\t\t\"CLASS\": function( className ) {\r\n\t\t\tvar pattern = classCache[ expando ][ className ];\r\n\t\t\tif ( !pattern ) {\r\n\t\t\t\tpattern = classCache( className, new RegExp(\"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\") );\r\n\t\t\t}\r\n\t\t\treturn function( elem ) {\r\n\t\t\t\treturn pattern.test( elem.className || (typeof elem.getAttribute !== strundefined && elem.getAttribute(\"class\")) || \"\" );\r\n\t\t\t};\r\n\t\t},\r\n\r\n\t\t\"ATTR\": function( name, operator, check ) {\r\n\t\t\tif ( !operator ) {\r\n\t\t\t\treturn function( elem ) {\r\n\t\t\t\t\treturn Sizzle.attr( elem, name ) != null;\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\treturn function( elem ) {\r\n\t\t\t\tvar result = Sizzle.attr( elem, name ),\r\n\t\t\t\t\tvalue = result + \"\";\r\n\r\n\t\t\t\tif ( result == null ) {\r\n\t\t\t\t\treturn operator === \"!=\";\r\n\t\t\t\t}\r\n\r\n\t\t\t\tswitch ( operator ) {\r\n\t\t\t\t\tcase \"=\":\r\n\t\t\t\t\t\treturn value === check;\r\n\t\t\t\t\tcase \"!=\":\r\n\t\t\t\t\t\treturn value !== check;\r\n\t\t\t\t\tcase \"^=\":\r\n\t\t\t\t\t\treturn check && value.indexOf( check ) === 0;\r\n\t\t\t\t\tcase \"*=\":\r\n\t\t\t\t\t\treturn check && value.indexOf( check ) > -1;\r\n\t\t\t\t\tcase \"$=\":\r\n\t\t\t\t\t\treturn check && value.substr( value.length - check.length ) === check;\r\n\t\t\t\t\tcase \"~=\":\r\n\t\t\t\t\t\treturn ( \" \" + value + \" \" ).indexOf( check ) > -1;\r\n\t\t\t\t\tcase \"|=\":\r\n\t\t\t\t\t\treturn value === check || value.substr( 0, check.length + 1 ) === check + \"-\";\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t},\r\n\r\n\t\t\"CHILD\": function( type, argument, first, last ) {\r\n\r\n\t\t\tif ( type === \"nth\" ) {\r\n\t\t\t\tvar doneName = done++;\r\n\r\n\t\t\t\treturn function( elem ) {\r\n\t\t\t\t\tvar parent, diff,\r\n\t\t\t\t\t\tcount = 0,\r\n\t\t\t\t\t\tnode = elem;\r\n\r\n\t\t\t\t\tif ( first === 1 && last === 0 ) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tparent = elem.parentNode;\r\n\r\n\t\t\t\t\tif ( parent && (parent[ expando ] !== doneName || !elem.sizset) ) {\r\n\t\t\t\t\t\tfor ( node = parent.firstChild; node; node = node.nextSibling ) {\r\n\t\t\t\t\t\t\tif ( node.nodeType === 1 ) {\r\n\t\t\t\t\t\t\t\tnode.sizset = ++count;\r\n\t\t\t\t\t\t\t\tif ( node === elem ) {\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tparent[ expando ] = doneName;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdiff = elem.sizset - last;\r\n\r\n\t\t\t\t\tif ( first === 0 ) {\r\n\t\t\t\t\t\treturn diff === 0;\r\n\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn ( diff % first === 0 && diff / first >= 0 );\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\treturn function( elem ) {\r\n\t\t\t\tvar node = elem;\r\n\r\n\t\t\t\tswitch ( type ) {\r\n\t\t\t\t\tcase \"only\":\r\n\t\t\t\t\tcase \"first\":\r\n\t\t\t\t\t\twhile ( (node = node.previousSibling) ) {\r\n\t\t\t\t\t\t\tif ( node.nodeType === 1 ) {\r\n\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( type === \"first\" ) {\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tnode = elem;\r\n\r\n\t\t\t\t\t\t/* falls through */\r\n\t\t\t\t\tcase \"last\":\r\n\t\t\t\t\t\twhile ( (node = node.nextSibling) ) {\r\n\t\t\t\t\t\t\tif ( node.nodeType === 1 ) {\r\n\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t},\r\n\r\n\t\t\"PSEUDO\": function( pseudo, argument, context, xml ) {\r\n\t\t\t// pseudo-class names are case-insensitive\r\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\r\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\r\n\t\t\tvar args,\r\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.pseudos[ pseudo.toLowerCase() ];\r\n\r\n\t\t\tif ( !fn ) {\r\n\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\r\n\t\t\t}\r\n\r\n\t\t\t// The user may use createPseudo to indicate that\r\n\t\t\t// arguments are needed to create the filter function\r\n\t\t\t// just as Sizzle does\r\n\t\t\tif ( !fn[ expando ] ) {\r\n\t\t\t\tif ( fn.length > 1 ) {\r\n\t\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\r\n\t\t\t\t\treturn function( elem ) {\r\n\t\t\t\t\t\treturn fn( elem, 0, args );\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t\treturn fn;\r\n\t\t\t}\r\n\r\n\t\t\treturn fn( argument, context, xml );\r\n\t\t}\r\n\t},\r\n\r\n\tpseudos: {\r\n\t\t\"not\": markFunction(function( selector, context, xml ) {\r\n\t\t\t// Trim the selector passed to compile\r\n\t\t\t// to avoid treating leading and trailing\r\n\t\t\t// spaces as combinators\r\n\t\t\tvar matcher = compile( selector.replace( rtrim, \"$1\" ), context, xml );\r\n\t\t\treturn function( elem ) {\r\n\t\t\t\treturn !matcher( elem );\r\n\t\t\t};\r\n\t\t}),\r\n\r\n\t\t\"enabled\": function( elem ) {\r\n\t\t\treturn elem.disabled === false;\r\n\t\t},\r\n\r\n\t\t\"disabled\": function( elem ) {\r\n\t\t\treturn elem.disabled === true;\r\n\t\t},\r\n\r\n\t\t\"checked\": function( elem ) {\r\n\t\t\t// In CSS3, :checked should return both checked and selected elements\r\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\r\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\r\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\r\n\t\t},\r\n\r\n\t\t\"selected\": function( elem ) {\r\n\t\t\t// Accessing this property makes selected-by-default\r\n\t\t\t// options in Safari work properly\r\n\t\t\tif ( elem.parentNode ) {\r\n\t\t\t\telem.parentNode.selectedIndex;\r\n\t\t\t}\r\n\r\n\t\t\treturn elem.selected === true;\r\n\t\t},\r\n\r\n\t\t\"parent\": function( elem ) {\r\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\r\n\t\t},\r\n\r\n\t\t\"empty\": function( elem ) {\r\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\r\n\t\t\t// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),\r\n\t\t\t//   not comment, processing instructions, or others\r\n\t\t\t// Thanks to Diego Perini for the nodeName shortcut\r\n\t\t\t//   Greater than \"@\" means alpha characters (specifically not starting with \"#\" or \"?\")\r\n\t\t\tvar nodeType;\r\n\t\t\telem = elem.firstChild;\r\n\t\t\twhile ( elem ) {\r\n\t\t\t\tif ( elem.nodeName > \"@\" || (nodeType = elem.nodeType) === 3 || nodeType === 4 ) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\telem = elem.nextSibling;\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\t\t\"contains\": markFunction(function( text ) {\r\n\t\t\treturn function( elem ) {\r\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\r\n\t\t\t};\r\n\t\t}),\r\n\r\n\t\t\"has\": markFunction(function( selector ) {\r\n\t\t\treturn function( elem ) {\r\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\r\n\t\t\t};\r\n\t\t}),\r\n\r\n\t\t\"header\": function( elem ) {\r\n\t\t\treturn rheader.test( elem.nodeName );\r\n\t\t},\r\n\r\n\t\t\"text\": function( elem ) {\r\n\t\t\tvar type, attr;\r\n\t\t\t// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)\r\n\t\t\t// use getAttribute instead to test this case\r\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\r\n\t\t\t\t(type = elem.type) === \"text\" &&\r\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === type );\r\n\t\t},\r\n\r\n\t\t// Input types\r\n\t\t\"radio\": createInputPseudo(\"radio\"),\r\n\t\t\"checkbox\": createInputPseudo(\"checkbox\"),\r\n\t\t\"file\": createInputPseudo(\"file\"),\r\n\t\t\"password\": createInputPseudo(\"password\"),\r\n\t\t\"image\": createInputPseudo(\"image\"),\r\n\r\n\t\t\"submit\": createButtonPseudo(\"submit\"),\r\n\t\t\"reset\": createButtonPseudo(\"reset\"),\r\n\r\n\t\t\"button\": function( elem ) {\r\n\t\t\tvar name = elem.nodeName.toLowerCase();\r\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\r\n\t\t},\r\n\r\n\t\t\"input\": function( elem ) {\r\n\t\t\treturn rinputs.test( elem.nodeName );\r\n\t\t},\r\n\r\n\t\t\"focus\": function( elem ) {\r\n\t\t\tvar doc = elem.ownerDocument;\r\n\t\t\treturn elem === doc.activeElement && (!doc.hasFocus || doc.hasFocus()) && !!(elem.type || elem.href);\r\n\t\t},\r\n\r\n\t\t\"active\": function( elem ) {\r\n\t\t\treturn elem === elem.ownerDocument.activeElement;\r\n\t\t}\r\n\t},\r\n\r\n\tsetFilters: {\r\n\t\t\"first\": function( elements, argument, not ) {\r\n\t\t\treturn not ? elements.slice( 1 ) : [ elements[0] ];\r\n\t\t},\r\n\r\n\t\t\"last\": function( elements, argument, not ) {\r\n\t\t\tvar elem = elements.pop();\r\n\t\t\treturn not ? elements : [ elem ];\r\n\t\t},\r\n\r\n\t\t\"even\": function( elements, argument, not ) {\r\n\t\t\tvar results = [],\r\n\t\t\t\ti = not ? 1 : 0,\r\n\t\t\t\tlen = elements.length;\r\n\t\t\tfor ( ; i < len; i = i + 2 ) {\r\n\t\t\t\tresults.push( elements[i] );\r\n\t\t\t}\r\n\t\t\treturn results;\r\n\t\t},\r\n\r\n\t\t\"odd\": function( elements, argument, not ) {\r\n\t\t\tvar results = [],\r\n\t\t\t\ti = not ? 0 : 1,\r\n\t\t\t\tlen = elements.length;\r\n\t\t\tfor ( ; i < len; i = i + 2 ) {\r\n\t\t\t\tresults.push( elements[i] );\r\n\t\t\t}\r\n\t\t\treturn results;\r\n\t\t},\r\n\r\n\t\t\"lt\": function( elements, argument, not ) {\r\n\t\t\treturn not ? elements.slice( +argument ) : elements.slice( 0, +argument );\r\n\t\t},\r\n\r\n\t\t\"gt\": function( elements, argument, not ) {\r\n\t\t\treturn not ? elements.slice( 0, +argument + 1 ) : elements.slice( +argument + 1 );\r\n\t\t},\r\n\r\n\t\t\"eq\": function( elements, argument, not ) {\r\n\t\t\tvar elem = elements.splice( +argument, 1 );\r\n\t\t\treturn not ? elements : elem;\r\n\t\t}\r\n\t}\r\n};\r\n\r\nfunction siblingCheck( a, b, ret ) {\r\n\tif ( a === b ) {\r\n\t\treturn ret;\r\n\t}\r\n\r\n\tvar cur = a.nextSibling;\r\n\r\n\twhile ( cur ) {\r\n\t\tif ( cur === b ) {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\r\n\t\tcur = cur.nextSibling;\r\n\t}\r\n\r\n\treturn 1;\r\n}\r\n\r\nsortOrder = docElem.compareDocumentPosition ?\r\n\tfunction( a, b ) {\r\n\t\tif ( a === b ) {\r\n\t\t\thasDuplicate = true;\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\treturn ( !a.compareDocumentPosition || !b.compareDocumentPosition ?\r\n\t\t\ta.compareDocumentPosition :\r\n\t\t\ta.compareDocumentPosition(b) & 4\r\n\t\t) ? -1 : 1;\r\n\t} :\r\n\tfunction( a, b ) {\r\n\t\t// The nodes are identical, we can exit early\r\n\t\tif ( a === b ) {\r\n\t\t\thasDuplicate = true;\r\n\t\t\treturn 0;\r\n\r\n\t\t// Fallback to using sourceIndex (in IE) if it's available on both nodes\r\n\t\t} else if ( a.sourceIndex && b.sourceIndex ) {\r\n\t\t\treturn a.sourceIndex - b.sourceIndex;\r\n\t\t}\r\n\r\n\t\tvar al, bl,\r\n\t\t\tap = [],\r\n\t\t\tbp = [],\r\n\t\t\taup = a.parentNode,\r\n\t\t\tbup = b.parentNode,\r\n\t\t\tcur = aup;\r\n\r\n\t\t// If the nodes are siblings (or identical) we can do a quick check\r\n\t\tif ( aup === bup ) {\r\n\t\t\treturn siblingCheck( a, b );\r\n\r\n\t\t// If no parents were found then the nodes are disconnected\r\n\t\t} else if ( !aup ) {\r\n\t\t\treturn -1;\r\n\r\n\t\t} else if ( !bup ) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\r\n\t\t// Otherwise they're somewhere else in the tree so we need\r\n\t\t// to build up a full list of the parentNodes for comparison\r\n\t\twhile ( cur ) {\r\n\t\t\tap.unshift( cur );\r\n\t\t\tcur = cur.parentNode;\r\n\t\t}\r\n\r\n\t\tcur = bup;\r\n\r\n\t\twhile ( cur ) {\r\n\t\t\tbp.unshift( cur );\r\n\t\t\tcur = cur.parentNode;\r\n\t\t}\r\n\r\n\t\tal = ap.length;\r\n\t\tbl = bp.length;\r\n\r\n\t\t// Start walking down the tree looking for a discrepancy\r\n\t\tfor ( var i = 0; i < al && i < bl; i++ ) {\r\n\t\t\tif ( ap[i] !== bp[i] ) {\r\n\t\t\t\treturn siblingCheck( ap[i], bp[i] );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// We ended someplace up the tree so do a sibling check\r\n\t\treturn i === al ?\r\n\t\t\tsiblingCheck( a, bp[i], -1 ) :\r\n\t\t\tsiblingCheck( ap[i], b, 1 );\r\n\t};\r\n\r\n// Always assume the presence of duplicates if sort doesn't\r\n// pass them to our comparison function (as in Google Chrome).\r\n[0, 0].sort( sortOrder );\r\nbaseHasDuplicate = !hasDuplicate;\r\n\r\n// Document sorting and removing duplicates\r\nSizzle.uniqueSort = function( results ) {\r\n\tvar elem,\r\n\t\ti = 1;\r\n\r\n\thasDuplicate = baseHasDuplicate;\r\n\tresults.sort( sortOrder );\r\n\r\n\tif ( hasDuplicate ) {\r\n\t\tfor ( ; (elem = results[i]); i++ ) {\r\n\t\t\tif ( elem === results[ i - 1 ] ) {\r\n\t\t\t\tresults.splice( i--, 1 );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn results;\r\n};\r\n\r\nSizzle.error = function( msg ) {\r\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\r\n};\r\n\r\nfunction tokenize( selector, context, xml, parseOnly ) {\r\n\tvar matched, match, tokens, type,\r\n\t\tsoFar, groups, group, i,\r\n\t\tpreFilters, filters,\r\n\t\tcheckContext = !xml && context !== document,\r\n\t\t// Token cache should maintain spaces\r\n\t\tkey = ( checkContext ? \"<s>\" : \"\" ) + selector.replace( rtrim, \"$1<s>\" ),\r\n\t\tcached = tokenCache[ expando ][ key ];\r\n\r\n\tif ( cached ) {\r\n\t\treturn parseOnly ? 0 : slice.call( cached, 0 );\r\n\t}\r\n\r\n\tsoFar = selector;\r\n\tgroups = [];\r\n\ti = 0;\r\n\tpreFilters = Expr.preFilter;\r\n\tfilters = Expr.filter;\r\n\r\n\twhile ( soFar ) {\r\n\r\n\t\t// Comma and first run\r\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\r\n\t\t\tif ( match ) {\r\n\t\t\t\tsoFar = soFar.slice( match[0].length );\r\n\t\t\t\ttokens.selector = group;\r\n\t\t\t}\r\n\t\t\tgroups.push( tokens = [] );\r\n\t\t\tgroup = \"\";\r\n\r\n\t\t\t// Need to make sure we're within a narrower context if necessary\r\n\t\t\t// Adding a descendant combinator will generate what is needed\r\n\t\t\tif ( checkContext ) {\r\n\t\t\t\tsoFar = \" \" + soFar;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tmatched = false;\r\n\r\n\t\t// Combinators\r\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\r\n\t\t\tgroup += match[0];\r\n\t\t\tsoFar = soFar.slice( match[0].length );\r\n\r\n\t\t\t// Cast descendant combinators to space\r\n\t\t\tmatched = tokens.push({\r\n\t\t\t\tpart: match.pop().replace( rtrim, \" \" ),\r\n\t\t\t\tstring: match[0],\r\n\t\t\t\tcaptures: match\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// Filters\r\n\t\tfor ( type in filters ) {\r\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\r\n\t\t\t\t( match = preFilters[ type ](match, context, xml) )) ) {\r\n\r\n\t\t\t\tgroup += match[0];\r\n\t\t\t\tsoFar = soFar.slice( match[0].length );\r\n\t\t\t\tmatched = tokens.push({\r\n\t\t\t\t\tpart: type,\r\n\t\t\t\t\tstring: match.shift(),\r\n\t\t\t\t\tcaptures: match\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif ( !matched ) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\t// Attach the full group as a selector\r\n\tif ( group ) {\r\n\t\ttokens.selector = group;\r\n\t}\r\n\r\n\t// Return the length of the invalid excess\r\n\t// if we're just parsing\r\n\t// Otherwise, throw an error or return tokens\r\n\treturn parseOnly ?\r\n\t\tsoFar.length :\r\n\t\tsoFar ?\r\n\t\t\tSizzle.error( selector ) :\r\n\t\t\t// Cache the tokens\r\n\t\t\tslice.call( tokenCache(key, groups), 0 );\r\n}\r\n\r\nfunction addCombinator( matcher, combinator, context, xml ) {\r\n\tvar dir = combinator.dir,\r\n\t\tdoneName = done++;\r\n\r\n\tif ( !matcher ) {\r\n\t\t// If there is no matcher to check, check against the context\r\n\t\tmatcher = function( elem ) {\r\n\t\t\treturn elem === context;\r\n\t\t};\r\n\t}\r\n\treturn combinator.first ?\r\n\t\tfunction( elem ) {\r\n\t\t\twhile ( (elem = elem[ dir ]) ) {\r\n\t\t\t\tif ( elem.nodeType === 1 ) {\r\n\t\t\t\t\treturn matcher( elem ) && elem;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} :\r\n\t\txml ?\r\n\t\t\tfunction( elem ) {\r\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\r\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\r\n\t\t\t\t\t\tif ( matcher( elem ) ) {\r\n\t\t\t\t\t\t\treturn elem;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} :\r\n\t\t\tfunction( elem ) {\r\n\t\t\t\tvar cache,\r\n\t\t\t\t\tdirkey = doneName + \".\" + dirruns,\r\n\t\t\t\t\tcachedkey = dirkey + \".\" + cachedruns;\r\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\r\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\r\n\t\t\t\t\t\tif ( (cache = elem[ expando ]) === cachedkey ) {\r\n\t\t\t\t\t\t\treturn elem.sizset;\r\n\t\t\t\t\t\t} else if ( typeof cache === \"string\" && cache.indexOf(dirkey) === 0 ) {\r\n\t\t\t\t\t\t\tif ( elem.sizset ) {\r\n\t\t\t\t\t\t\t\treturn elem;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\telem[ expando ] = cachedkey;\r\n\t\t\t\t\t\t\tif ( matcher( elem ) ) {\r\n\t\t\t\t\t\t\t\telem.sizset = true;\r\n\t\t\t\t\t\t\t\treturn elem;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telem.sizset = false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n}\r\n\r\nfunction addMatcher( higher, deeper ) {\r\n\treturn higher ?\r\n\t\tfunction( elem ) {\r\n\t\t\tvar result = deeper( elem );\r\n\t\t\treturn result && higher( result === true ? elem : result );\r\n\t\t} :\r\n\t\tdeeper;\r\n}\r\n\r\n// [\"TAG\", \">\", \"ID\", \" \", \"CLASS\"]\r\nfunction matcherFromTokens( tokens, context, xml ) {\r\n\tvar token, matcher,\r\n\t\ti = 0;\r\n\r\n\tfor ( ; (token = tokens[i]); i++ ) {\r\n\t\tif ( Expr.relative[ token.part ] ) {\r\n\t\t\tmatcher = addCombinator( matcher, Expr.relative[ token.part ], context, xml );\r\n\t\t} else {\r\n\t\t\tmatcher = addMatcher( matcher, Expr.filter[ token.part ].apply(null, token.captures.concat( context, xml )) );\r\n\t\t}\r\n\t}\r\n\r\n\treturn matcher;\r\n}\r\n\r\nfunction matcherFromGroupMatchers( matchers ) {\r\n\treturn function( elem ) {\r\n\t\tvar matcher,\r\n\t\t\tj = 0;\r\n\t\tfor ( ; (matcher = matchers[j]); j++ ) {\r\n\t\t\tif ( matcher(elem) ) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t};\r\n}\r\n\r\ncompile = Sizzle.compile = function( selector, context, xml ) {\r\n\tvar group, i, len,\r\n\t\tcached = compilerCache[ expando ][ selector ];\r\n\r\n\t// Return a cached group function if already generated (context dependent)\r\n\tif ( cached && cached.context === context ) {\r\n\t\treturn cached;\r\n\t}\r\n\r\n\t// Generate a function of recursive functions that can be used to check each element\r\n\tgroup = tokenize( selector, context, xml );\r\n\tfor ( i = 0, len = group.length; i < len; i++ ) {\r\n\t\tgroup[i] = matcherFromTokens(group[i], context, xml);\r\n\t}\r\n\r\n\t// Cache the compiled function\r\n\tcached = compilerCache( selector, matcherFromGroupMatchers(group) );\r\n\tcached.context = context;\r\n\tcached.runs = cached.dirruns = 0;\r\n\treturn cached;\r\n};\r\n\r\nfunction multipleContexts( selector, contexts, results, seed ) {\r\n\tvar i = 0,\r\n\t\tlen = contexts.length;\r\n\tfor ( ; i < len; i++ ) {\r\n\t\tSizzle( selector, contexts[i], results, seed );\r\n\t}\r\n}\r\n\r\nfunction handlePOSGroup( selector, posfilter, argument, contexts, seed, not ) {\r\n\tvar results,\r\n\t\tfn = Expr.setFilters[ posfilter.toLowerCase() ];\r\n\r\n\tif ( !fn ) {\r\n\t\tSizzle.error( posfilter );\r\n\t}\r\n\r\n\tif ( selector || !(results = seed) ) {\r\n\t\tmultipleContexts( selector || \"*\", contexts, (results = []), seed );\r\n\t}\r\n\r\n\treturn results.length > 0 ? fn( results, argument, not ) : [];\r\n}\r\n\r\nfunction handlePOS( groups, context, results, seed ) {\r\n\tvar group, part, j, groupLen, token, selector,\r\n\t\tanchor, elements, match, matched,\r\n\t\tlastIndex, currentContexts, not,\r\n\t\ti = 0,\r\n\t\tlen = groups.length,\r\n\t\trpos = matchExpr[\"POS\"],\r\n\t\t// This is generated here in case matchExpr[\"POS\"] is extended\r\n\t\trposgroups = new RegExp( \"^\" + rpos.source + \"(?!\" + whitespace + \")\", \"i\" ),\r\n\t\t// This is for making sure non-participating\r\n\t\t// matching groups are represented cross-browser (IE6-8)\r\n\t\tsetUndefined = function() {\r\n\t\t\tvar i = 1,\r\n\t\t\t\tlen = arguments.length - 2;\r\n\t\t\tfor ( ; i < len; i++ ) {\r\n\t\t\t\tif ( arguments[i] === undefined ) {\r\n\t\t\t\t\tmatch[i] = undefined;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\tfor ( ; i < len; i++ ) {\r\n\t\tgroup = groups[i];\r\n\t\tpart = \"\";\r\n\t\telements = seed;\r\n\t\tfor ( j = 0, groupLen = group.length; j < groupLen; j++ ) {\r\n\t\t\ttoken = group[j];\r\n\t\t\tselector = token.string;\r\n\t\t\tif ( token.part === \"PSEUDO\" ) {\r\n\t\t\t\t// Reset regex index to 0\r\n\t\t\t\trpos.exec(\"\");\r\n\t\t\t\tanchor = 0;\r\n\t\t\t\twhile ( (match = rpos.exec( selector )) ) {\r\n\t\t\t\t\tmatched = true;\r\n\t\t\t\t\tlastIndex = rpos.lastIndex = match.index + match[0].length;\r\n\t\t\t\t\tif ( lastIndex > anchor ) {\r\n\t\t\t\t\t\tpart += selector.slice( anchor, match.index );\r\n\t\t\t\t\t\tanchor = lastIndex;\r\n\t\t\t\t\t\tcurrentContexts = [ context ];\r\n\r\n\t\t\t\t\t\tif ( rcombinators.test(part) ) {\r\n\t\t\t\t\t\t\tif ( elements ) {\r\n\t\t\t\t\t\t\t\tcurrentContexts = elements;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telements = seed;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( (not = rendsWithNot.test( part )) ) {\r\n\t\t\t\t\t\t\tpart = part.slice( 0, -5 ).replace( rcombinators, \"$&*\" );\r\n\t\t\t\t\t\t\tanchor++;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( match.length > 1 ) {\r\n\t\t\t\t\t\t\tmatch[0].replace( rposgroups, setUndefined );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telements = handlePOSGroup( part, match[1], match[2], currentContexts, elements, not );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpart = \"\";\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( !matched ) {\r\n\t\t\t\tpart += selector;\r\n\t\t\t}\r\n\t\t\tmatched = false;\r\n\t\t}\r\n\r\n\t\tif ( part ) {\r\n\t\t\tif ( rcombinators.test(part) ) {\r\n\t\t\t\tmultipleContexts( part, elements || [ context ], results, seed );\r\n\t\t\t} else {\r\n\t\t\t\tSizzle( part, context, results, seed ? seed.concat(elements) : elements );\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tpush.apply( results, elements );\r\n\t\t}\r\n\t}\r\n\r\n\t// Do not sort if this is a single filter\r\n\treturn len === 1 ? results : Sizzle.uniqueSort( results );\r\n}\r\n\r\nfunction select( selector, context, results, seed, xml ) {\r\n\t// Remove excessive whitespace\r\n\tselector = selector.replace( rtrim, \"$1\" );\r\n\tvar elements, matcher, cached, elem,\r\n\t\ti, tokens, token, lastToken, findContext, type,\r\n\t\tmatch = tokenize( selector, context, xml ),\r\n\t\tcontextNodeType = context.nodeType;\r\n\r\n\t// POS handling\r\n\tif ( matchExpr[\"POS\"].test(selector) ) {\r\n\t\treturn handlePOS( match, context, results, seed );\r\n\t}\r\n\r\n\tif ( seed ) {\r\n\t\telements = slice.call( seed, 0 );\r\n\r\n\t// To maintain document order, only narrow the\r\n\t// set if there is one group\r\n\t} else if ( match.length === 1 ) {\r\n\r\n\t\t// Take a shortcut and set the context if the root selector is an ID\r\n\t\tif ( (tokens = slice.call( match[0], 0 )).length > 2 &&\r\n\t\t\t\t(token = tokens[0]).part === \"ID\" &&\r\n\t\t\t\tcontextNodeType === 9 && !xml &&\r\n\t\t\t\tExpr.relative[ tokens[1].part ] ) {\r\n\r\n\t\t\tcontext = Expr.find[\"ID\"]( token.captures[0].replace( rbackslash, \"\" ), context, xml )[0];\r\n\t\t\tif ( !context ) {\r\n\t\t\t\treturn results;\r\n\t\t\t}\r\n\r\n\t\t\tselector = selector.slice( tokens.shift().string.length );\r\n\t\t}\r\n\r\n\t\tfindContext = ( (match = rsibling.exec( tokens[0].string )) && !match.index && context.parentNode ) || context;\r\n\r\n\t\t// Reduce the set if possible\r\n\t\tlastToken = \"\";\r\n\t\tfor ( i = tokens.length - 1; i >= 0; i-- ) {\r\n\t\t\ttoken = tokens[i];\r\n\t\t\ttype = token.part;\r\n\t\t\tlastToken = token.string + lastToken;\r\n\t\t\tif ( Expr.relative[ type ] ) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif ( Expr.order.test(type) ) {\r\n\t\t\t\telements = Expr.find[ type ]( token.captures[0].replace( rbackslash, \"\" ), findContext, xml );\r\n\t\t\t\tif ( elements == null ) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tselector = selector.slice( 0, selector.length - lastToken.length ) +\r\n\t\t\t\t\t\tlastToken.replace( matchExpr[ type ], \"\" );\r\n\r\n\t\t\t\t\tif ( !selector ) {\r\n\t\t\t\t\t\tpush.apply( results, slice.call(elements, 0) );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Only loop over the given elements once\r\n\tif ( selector ) {\r\n\t\tmatcher = compile( selector, context, xml );\r\n\t\tdirruns = matcher.dirruns++;\r\n\t\tif ( elements == null ) {\r\n\t\t\telements = Expr.find[\"TAG\"]( \"*\", (rsibling.test( selector ) && context.parentNode) || context );\r\n\t\t}\r\n\r\n\t\tfor ( i = 0; (elem = elements[i]); i++ ) {\r\n\t\t\tcachedruns = matcher.runs++;\r\n\t\t\tif ( matcher(elem) ) {\r\n\t\t\t\tresults.push( elem );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn results;\r\n}\r\n\r\nif ( document.querySelectorAll ) {\r\n\t(function() {\r\n\t\tvar disconnectedMatch,\r\n\t\t\toldSelect = select,\r\n\t\t\trescape = /'|\\\\/g,\r\n\t\t\trattributeQuotes = /\\=[\\x20\\t\\r\\n\\f]*([^'\"\\]]*)[\\x20\\t\\r\\n\\f]*\\]/g,\r\n\t\t\trbuggyQSA = [],\r\n\t\t\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\r\n\t\t\t// A support test would require too much code (would include document ready)\r\n\t\t\t// just skip matchesSelector for :active\r\n\t\t\trbuggyMatches = [\":active\"],\r\n\t\t\tmatches = docElem.matchesSelector ||\r\n\t\t\t\tdocElem.mozMatchesSelector ||\r\n\t\t\t\tdocElem.webkitMatchesSelector ||\r\n\t\t\t\tdocElem.oMatchesSelector ||\r\n\t\t\t\tdocElem.msMatchesSelector;\r\n\r\n\t\t// Build QSA regex\r\n\t\t// Regex strategy adopted from Diego Perini\r\n\t\tassert(function( div ) {\r\n\t\t\t// Select is set to empty string on purpose\r\n\t\t\t// This is to test IE's treatment of not explictly\r\n\t\t\t// setting a boolean content attribute,\r\n\t\t\t// since its presence should be enough\r\n\t\t\t// http://bugs.jquery.com/ticket/12359\r\n\t\t\tdiv.innerHTML = \"<select><option selected=''></option></select>\";\r\n\r\n\t\t\t// IE8 - Some boolean attributes are not treated correctly\r\n\t\t\tif ( !div.querySelectorAll(\"[selected]\").length ) {\r\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:checked|disabled|ismap|multiple|readonly|selected|value)\" );\r\n\t\t\t}\r\n\r\n\t\t\t// Webkit/Opera - :checked should return selected option elements\r\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\r\n\t\t\t// IE8 throws error here (do not put tests after this one)\r\n\t\t\tif ( !div.querySelectorAll(\":checked\").length ) {\r\n\t\t\t\trbuggyQSA.push(\":checked\");\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tassert(function( div ) {\r\n\r\n\t\t\t// Opera 10-12/IE9 - ^= $= *= and empty values\r\n\t\t\t// Should not select anything\r\n\t\t\tdiv.innerHTML = \"<p test=''></p>\";\r\n\t\t\tif ( div.querySelectorAll(\"[test^='']\").length ) {\r\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:\\\"\\\"|'')\" );\r\n\t\t\t}\r\n\r\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\r\n\t\t\t// IE8 throws error here (do not put tests after this one)\r\n\t\t\tdiv.innerHTML = \"<input type='hidden'/>\";\r\n\t\t\tif ( !div.querySelectorAll(\":enabled\").length ) {\r\n\t\t\t\trbuggyQSA.push(\":enabled\", \":disabled\");\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\r\n\r\n\t\tselect = function( selector, context, results, seed, xml ) {\r\n\t\t\t// Only use querySelectorAll when not filtering,\r\n\t\t\t// when this is not xml,\r\n\t\t\t// and when no QSA bugs apply\r\n\t\t\tif ( !seed && !xml && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\r\n\t\t\t\tif ( context.nodeType === 9 ) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tpush.apply( results, slice.call(context.querySelectorAll( selector ), 0) );\r\n\t\t\t\t\t\treturn results;\r\n\t\t\t\t\t} catch(qsaError) {}\r\n\t\t\t\t// qSA works strangely on Element-rooted queries\r\n\t\t\t\t// We can work around this by specifying an extra ID on the root\r\n\t\t\t\t// and working up from there (Thanks to Andrew Dupont for the technique)\r\n\t\t\t\t// IE 8 doesn't work on object elements\r\n\t\t\t\t} else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== \"object\" ) {\r\n\t\t\t\t\tvar groups, i, len,\r\n\t\t\t\t\t\told = context.getAttribute(\"id\"),\r\n\t\t\t\t\t\tnid = old || expando,\r\n\t\t\t\t\t\tnewContext = rsibling.test( selector ) && context.parentNode || context;\r\n\r\n\t\t\t\t\tif ( old ) {\r\n\t\t\t\t\t\tnid = nid.replace( rescape, \"\\\\$&\" );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcontext.setAttribute( \"id\", nid );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tgroups = tokenize(selector, context, xml);\r\n\t\t\t\t\t// Trailing space is unnecessary\r\n\t\t\t\t\t// There is always a context check\r\n\t\t\t\t\tnid = \"[id='\" + nid + \"']\";\r\n\t\t\t\t\tfor ( i = 0, len = groups.length; i < len; i++ ) {\r\n\t\t\t\t\t\tgroups[i] = nid + groups[i].selector;\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tpush.apply( results, slice.call( newContext.querySelectorAll(\r\n\t\t\t\t\t\t\tgroups.join(\",\")\r\n\t\t\t\t\t\t), 0 ) );\r\n\t\t\t\t\t\treturn results;\r\n\t\t\t\t\t} catch(qsaError) {\r\n\t\t\t\t\t} finally {\r\n\t\t\t\t\t\tif ( !old ) {\r\n\t\t\t\t\t\t\tcontext.removeAttribute(\"id\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn oldSelect( selector, context, results, seed, xml );\r\n\t\t};\r\n\r\n\t\tif ( matches ) {\r\n\t\t\tassert(function( div ) {\r\n\t\t\t\t// Check to see if it's possible to do matchesSelector\r\n\t\t\t\t// on a disconnected node (IE 9)\r\n\t\t\t\tdisconnectedMatch = matches.call( div, \"div\" );\r\n\r\n\t\t\t\t// This should fail with an exception\r\n\t\t\t\t// Gecko does not error, returns false instead\r\n\t\t\t\ttry {\r\n\t\t\t\t\tmatches.call( div, \"[test!='']:sizzle\" );\r\n\t\t\t\t\trbuggyMatches.push( matchExpr[\"PSEUDO\"].source, matchExpr[\"POS\"].source, \"!=\" );\r\n\t\t\t\t} catch ( e ) {}\r\n\t\t\t});\r\n\r\n\t\t\t// rbuggyMatches always contains :active, so no need for a length check\r\n\t\t\trbuggyMatches = /* rbuggyMatches.length && */ new RegExp( rbuggyMatches.join(\"|\") );\r\n\r\n\t\t\tSizzle.matchesSelector = function( elem, expr ) {\r\n\t\t\t\t// Make sure that attribute selectors are quoted\r\n\t\t\t\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\r\n\r\n\t\t\t\t// rbuggyMatches always contains :active, so no need for an existence check\r\n\t\t\t\tif ( !isXML( elem ) && !rbuggyMatches.test( expr ) && (!rbuggyQSA || !rbuggyQSA.test( expr )) ) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tvar ret = matches.call( elem, expr );\r\n\r\n\t\t\t\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\r\n\t\t\t\t\t\tif ( ret || disconnectedMatch ||\r\n\t\t\t\t\t\t\t\t// As well, disconnected nodes are said to be in a document\r\n\t\t\t\t\t\t\t\t// fragment in IE 9\r\n\t\t\t\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\r\n\t\t\t\t\t\t\treturn ret;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} catch(e) {}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn Sizzle( expr, null, null, [ elem ] ).length > 0;\r\n\t\t\t};\r\n\t\t}\r\n\t})();\r\n}\r\n\r\n// Deprecated\r\nExpr.setFilters[\"nth\"] = Expr.setFilters[\"eq\"];\r\n\r\n// Back-compat\r\nExpr.filters = Expr.pseudos;\r\n\r\n// Override sizzle attribute retrieval\nSizzle.attr = jQuery.attr;\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\njQuery.expr[\":\"] = jQuery.expr.pseudos;\njQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\n\r\n\r\n})( window );\r\nvar runtil = /Until$/,\n\trparentsprev = /^(?:parents|prev(?:Until|All))/,\n\tisSimple = /^.[^:#\\[\\.,]*$/,\n\trneedsContext = jQuery.expr.match.needsContext,\n\t// methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend({\n\tfind: function( selector ) {\n\t\tvar i, l, length, n, r, ret,\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn jQuery( selector ).filter(function() {\n\t\t\t\tfor ( i = 0, l = self.length; i < l; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tret = this.pushStack( \"\", \"find\", selector );\n\n\t\tfor ( i = 0, l = this.length; i < l; i++ ) {\n\t\t\tlength = ret.length;\n\t\t\tjQuery.find( selector, this[i], ret );\n\n\t\t\tif ( i > 0 ) {\n\t\t\t\t// Make sure that the results are unique\n\t\t\t\tfor ( n = length; n < ret.length; n++ ) {\n\t\t\t\t\tfor ( r = 0; r < length; r++ ) {\n\t\t\t\t\t\tif ( ret[r] === ret[n] ) {\n\t\t\t\t\t\t\tret.splice(n--, 1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\thas: function( target ) {\n\t\tvar i,\n\t\t\ttargets = jQuery( target, this ),\n\t\t\tlen = targets.length;\n\n\t\treturn this.filter(function() {\n\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[i] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector, false), \"not\", selector);\n\t},\n\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector, true), \"filter\", selector );\n\t},\n\n\tis: function( selector ) {\n\t\treturn !!selector && (\n\t\t\ttypeof selector === \"string\" ?\n\t\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\t\trneedsContext.test( selector ) ?\n\t\t\t\t\tjQuery( selector, this.context ).index( this[0] ) >= 0 :\n\t\t\t\t\tjQuery.filter( selector, this ).length > 0 :\n\t\t\t\tthis.filter( selector ).length > 0 );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tret = [],\n\t\t\tpos = rneedsContext.test( selectors ) || typeof selectors !== \"string\" ?\n\t\t\t\tjQuery( selectors, context || this.context ) :\n\t\t\t\t0;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tcur = this[i];\n\n\t\t\twhile ( cur && cur.ownerDocument && cur !== context && cur.nodeType !== 11 ) {\n\t\t\t\tif ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {\n\t\t\t\t\tret.push( cur );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t}\n\n\t\tret = ret.length > 1 ? jQuery.unique( ret ) : ret;\n\n\t\treturn this.pushStack( ret, \"closest\", selectors );\n\t},\n\n\t// Determine the position of an element within\n\t// the matched set of elements\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;\n\t\t}\n\n\t\t// index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn jQuery.inArray( this[0], jQuery( elem ) );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn jQuery.inArray(\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[0] : elem, this );\n\t},\n\n\tadd: function( selector, context ) {\n\t\tvar set = typeof selector === \"string\" ?\n\t\t\t\tjQuery( selector, context ) :\n\t\t\t\tjQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),\n\t\t\tall = jQuery.merge( this.get(), set );\n\n\t\treturn this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?\n\t\t\tall :\n\t\t\tjQuery.unique( all ) );\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter(selector)\n\t\t);\n\t}\n});\n\njQuery.fn.andSelf = jQuery.fn.addBack;\n\n// A painfully simple check to see if an element is disconnected\n// from a document (should be improved, where feasible).\nfunction isDisconnected( node ) {\n\treturn !node || !node.parentNode || node.parentNode.nodeType === 11;\n}\n\nfunction sibling( cur, dir ) {\n\tdo {\n\t\tcur = cur[ dir ];\n\t} while ( cur && cur.nodeType !== 1 );\n\n\treturn cur;\n}\n\njQuery.each({\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn jQuery.dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn jQuery.sibling( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\treturn jQuery.nodeName( elem, \"iframe\" ) ?\n\t\t\telem.contentDocument || elem.contentWindow.document :\n\t\t\tjQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar ret = jQuery.map( this, fn, until );\n\n\t\tif ( !runtil.test( name ) ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tret = jQuery.filter( selector, ret );\n\t\t}\n\n\t\tret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;\n\n\t\tif ( this.length > 1 && rparentsprev.test( name ) ) {\n\t\t\tret = ret.reverse();\n\t\t}\n\n\t\treturn this.pushStack( ret, name, core_slice.call( arguments ).join(\",\") );\n\t};\n});\n\njQuery.extend({\n\tfilter: function( expr, elems, not ) {\n\t\tif ( not ) {\n\t\t\texpr = \":not(\" + expr + \")\";\n\t\t}\n\n\t\treturn elems.length === 1 ?\n\t\t\tjQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :\n\t\t\tjQuery.find.matches(expr, elems);\n\t},\n\n\tdir: function( elem, dir, until ) {\n\t\tvar matched = [],\n\t\t\tcur = elem[ dir ];\n\n\t\twhile ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {\n\t\t\tif ( cur.nodeType === 1 ) {\n\t\t\t\tmatched.push( cur );\n\t\t\t}\n\t\t\tcur = cur[dir];\n\t\t}\n\t\treturn matched;\n\t},\n\n\tsibling: function( n, elem ) {\n\t\tvar r = [];\n\n\t\tfor ( ; n; n = n.nextSibling ) {\n\t\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\t\tr.push( n );\n\t\t\t}\n\t\t}\n\n\t\treturn r;\n\t}\n});\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, keep ) {\n\n\t// Can't pass null or undefined to indexOf in Firefox 4\n\t// Set to 0 to skip string check\n\tqualifier = qualifier || 0;\n\n\tif ( jQuery.isFunction( qualifier ) ) {\n\t\treturn jQuery.grep(elements, function( elem, i ) {\n\t\t\tvar retVal = !!qualifier.call( elem, i, elem );\n\t\t\treturn retVal === keep;\n\t\t});\n\n\t} else if ( qualifier.nodeType ) {\n\t\treturn jQuery.grep(elements, function( elem, i ) {\n\t\t\treturn ( elem === qualifier ) === keep;\n\t\t});\n\n\t} else if ( typeof qualifier === \"string\" ) {\n\t\tvar filtered = jQuery.grep(elements, function( elem ) {\n\t\t\treturn elem.nodeType === 1;\n\t\t});\n\n\t\tif ( isSimple.test( qualifier ) ) {\n\t\t\treturn jQuery.filter(qualifier, filtered, !keep);\n\t\t} else {\n\t\t\tqualifier = jQuery.filter( qualifier, filtered );\n\t\t}\n\t}\n\n\treturn jQuery.grep(elements, function( elem, i ) {\n\t\treturn ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;\n\t});\n}\nfunction createSafeFragment( document ) {\n\tvar list = nodeNames.split( \"|\" ),\n\tsafeFrag = document.createDocumentFragment();\n\n\tif ( safeFrag.createElement ) {\n\t\twhile ( list.length ) {\n\t\t\tsafeFrag.createElement(\n\t\t\t\tlist.pop()\n\t\t\t);\n\t\t}\n\t}\n\treturn safeFrag;\n}\n\nvar nodeNames = \"abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|\" +\n\t\t\"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video\",\n\trinlinejQuery = / jQuery\\d+=\"(?:null|\\d+)\"/g,\n\trleadingWhitespace = /^\\s+/,\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n\trtagName = /<([\\w:]+)/,\n\trtbody = /<tbody/i,\n\trhtml = /<|&#?\\w+;/,\n\trnoInnerhtml = /<(?:script|style|link)/i,\n\trnocache = /<(?:script|object|embed|option|style)/i,\n\trnoshimcache = new RegExp(\"<(?:\" + nodeNames + \")[\\\\s/>]\", \"i\"),\n\trcheckableType = /^(?:checkbox|radio)$/,\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trscriptType = /\\/(java|ecma)script/i,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|\\-\\-)|[\\]\\-]{2}>\\s*$/g,\n\twrapMap = {\n\t\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\t\tlegend: [ 1, \"<fieldset>\", \"</fieldset>\" ],\n\t\tthead: [ 1, \"<table>\", \"</table>\" ],\n\t\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\t\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\t\tcol: [ 2, \"<table><tbody></tbody><colgroup>\", \"</colgroup></table>\" ],\n\t\tarea: [ 1, \"<map>\", \"</map>\" ],\n\t\t_default: [ 0, \"\", \"\" ]\n\t},\n\tsafeFragment = createSafeFragment( document ),\n\tfragmentDiv = safeFragment.appendChild( document.createElement(\"div\") );\n\nwrapMap.optgroup = wrapMap.option;\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,\n// unless wrapped in a div with non-breaking characters in front of it.\nif ( !jQuery.support.htmlSerialize ) {\n\twrapMap._default = [ 1, \"X<div>\", \"</div>\" ];\n}\n\njQuery.fn.extend({\n\ttext: function( value ) {\n\t\treturn jQuery.access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );\n\t\t}, null, value, arguments.length );\n\t},\n\n\twrapAll: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function(i) {\n\t\t\t\tjQuery(this).wrapAll( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\tif ( this[0] ) {\n\t\t\t// The elements to wrap the target around\n\t\t\tvar wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);\n\n\t\t\tif ( this[0].parentNode ) {\n\t\t\t\twrap.insertBefore( this[0] );\n\t\t\t}\n\n\t\t\twrap.map(function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstChild && elem.firstChild.nodeType === 1 ) {\n\t\t\t\t\telem = elem.firstChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t}).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function(i) {\n\t\t\t\tjQuery(this).wrapInner( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t});\n\t},\n\n\twrap: function( html ) {\n\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\treturn this.each(function(i) {\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );\n\t\t});\n\t},\n\n\tunwrap: function() {\n\t\treturn this.parent().each(function() {\n\t\t\tif ( !jQuery.nodeName( this, \"body\" ) ) {\n\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t\t}\n\t\t}).end();\n\t},\n\n\tappend: function() {\n\t\treturn this.domManip(arguments, true, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 ) {\n\t\t\t\tthis.appendChild( elem );\n\t\t\t}\n\t\t});\n\t},\n\n\tprepend: function() {\n\t\treturn this.domManip(arguments, true, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 ) {\n\t\t\t\tthis.insertBefore( elem, this.firstChild );\n\t\t\t}\n\t\t});\n\t},\n\n\tbefore: function() {\n\t\tif ( !isDisconnected( this[0] ) ) {\n\t\t\treturn this.domManip(arguments, false, function( elem ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t});\n\t\t}\n\n\t\tif ( arguments.length ) {\n\t\t\tvar set = jQuery.clean( arguments );\n\t\t\treturn this.pushStack( jQuery.merge( set, this ), \"before\", this.selector );\n\t\t}\n\t},\n\n\tafter: function() {\n\t\tif ( !isDisconnected( this[0] ) ) {\n\t\t\treturn this.domManip(arguments, false, function( elem ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t});\n\t\t}\n\n\t\tif ( arguments.length ) {\n\t\t\tvar set = jQuery.clean( arguments );\n\t\t\treturn this.pushStack( jQuery.merge( this, set ), \"after\", this.selector );\n\t\t}\n\t},\n\n\t// keepData is for internal use only--do not document\n\tremove: function( selector, keepData ) {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = this[i]) != null; i++ ) {\n\t\t\tif ( !selector || jQuery.filter( selector, [ elem ] ).length ) {\n\t\t\t\tif ( !keepData && elem.nodeType === 1 ) {\n\t\t\t\t\tjQuery.cleanData( elem.getElementsByTagName(\"*\") );\n\t\t\t\t\tjQuery.cleanData( [ elem ] );\n\t\t\t\t}\n\n\t\t\t\tif ( elem.parentNode ) {\n\t\t\t\t\telem.parentNode.removeChild( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = this[i]) != null; i++ ) {\n\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\tjQuery.cleanData( elem.getElementsByTagName(\"*\") );\n\t\t\t}\n\n\t\t\t// Remove any remaining nodes\n\t\t\twhile ( elem.firstChild ) {\n\t\t\t\telem.removeChild( elem.firstChild );\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function () {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t});\n\t},\n\n\thtml: function( value ) {\n\t\treturn jQuery.access( this, function( value ) {\n\t\t\tvar elem = this[0] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined ) {\n\t\t\t\treturn elem.nodeType === 1 ?\n\t\t\t\t\telem.innerHTML.replace( rinlinejQuery, \"\" ) :\n\t\t\t\t\tundefined;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t( jQuery.support.htmlSerialize || !rnoshimcache.test( value )  ) &&\n\t\t\t\t( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [\"\", \"\"] )[1].toLowerCase() ] ) {\n\n\t\t\t\tvalue = value.replace( rxhtmlTag, \"<$1></$2>\" );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor (; i < l; i++ ) {\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\telem = this[i] || {};\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( elem.getElementsByTagName( \"*\" ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch(e) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function( value ) {\n\t\tif ( !isDisconnected( this[0] ) ) {\n\t\t\t// Make sure that the elements are removed from the DOM before they are inserted\n\t\t\t// this can help fix replacing a parent with child elements\n\t\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\t\treturn this.each(function(i) {\n\t\t\t\t\tvar self = jQuery(this), old = self.html();\n\t\t\t\t\tself.replaceWith( value.call( this, i, old ) );\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ( typeof value !== \"string\" ) {\n\t\t\t\tvalue = jQuery( value ).detach();\n\t\t\t}\n\n\t\t\treturn this.each(function() {\n\t\t\t\tvar next = this.nextSibling,\n\t\t\t\t\tparent = this.parentNode;\n\n\t\t\t\tjQuery( this ).remove();\n\n\t\t\t\tif ( next ) {\n\t\t\t\t\tjQuery(next).before( value );\n\t\t\t\t} else {\n\t\t\t\t\tjQuery(parent).append( value );\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn this.length ?\n\t\t\tthis.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), \"replaceWith\", value ) :\n\t\t\tthis;\n\t},\n\n\tdetach: function( selector ) {\n\t\treturn this.remove( selector, true );\n\t},\n\n\tdomManip: function( args, table, callback ) {\n\n\t\t// Flatten any nested arrays\n\t\targs = [].concat.apply( [], args );\n\n\t\tvar results, first, fragment, iNoClone,\n\t\t\ti = 0,\n\t\t\tvalue = args[0],\n\t\t\tscripts = [],\n\t\t\tl = this.length;\n\n\t\t// We can't cloneNode fragments that contain checked, in WebKit\n\t\tif ( !jQuery.support.checkClone && l > 1 && typeof value === \"string\" && rchecked.test( value ) ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tjQuery(this).domManip( args, table, callback );\n\t\t\t});\n\t\t}\n\n\t\tif ( jQuery.isFunction(value) ) {\n\t\t\treturn this.each(function(i) {\n\t\t\t\tvar self = jQuery(this);\n\t\t\t\targs[0] = value.call( this, i, table ? self.html() : undefined );\n\t\t\t\tself.domManip( args, table, callback );\n\t\t\t});\n\t\t}\n\n\t\tif ( this[0] ) {\n\t\t\tresults = jQuery.buildFragment( args, this, scripts );\n\t\t\tfragment = results.fragment;\n\t\t\tfirst = fragment.firstChild;\n\n\t\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\t\tfragment = first;\n\t\t\t}\n\n\t\t\tif ( first ) {\n\t\t\t\ttable = table && jQuery.nodeName( first, \"tr\" );\n\n\t\t\t\t// Use the original fragment for the last item instead of the first because it can end up\n\t\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\t\t// Fragments from the fragment cache must always be cloned and never used in place.\n\t\t\t\tfor ( iNoClone = results.cacheable || l - 1; i < l; i++ ) {\n\t\t\t\t\tcallback.call(\n\t\t\t\t\t\ttable && jQuery.nodeName( this[i], \"table\" ) ?\n\t\t\t\t\t\t\tfindOrAppend( this[i], \"tbody\" ) :\n\t\t\t\t\t\t\tthis[i],\n\t\t\t\t\t\ti === iNoClone ?\n\t\t\t\t\t\t\tfragment :\n\t\t\t\t\t\t\tjQuery.clone( fragment, true, true )\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fix #11809: Avoid leaking memory\n\t\t\tfragment = first = null;\n\n\t\t\tif ( scripts.length ) {\n\t\t\t\tjQuery.each( scripts, function( i, elem ) {\n\t\t\t\t\tif ( elem.src ) {\n\t\t\t\t\t\tif ( jQuery.ajax ) {\n\t\t\t\t\t\t\tjQuery.ajax({\n\t\t\t\t\t\t\t\turl: elem.src,\n\t\t\t\t\t\t\t\ttype: \"GET\",\n\t\t\t\t\t\t\t\tdataType: \"script\",\n\t\t\t\t\t\t\t\tasync: false,\n\t\t\t\t\t\t\t\tglobal: false,\n\t\t\t\t\t\t\t\t\"throws\": true\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjQuery.error(\"no ajax\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || \"\" ).replace( rcleanScript, \"\" ) );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( elem.parentNode ) {\n\t\t\t\t\t\telem.parentNode.removeChild( elem );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n});\n\nfunction findOrAppend( elem, tag ) {\n\treturn elem.getElementsByTagName( tag )[0] || elem.appendChild( elem.ownerDocument.createElement( tag ) );\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\n\tif ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {\n\t\treturn;\n\t}\n\n\tvar type, i, l,\n\t\toldData = jQuery._data( src ),\n\t\tcurData = jQuery._data( dest, oldData ),\n\t\tevents = oldData.events;\n\n\tif ( events ) {\n\t\tdelete curData.handle;\n\t\tcurData.events = {};\n\n\t\tfor ( type in events ) {\n\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t}\n\t\t}\n\t}\n\n\t// make the cloned public data object a copy from the original\n\tif ( curData.data ) {\n\t\tcurData.data = jQuery.extend( {}, curData.data );\n\t}\n}\n\nfunction cloneFixAttributes( src, dest ) {\n\tvar nodeName;\n\n\t// We do not need to do anything for non-Elements\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// clearAttributes removes the attributes, which we don't want,\n\t// but also removes the attachEvent events, which we *do* want\n\tif ( dest.clearAttributes ) {\n\t\tdest.clearAttributes();\n\t}\n\n\t// mergeAttributes, in contrast, only merges back on the\n\t// original attributes, not the events\n\tif ( dest.mergeAttributes ) {\n\t\tdest.mergeAttributes( src );\n\t}\n\n\tnodeName = dest.nodeName.toLowerCase();\n\n\tif ( nodeName === \"object\" ) {\n\t\t// IE6-10 improperly clones children of object elements using classid.\n\t\t// IE10 throws NoModificationAllowedError if parent is null, #12132.\n\t\tif ( dest.parentNode ) {\n\t\t\tdest.outerHTML = src.outerHTML;\n\t\t}\n\n\t\t// This path appears unavoidable for IE9. When cloning an object\n\t\t// element in IE9, the outerHTML strategy above is not sufficient.\n\t\t// If the src has innerHTML and the destination does not,\n\t\t// copy the src.innerHTML into the dest.innerHTML. #10324\n\t\tif ( jQuery.support.html5Clone && (src.innerHTML && !jQuery.trim(dest.innerHTML)) ) {\n\t\t\tdest.innerHTML = src.innerHTML;\n\t\t}\n\n\t} else if ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\t// IE6-8 fails to persist the checked state of a cloned checkbox\n\t\t// or radio button. Worse, IE6-7 fail to give the cloned element\n\t\t// a checked appearance if the defaultChecked value isn't also set\n\n\t\tdest.defaultChecked = dest.checked = src.checked;\n\n\t\t// IE6-7 get confused and end up setting the value of a cloned\n\t\t// checkbox/radio button to an empty string instead of \"on\"\n\t\tif ( dest.value !== src.value ) {\n\t\t\tdest.value = src.value;\n\t\t}\n\n\t// IE6-8 fails to return the selected option to the default selected\n\t// state when cloning options\n\t} else if ( nodeName === \"option\" ) {\n\t\tdest.selected = src.defaultSelected;\n\n\t// IE6-8 fails to set the defaultValue to the correct value when\n\t// cloning other types of input fields\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\n\t// IE blanks contents when cloning scripts\n\t} else if ( nodeName === \"script\" && dest.text !== src.text ) {\n\t\tdest.text = src.text;\n\t}\n\n\t// Event data gets referenced instead of copied if the expando\n\t// gets copied too\n\tdest.removeAttribute( jQuery.expando );\n}\n\njQuery.buildFragment = function( args, context, scripts ) {\n\tvar fragment, cacheable, cachehit,\n\t\tfirst = args[ 0 ];\n\n\t// Set context from what may come in as undefined or a jQuery collection or a node\n\t// Updated to fix #12266 where accessing context[0] could throw an exception in IE9/10 &\n\t// also doubles as fix for #8950 where plain objects caused createDocumentFragment exception\n\tcontext = context || document;\n\tcontext = !context.nodeType && context[0] || context;\n\tcontext = context.ownerDocument || context;\n\n\t// Only cache \"small\" (1/2 KB) HTML strings that are associated with the main document\n\t// Cloning options loses the selected state, so don't cache them\n\t// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment\n\t// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache\n\t// Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501\n\tif ( args.length === 1 && typeof first === \"string\" && first.length < 512 && context === document &&\n\t\tfirst.charAt(0) === \"<\" && !rnocache.test( first ) &&\n\t\t(jQuery.support.checkClone || !rchecked.test( first )) &&\n\t\t(jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {\n\n\t\t// Mark cacheable and look for a hit\n\t\tcacheable = true;\n\t\tfragment = jQuery.fragments[ first ];\n\t\tcachehit = fragment !== undefined;\n\t}\n\n\tif ( !fragment ) {\n\t\tfragment = context.createDocumentFragment();\n\t\tjQuery.clean( args, context, fragment, scripts );\n\n\t\t// Update the cache, but only store false\n\t\t// unless this is a second parsing of the same content\n\t\tif ( cacheable ) {\n\t\t\tjQuery.fragments[ first ] = cachehit && fragment;\n\t\t}\n\t}\n\n\treturn { fragment: fragment, cacheable: cacheable };\n};\n\njQuery.fragments = {};\n\njQuery.each({\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\ti = 0,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tl = insert.length,\n\t\t\tparent = this.length === 1 && this[0].parentNode;\n\n\t\tif ( (parent == null || parent && parent.nodeType === 11 && parent.childNodes.length === 1) && l === 1 ) {\n\t\t\tinsert[ original ]( this[0] );\n\t\t\treturn this;\n\t\t} else {\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\telems = ( i > 0 ? this.clone(true) : this ).get();\n\t\t\t\tjQuery( insert[i] )[ original ]( elems );\n\t\t\t\tret = ret.concat( elems );\n\t\t\t}\n\n\t\t\treturn this.pushStack( ret, name, insert.selector );\n\t\t}\n\t};\n});\n\nfunction getAll( elem ) {\n\tif ( typeof elem.getElementsByTagName !== \"undefined\" ) {\n\t\treturn elem.getElementsByTagName( \"*\" );\n\n\t} else if ( typeof elem.querySelectorAll !== \"undefined\" ) {\n\t\treturn elem.querySelectorAll( \"*\" );\n\n\t} else {\n\t\treturn [];\n\t}\n}\n\n// Used in clean, fixes the defaultChecked property\nfunction fixDefaultChecked( elem ) {\n\tif ( rcheckableType.test( elem.type ) ) {\n\t\telem.defaultChecked = elem.checked;\n\t}\n}\n\njQuery.extend({\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar srcElements,\n\t\t\tdestElements,\n\t\t\ti,\n\t\t\tclone;\n\n\t\tif ( jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( \"<\" + elem.nodeName + \">\" ) ) {\n\t\t\tclone = elem.cloneNode( true );\n\n\t\t// IE<=8 does not properly clone detached, unknown element nodes\n\t\t} else {\n\t\t\tfragmentDiv.innerHTML = elem.outerHTML;\n\t\t\tfragmentDiv.removeChild( clone = fragmentDiv.firstChild );\n\t\t}\n\n\t\tif ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&\n\t\t\t\t(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {\n\t\t\t// IE copies events bound via attachEvent when using cloneNode.\n\t\t\t// Calling detachEvent on the clone will also remove the events\n\t\t\t// from the original. In order to get around this, we use some\n\t\t\t// proprietary methods to clear the events. Thanks to MooTools\n\t\t\t// guys for this hotness.\n\n\t\t\tcloneFixAttributes( elem, clone );\n\n\t\t\t// Using Sizzle here is crazy slow, so we use getElementsByTagName instead\n\t\t\tsrcElements = getAll( elem );\n\t\t\tdestElements = getAll( clone );\n\n\t\t\t// Weird iteration because IE will replace the length property\n\t\t\t// with an element if you are cloning the body and one of the\n\t\t\t// elements on the page has a name or id of \"length\"\n\t\t\tfor ( i = 0; srcElements[i]; ++i ) {\n\t\t\t\t// Ensure that the destination node is not null; Fixes #9587\n\t\t\t\tif ( destElements[i] ) {\n\t\t\t\t\tcloneFixAttributes( srcElements[i], destElements[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tcloneCopyEvent( elem, clone );\n\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = getAll( elem );\n\t\t\t\tdestElements = getAll( clone );\n\n\t\t\t\tfor ( i = 0; srcElements[i]; ++i ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[i], destElements[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsrcElements = destElements = null;\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tclean: function( elems, context, fragment, scripts ) {\n\t\tvar i, j, elem, tag, wrap, depth, div, hasBody, tbody, len, handleScript, jsTags,\n\t\t\tsafe = context === document && safeFragment,\n\t\t\tret = [];\n\n\t\t// Ensure that context is a document\n\t\tif ( !context || typeof context.createDocumentFragment === \"undefined\" ) {\n\t\t\tcontext = document;\n\t\t}\n\n\t\t// Use the already-created safe fragment if context permits\n\t\tfor ( i = 0; (elem = elems[i]) != null; i++ ) {\n\t\t\tif ( typeof elem === \"number\" ) {\n\t\t\t\telem += \"\";\n\t\t\t}\n\n\t\t\tif ( !elem ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Convert html string into DOM nodes\n\t\t\tif ( typeof elem === \"string\" ) {\n\t\t\t\tif ( !rhtml.test( elem ) ) {\n\t\t\t\t\telem = context.createTextNode( elem );\n\t\t\t\t} else {\n\t\t\t\t\t// Ensure a safe container in which to render the html\n\t\t\t\t\tsafe = safe || createSafeFragment( context );\n\t\t\t\t\tdiv = context.createElement(\"div\");\n\t\t\t\t\tsafe.appendChild( div );\n\n\t\t\t\t\t// Fix \"XHTML\"-style tags in all browsers\n\t\t\t\t\telem = elem.replace(rxhtmlTag, \"<$1></$2>\");\n\n\t\t\t\t\t// Go to html and back, then peel off extra wrappers\n\t\t\t\t\ttag = ( rtagName.exec( elem ) || [\"\", \"\"] )[1].toLowerCase();\n\t\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\t\tdepth = wrap[0];\n\t\t\t\t\tdiv.innerHTML = wrap[1] + elem + wrap[2];\n\n\t\t\t\t\t// Move to the right depth\n\t\t\t\t\twhile ( depth-- ) {\n\t\t\t\t\t\tdiv = div.lastChild;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Remove IE's autoinserted <tbody> from table fragments\n\t\t\t\t\tif ( !jQuery.support.tbody ) {\n\n\t\t\t\t\t\t// String was a <table>, *may* have spurious <tbody>\n\t\t\t\t\t\thasBody = rtbody.test(elem);\n\t\t\t\t\t\t\ttbody = tag === \"table\" && !hasBody ?\n\t\t\t\t\t\t\t\tdiv.firstChild && div.firstChild.childNodes :\n\n\t\t\t\t\t\t\t\t// String was a bare <thead> or <tfoot>\n\t\t\t\t\t\t\t\twrap[1] === \"<table>\" && !hasBody ?\n\t\t\t\t\t\t\t\t\tdiv.childNodes :\n\t\t\t\t\t\t\t\t\t[];\n\n\t\t\t\t\t\tfor ( j = tbody.length - 1; j >= 0 ; --j ) {\n\t\t\t\t\t\t\tif ( jQuery.nodeName( tbody[ j ], \"tbody\" ) && !tbody[ j ].childNodes.length ) {\n\t\t\t\t\t\t\t\ttbody[ j ].parentNode.removeChild( tbody[ j ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// IE completely kills leading whitespace when innerHTML is used\n\t\t\t\t\tif ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {\n\t\t\t\t\t\tdiv.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );\n\t\t\t\t\t}\n\n\t\t\t\t\telem = div.childNodes;\n\n\t\t\t\t\t// Take out of fragment container (we need a fresh div each time)\n\t\t\t\t\tdiv.parentNode.removeChild( div );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( elem.nodeType ) {\n\t\t\t\tret.push( elem );\n\t\t\t} else {\n\t\t\t\tjQuery.merge( ret, elem );\n\t\t\t}\n\t\t}\n\n\t\t// Fix #11356: Clear elements from safeFragment\n\t\tif ( div ) {\n\t\t\telem = div = safe = null;\n\t\t}\n\n\t\t// Reset defaultChecked for any radios and checkboxes\n\t\t// about to be appended to the DOM in IE 6/7 (#8060)\n\t\tif ( !jQuery.support.appendChecked ) {\n\t\t\tfor ( i = 0; (elem = ret[i]) != null; i++ ) {\n\t\t\t\tif ( jQuery.nodeName( elem, \"input\" ) ) {\n\t\t\t\t\tfixDefaultChecked( elem );\n\t\t\t\t} else if ( typeof elem.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\t\tjQuery.grep( elem.getElementsByTagName(\"input\"), fixDefaultChecked );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Append elements to a provided document fragment\n\t\tif ( fragment ) {\n\t\t\t// Special handling of each script element\n\t\t\thandleScript = function( elem ) {\n\t\t\t\t// Check if we consider it executable\n\t\t\t\tif ( !elem.type || rscriptType.test( elem.type ) ) {\n\t\t\t\t\t// Detach the script and store it in the scripts array (if provided) or the fragment\n\t\t\t\t\t// Return truthy to indicate that it has been handled\n\t\t\t\t\treturn scripts ?\n\t\t\t\t\t\tscripts.push( elem.parentNode ? elem.parentNode.removeChild( elem ) : elem ) :\n\t\t\t\t\t\tfragment.appendChild( elem );\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tfor ( i = 0; (elem = ret[i]) != null; i++ ) {\n\t\t\t\t// Check if we're done after handling an executable script\n\t\t\t\tif ( !( jQuery.nodeName( elem, \"script\" ) && handleScript( elem ) ) ) {\n\t\t\t\t\t// Append to fragment and handle embedded scripts\n\t\t\t\t\tfragment.appendChild( elem );\n\t\t\t\t\tif ( typeof elem.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\t\t\t// handleScript alters the DOM, so use jQuery.merge to ensure snapshot iteration\n\t\t\t\t\t\tjsTags = jQuery.grep( jQuery.merge( [], elem.getElementsByTagName(\"script\") ), handleScript );\n\n\t\t\t\t\t\t// Splice the scripts into ret after their former ancestor and advance our index beyond them\n\t\t\t\t\t\tret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );\n\t\t\t\t\t\ti += jsTags.length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tcleanData: function( elems, /* internal */ acceptData ) {\n\t\tvar data, id, elem, type,\n\t\t\ti = 0,\n\t\t\tinternalKey = jQuery.expando,\n\t\t\tcache = jQuery.cache,\n\t\t\tdeleteExpando = jQuery.support.deleteExpando,\n\t\t\tspecial = jQuery.event.special;\n\n\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\n\t\t\tif ( acceptData || jQuery.acceptData( elem ) ) {\n\n\t\t\t\tid = elem[ internalKey ];\n\t\t\t\tdata = id && cache[ id ];\n\n\t\t\t\tif ( data ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Remove cache only if it was not already removed by jQuery.event.remove\n\t\t\t\t\tif ( cache[ id ] ) {\n\n\t\t\t\t\t\tdelete cache[ id ];\n\n\t\t\t\t\t\t// IE does not allow us to delete expando properties from nodes,\n\t\t\t\t\t\t// nor does it have a removeAttribute function on Document nodes;\n\t\t\t\t\t\t// we must handle all of these cases\n\t\t\t\t\t\tif ( deleteExpando ) {\n\t\t\t\t\t\t\tdelete elem[ internalKey ];\n\n\t\t\t\t\t\t} else if ( elem.removeAttribute ) {\n\t\t\t\t\t\t\telem.removeAttribute( internalKey );\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\telem[ internalKey ] = null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tjQuery.deletedIds.push( id );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n// Limit scope pollution from any deprecated API\n(function() {\n\nvar matched, browser;\n\n// Use of jQuery.browser is frowned upon.\n// More details: http://api.jquery.com/jQuery.browser\n// jQuery.uaMatch maintained for back-compat\njQuery.uaMatch = function( ua ) {\n\tua = ua.toLowerCase();\n\n\tvar match = /(chrome)[ \\/]([\\w.]+)/.exec( ua ) ||\n\t\t/(webkit)[ \\/]([\\w.]+)/.exec( ua ) ||\n\t\t/(opera)(?:.*version|)[ \\/]([\\w.]+)/.exec( ua ) ||\n\t\t/(msie) ([\\w.]+)/.exec( ua ) ||\n\t\tua.indexOf(\"compatible\") < 0 && /(mozilla)(?:.*? rv:([\\w.]+)|)/.exec( ua ) ||\n\t\t[];\n\n\treturn {\n\t\tbrowser: match[ 1 ] || \"\",\n\t\tversion: match[ 2 ] || \"0\"\n\t};\n};\n\nmatched = jQuery.uaMatch( navigator.userAgent );\nbrowser = {};\n\nif ( matched.browser ) {\n\tbrowser[ matched.browser ] = true;\n\tbrowser.version = matched.version;\n}\n\n// Chrome is Webkit, but Webkit is also Safari.\nif ( browser.chrome ) {\n\tbrowser.webkit = true;\n} else if ( browser.webkit ) {\n\tbrowser.safari = true;\n}\n\njQuery.browser = browser;\n\njQuery.sub = function() {\n\tfunction jQuerySub( selector, context ) {\n\t\treturn new jQuerySub.fn.init( selector, context );\n\t}\n\tjQuery.extend( true, jQuerySub, this );\n\tjQuerySub.superclass = this;\n\tjQuerySub.fn = jQuerySub.prototype = this();\n\tjQuerySub.fn.constructor = jQuerySub;\n\tjQuerySub.sub = this.sub;\n\tjQuerySub.fn.init = function init( selector, context ) {\n\t\tif ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {\n\t\t\tcontext = jQuerySub( context );\n\t\t}\n\n\t\treturn jQuery.fn.init.call( this, selector, context, rootjQuerySub );\n\t};\n\tjQuerySub.fn.init.prototype = jQuerySub.fn;\n\tvar rootjQuerySub = jQuerySub(document);\n\treturn jQuerySub;\n};\n\n})();\nvar curCSS, iframe, iframeDoc,\n\tralpha = /alpha\\([^)]*\\)/i,\n\tropacity = /opacity=([^)]*)/,\n\trposition = /^(top|right|bottom|left)$/,\n\t// swappable if display is none or starts with table except \"table\", \"table-cell\", or \"table-caption\"\n\t// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trmargin = /^margin/,\n\trnumsplit = new RegExp( \"^(\" + core_pnum + \")(.*)$\", \"i\" ),\n\trnumnonpx = new RegExp( \"^(\" + core_pnum + \")(?!px)[a-z%]+$\", \"i\" ),\n\trrelNum = new RegExp( \"^([-+])=(\" + core_pnum + \")\", \"i\" ),\n\telemdisplay = {},\n\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: 0,\n\t\tfontWeight: 400\n\t},\n\n\tcssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ],\n\tcssPrefixes = [ \"Webkit\", \"O\", \"Moz\", \"ms\" ],\n\n\teventsToggle = jQuery.fn.toggle;\n\n// return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( style, name ) {\n\n\t// shortcut for names that are not vendor prefixed\n\tif ( name in style ) {\n\t\treturn name;\n\t}\n\n\t// check for vendor prefixed names\n\tvar capName = name.charAt(0).toUpperCase() + name.slice(1),\n\t\torigName = name,\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in style ) {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\treturn origName;\n}\n\nfunction isHidden( elem, el ) {\n\telem = el || elem;\n\treturn jQuery.css( elem, \"display\" ) === \"none\" || !jQuery.contains( elem.ownerDocument, elem );\n}\n\nfunction showHide( elements, show ) {\n\tvar elem, display,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\t\tvalues[ index ] = jQuery._data( elem, \"olddisplay\" );\n\t\tif ( show ) {\n\t\t\t// Reset the inline display of this element to learn if it is\n\t\t\t// being hidden by cascaded rules or not\n\t\t\tif ( !values[ index ] && elem.style.display === \"none\" ) {\n\t\t\t\telem.style.display = \"\";\n\t\t\t}\n\n\t\t\t// Set elements which have been overridden with display: none\n\t\t\t// in a stylesheet to whatever the default browser style is\n\t\t\t// for such an element\n\t\t\tif ( elem.style.display === \"\" && isHidden( elem ) ) {\n\t\t\t\tvalues[ index ] = jQuery._data( elem, \"olddisplay\", css_defaultDisplay(elem.nodeName) );\n\t\t\t}\n\t\t} else {\n\t\t\tdisplay = curCSS( elem, \"display\" );\n\n\t\t\tif ( !values[ index ] && display !== \"none\" ) {\n\t\t\t\tjQuery._data( elem, \"olddisplay\", display );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of most of the elements in a second loop\n\t// to avoid the constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( !show || elem.style.display === \"none\" || elem.style.display === \"\" ) {\n\t\t\telem.style.display = show ? values[ index ] || \"\" : \"none\";\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend({\n\tcss: function( name, value ) {\n\t\treturn jQuery.access( this, function( elem, name, value ) {\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t},\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state, fn2 ) {\n\t\tvar bool = typeof state === \"boolean\";\n\n\t\tif ( jQuery.isFunction( state ) && jQuery.isFunction( fn2 ) ) {\n\t\t\treturn eventsToggle.apply( this, arguments );\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( bool ? state : isHidden( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t});\n\t}\n});\n\njQuery.extend({\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Exclude the following css properties to add px\n\tcssNumber: {\n\t\t\"fillOpacity\": true,\n\t\t\"fontWeight\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {\n\t\t// normalize float css property\n\t\t\"float\": jQuery.support.cssFloat ? \"cssFloat\" : \"styleFloat\"\n\t},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tstyle = elem.style;\n\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );\n\n\t\t// gets hook for the prefixed version\n\t\t// followed by the unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// convert relative number strings (+= or -=) to relative numbers. #7345\n\t\t\tif ( type === \"string\" && (ret = rrelNum.exec( value )) ) {\n\t\t\t\tvalue = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that NaN and null values aren't set. See: #7116\n\t\t\tif ( value == null || type === \"number\" && isNaN( value ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add 'px' to the (except for certain CSS properties)\n\t\t\tif ( type === \"number\" && !jQuery.cssNumber[ origName ] ) {\n\t\t\t\tvalue += \"px\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !(\"set\" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {\n\t\t\t\t// Wrapped to prevent IE from throwing errors when 'invalid' values are provided\n\t\t\t\t// Fixes bug #5509\n\t\t\t\ttry {\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t} catch(e) {}\n\t\t\t}\n\n\t\t} else {\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, numeric, extra ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = jQuery.camelCase( name );\n\n\t\t// Make sure that we're working with the right name\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );\n\n\t\t// gets hook for the prefixed version\n\t\t// followed by the unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name );\n\t\t}\n\n\t\t//convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Return, converting to number if forced or a qualifier was provided and val looks numeric\n\t\tif ( numeric || extra !== undefined ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn numeric || jQuery.isNumeric( num ) ? num || 0 : val;\n\t\t}\n\t\treturn val;\n\t},\n\n\t// A method for quickly swapping in/out CSS properties to get correct calculations\n\tswap: function( elem, options, callback ) {\n\t\tvar ret, name,\n\t\t\told = {};\n\n\t\t// Remember the old values, and insert the new ones\n\t\tfor ( name in options ) {\n\t\t\told[ name ] = elem.style[ name ];\n\t\t\telem.style[ name ] = options[ name ];\n\t\t}\n\n\t\tret = callback.call( elem );\n\n\t\t// Revert the old values\n\t\tfor ( name in options ) {\n\t\t\telem.style[ name ] = old[ name ];\n\t\t}\n\n\t\treturn ret;\n\t}\n});\n\n// NOTE: To any future maintainer, we've window.getComputedStyle\n// because jsdom on node.js will break without it.\nif ( window.getComputedStyle ) {\n\tcurCSS = function( elem, name ) {\n\t\tvar ret, width, minWidth, maxWidth,\n\t\t\tcomputed = window.getComputedStyle( elem, null ),\n\t\t\tstyle = elem.style;\n\n\t\tif ( computed ) {\n\n\t\t\tret = computed[ name ];\n\t\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\t\tret = jQuery.style( elem, name );\n\t\t\t}\n\n\t\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t\t// Chrome < 17 and Safari 5.0 uses \"computed value\" instead of \"used value\" for margin-right\n\t\t\t// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n\t\t\t// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n\t\t\tif ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\t\t\t\twidth = style.width;\n\t\t\t\tminWidth = style.minWidth;\n\t\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\t\tret = computed.width;\n\n\t\t\t\tstyle.width = width;\n\t\t\t\tstyle.minWidth = minWidth;\n\t\t\t\tstyle.maxWidth = maxWidth;\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t};\n} else if ( document.documentElement.currentStyle ) {\n\tcurCSS = function( elem, name ) {\n\t\tvar left, rsLeft,\n\t\t\tret = elem.currentStyle && elem.currentStyle[ name ],\n\t\t\tstyle = elem.style;\n\n\t\t// Avoid setting ret to empty string here\n\t\t// so we don't default to auto\n\t\tif ( ret == null && style && style[ name ] ) {\n\t\t\tret = style[ name ];\n\t\t}\n\n\t\t// From the awesome hack by Dean Edwards\n\t\t// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\n\n\t\t// If we're not dealing with a regular pixel number\n\t\t// but a number that has a weird ending, we need to convert it to pixels\n\t\t// but not position css attributes, as those are proportional to the parent element instead\n\t\t// and we can't measure the parent instead because it might trigger a \"stacking dolls\" problem\n\t\tif ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\tleft = style.left;\n\t\t\trsLeft = elem.runtimeStyle && elem.runtimeStyle.left;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tif ( rsLeft ) {\n\t\t\t\telem.runtimeStyle.left = elem.currentStyle.left;\n\t\t\t}\n\t\t\tstyle.left = name === \"fontSize\" ? \"1em\" : ret;\n\t\t\tret = style.pixelLeft + \"px\";\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.left = left;\n\t\t\tif ( rsLeft ) {\n\t\t\t\telem.runtimeStyle.left = rsLeft;\n\t\t\t}\n\t\t}\n\n\t\treturn ret === \"\" ? \"auto\" : ret;\n\t};\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\tvar matches = rnumsplit.exec( value );\n\treturn matches ?\n\t\t\tMath.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || \"px\" ) :\n\t\t\tvalue;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox ) {\n\tvar i = extra === ( isBorderBox ? \"border\" : \"content\" ) ?\n\t\t// If we already have the right measurement, avoid augmentation\n\t\t4 :\n\t\t// Otherwise initialize for horizontal or vertical properties\n\t\tname === \"width\" ? 1 : 0,\n\n\t\tval = 0;\n\n\tfor ( ; i < 4; i += 2 ) {\n\t\t// both box models exclude margin, so add it if we want it\n\t\tif ( extra === \"margin\" ) {\n\t\t\t// we use jQuery.css instead of curCSS here\n\t\t\t// because of the reliableMarginRight CSS hook!\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true );\n\t\t}\n\n\t\t// From this point on we use curCSS for maximum performance (relevant in animations)\n\t\tif ( isBorderBox ) {\n\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\tif ( extra === \"content\" ) {\n\t\t\t\tval -= parseFloat( curCSS( elem, \"padding\" + cssExpand[ i ] ) ) || 0;\n\t\t\t}\n\n\t\t\t// at this point, extra isn't border nor margin, so remove border\n\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\tval -= parseFloat( curCSS( elem, \"border\" + cssExpand[ i ] + \"Width\" ) ) || 0;\n\t\t\t}\n\t\t} else {\n\t\t\t// at this point, extra isn't content, so add padding\n\t\t\tval += parseFloat( curCSS( elem, \"padding\" + cssExpand[ i ] ) ) || 0;\n\n\t\t\t// at this point, extra isn't content nor padding, so add border\n\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\tval += parseFloat( curCSS( elem, \"border\" + cssExpand[ i ] + \"Width\" ) ) || 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n\t// Start with offset property, which is equivalent to the border-box value\n\tvar val = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n\t\tvalueIsBorderBox = true,\n\t\tisBorderBox = jQuery.support.boxSizing && jQuery.css( elem, \"boxSizing\" ) === \"border-box\";\n\n\t// some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\tif ( val <= 0 || val == null ) {\n\t\t// Fall back to computed then uncomputed css if necessary\n\t\tval = curCSS( elem, name );\n\t\tif ( val < 0 || val == null ) {\n\t\t\tval = elem.style[ name ];\n\t\t}\n\n\t\t// Computed unit is not pixels. Stop here and return.\n\t\tif ( rnumnonpx.test(val) ) {\n\t\t\treturn val;\n\t\t}\n\n\t\t// we need the check for style in case a browser which returns unreliable values\n\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\tvalueIsBorderBox = isBorderBox && ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );\n\n\t\t// Normalize \"\", auto, and prepare for extra\n\t\tval = parseFloat( val ) || 0;\n\t}\n\n\t// use the active box-sizing model to add/subtract irrelevant styles\n\treturn ( val +\n\t\taugmentWidthOrHeight(\n\t\t\telem,\n\t\t\tname,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox\n\t\t)\n\t) + \"px\";\n}\n\n\n// Try to determine the default display value of an element\nfunction css_defaultDisplay( nodeName ) {\n\tif ( elemdisplay[ nodeName ] ) {\n\t\treturn elemdisplay[ nodeName ];\n\t}\n\n\tvar elem = jQuery( \"<\" + nodeName + \">\" ).appendTo( document.body ),\n\t\tdisplay = elem.css(\"display\");\n\telem.remove();\n\n\t// If the simple way fails,\n\t// get element's real default display by attaching it to a temp iframe\n\tif ( display === \"none\" || display === \"\" ) {\n\t\t// Use the already-created iframe if possible\n\t\tiframe = document.body.appendChild(\n\t\t\tiframe || jQuery.extend( document.createElement(\"iframe\"), {\n\t\t\t\tframeBorder: 0,\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t})\n\t\t);\n\n\t\t// Create a cacheable copy of the iframe document on first call.\n\t\t// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML\n\t\t// document to it; WebKit & Firefox won't allow reusing the iframe document.\n\t\tif ( !iframeDoc || !iframe.createElement ) {\n\t\t\tiframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;\n\t\t\tiframeDoc.write(\"<!doctype html><html><body>\");\n\t\t\tiframeDoc.close();\n\t\t}\n\n\t\telem = iframeDoc.body.appendChild( iframeDoc.createElement(nodeName) );\n\n\t\tdisplay = curCSS( elem, \"display\" );\n\t\tdocument.body.removeChild( iframe );\n\t}\n\n\t// Store the correct default display\n\telemdisplay[ nodeName ] = display;\n\n\treturn display;\n}\n\njQuery.each([ \"height\", \"width\" ], function( i, name ) {\n\tjQuery.cssHooks[ name ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\t\t\t\t// certain elements can have dimension info if we invisibly show them\n\t\t\t\t// however, it must have a current display style that would benefit from this\n\t\t\t\tif ( elem.offsetWidth === 0 && rdisplayswap.test( curCSS( elem, \"display\" ) ) ) {\n\t\t\t\t\treturn jQuery.swap( elem, cssShow, function() {\n\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\treturn setPositiveNumber( elem, value, extra ?\n\t\t\t\taugmentWidthOrHeight(\n\t\t\t\t\telem,\n\t\t\t\t\tname,\n\t\t\t\t\textra,\n\t\t\t\t\tjQuery.support.boxSizing && jQuery.css( elem, \"boxSizing\" ) === \"border-box\"\n\t\t\t\t) : 0\n\t\t\t);\n\t\t}\n\t};\n});\n\nif ( !jQuery.support.opacity ) {\n\tjQuery.cssHooks.opacity = {\n\t\tget: function( elem, computed ) {\n\t\t\t// IE uses filters for opacity\n\t\t\treturn ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || \"\" ) ?\n\t\t\t\t( 0.01 * parseFloat( RegExp.$1 ) ) + \"\" :\n\t\t\t\tcomputed ? \"1\" : \"\";\n\t\t},\n\n\t\tset: function( elem, value ) {\n\t\t\tvar style = elem.style,\n\t\t\t\tcurrentStyle = elem.currentStyle,\n\t\t\t\topacity = jQuery.isNumeric( value ) ? \"alpha(opacity=\" + value * 100 + \")\" : \"\",\n\t\t\t\tfilter = currentStyle && currentStyle.filter || style.filter || \"\";\n\n\t\t\t// IE has trouble with opacity if it does not have layout\n\t\t\t// Force it by setting the zoom level\n\t\t\tstyle.zoom = 1;\n\n\t\t\t// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652\n\t\t\tif ( value >= 1 && jQuery.trim( filter.replace( ralpha, \"\" ) ) === \"\" &&\n\t\t\t\tstyle.removeAttribute ) {\n\n\t\t\t\t// Setting style.filter to null, \"\" & \" \" still leave \"filter:\" in the cssText\n\t\t\t\t// if \"filter:\" is present at all, clearType is disabled, we want to avoid this\n\t\t\t\t// style.removeAttribute is IE Only, but so apparently is this code path...\n\t\t\t\tstyle.removeAttribute( \"filter\" );\n\n\t\t\t\t// if there there is no filter style applied in a css rule, we are done\n\t\t\t\tif ( currentStyle && !currentStyle.filter ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// otherwise, set new filter values\n\t\t\tstyle.filter = ralpha.test( filter ) ?\n\t\t\t\tfilter.replace( ralpha, opacity ) :\n\t\t\t\tfilter + \" \" + opacity;\n\t\t}\n\t};\n}\n\n// These hooks cannot be added until DOM ready because the support test\n// for it is not run until after DOM ready\njQuery(function() {\n\tif ( !jQuery.support.reliableMarginRight ) {\n\t\tjQuery.cssHooks.marginRight = {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\t\t// Work around by temporarily setting element display to inline-block\n\t\t\t\treturn jQuery.swap( elem, { \"display\": \"inline-block\" }, function() {\n\t\t\t\t\tif ( computed ) {\n\t\t\t\t\t\treturn curCSS( elem, \"marginRight\" );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t}\n\n\t// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n\t// getComputedStyle returns percent when specified for top/left/bottom/right\n\t// rather than make the css module depend on the offset module, we just check for it here\n\tif ( !jQuery.support.pixelPosition && jQuery.fn.position ) {\n\t\tjQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\t\t\tjQuery.cssHooks[ prop ] = {\n\t\t\t\tget: function( elem, computed ) {\n\t\t\t\t\tif ( computed ) {\n\t\t\t\t\t\tvar ret = curCSS( elem, prop );\n\t\t\t\t\t\t// if curCSS returns percentage, fallback to offset\n\t\t\t\t\t\treturn rnumnonpx.test( ret ) ? jQuery( elem ).position()[ prop ] + \"px\" : ret;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n});\n\nif ( jQuery.expr && jQuery.expr.filters ) {\n\tjQuery.expr.filters.hidden = function( elem ) {\n\t\treturn ( elem.offsetWidth === 0 && elem.offsetHeight === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || curCSS( elem, \"display\" )) === \"none\");\n\t};\n\n\tjQuery.expr.filters.visible = function( elem ) {\n\t\treturn !jQuery.expr.filters.hidden( elem );\n\t};\n}\n\n// These hooks are used by animate to expand properties\njQuery.each({\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i,\n\n\t\t\t\t// assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split(\" \") : [ value ],\n\t\t\t\texpanded = {};\n\n\t\t\tfor ( i = 0; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( !rmargin.test( prefix ) ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n});\nvar r20 = /%20/g,\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,\n\trselectTextarea = /^(?:select|textarea)/i;\n\njQuery.fn.extend({\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map(function(){\n\t\t\treturn this.elements ? jQuery.makeArray( this.elements ) : this;\n\t\t})\n\t\t.filter(function(){\n\t\t\treturn this.name && !this.disabled &&\n\t\t\t\t( this.checked || rselectTextarea.test( this.nodeName ) ||\n\t\t\t\t\trinput.test( this.type ) );\n\t\t})\n\t\t.map(function( i, elem ){\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\treturn val == null ?\n\t\t\t\tnull :\n\t\t\t\tjQuery.isArray( val ) ?\n\t\t\t\t\tjQuery.map( val, function( val, i ){\n\t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t\t}) :\n\t\t\t\t\t{ name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t}).get();\n\t}\n});\n\n//Serialize an array of form elements or a set of\n//key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, value ) {\n\t\t\t// If value is a function, invoke it and return its value\n\t\t\tvalue = jQuery.isFunction( value ) ? value() : ( value == null ? \"\" : value );\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" + encodeURIComponent( value );\n\t\t};\n\n\t// Set traditional to true for jQuery <= 1.3.2 behavior.\n\tif ( traditional === undefined ) {\n\t\ttraditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n\t}\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t});\n\n\t} else {\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" ).replace( r20, \"+\" );\n};\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( jQuery.isArray( obj ) ) {\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\t\t\t\t// If array item is non-scalar (array or object), encode its\n\t\t\t\t// numeric index to resolve deserialization ambiguity issues.\n\t\t\t\t// Note that rack (as of 1.0.0) can't currently deserialize\n\t\t\t\t// nested arrays properly, and attempting to do so may cause\n\t\t\t\t// a server error. Possible fixes are to modify rack's\n\t\t\t\t// deserialization algorithm or to provide an option or flag\n\t\t\t\t// to force array serialization to be shallow.\n\t\t\t\tbuildParams( prefix + \"[\" + ( typeof v === \"object\" ? i : \"\" ) + \"]\", v, traditional, add );\n\t\t\t}\n\t\t});\n\n\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\nvar // Document location\n\tajaxLocation,\n\t// Document location segments\n\tajaxLocParts,\n\n\trhash = /#.*$/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)\\r?$/mg, // IE leaves an \\r character at EOL\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app\\-storage|.+\\-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\trquery = /\\?/,\n\trscript = /<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi,\n\trts = /([?&])_=[^&]*/,\n\trurl = /^([\\w\\+\\.\\-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+)|)|)/,\n\n\t// Keep a copy of the old load method\n\t_load = jQuery.fn.load,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = [\"*/\"] + [\"*\"];\n\n// #8138, IE may throw an exception when accessing\n// a field from window.location if document.domain has been set\ntry {\n\tajaxLocation = location.href;\n} catch( e ) {\n\t// Use the href attribute of an A element\n\t// since IE will modify it given document.location\n\tajaxLocation = document.createElement( \"a\" );\n\tajaxLocation.href = \"\";\n\tajaxLocation = ajaxLocation.href;\n}\n\n// Segment location into parts\najaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType, list, placeBefore,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().split( core_rspace ),\n\t\t\ti = 0,\n\t\t\tlength = dataTypes.length;\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tdataType = dataTypes[ i ];\n\t\t\t\t// We control if we're asked to add before\n\t\t\t\t// any existing element\n\t\t\t\tplaceBefore = /^\\+/.test( dataType );\n\t\t\t\tif ( placeBefore ) {\n\t\t\t\t\tdataType = dataType.substr( 1 ) || \"*\";\n\t\t\t\t}\n\t\t\t\tlist = structure[ dataType ] = structure[ dataType ] || [];\n\t\t\t\t// then we add to the structure accordingly\n\t\t\t\tlist[ placeBefore ? \"unshift\" : \"push\" ]( func );\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,\n\t\tdataType /* internal */, inspected /* internal */ ) {\n\n\tdataType = dataType || options.dataTypes[ 0 ];\n\tinspected = inspected || {};\n\n\tinspected[ dataType ] = true;\n\n\tvar selection,\n\t\tlist = structure[ dataType ],\n\t\ti = 0,\n\t\tlength = list ? list.length : 0,\n\t\texecuteOnly = ( structure === prefilters );\n\n\tfor ( ; i < length && ( executeOnly || !selection ); i++ ) {\n\t\tselection = list[ i ]( options, originalOptions, jqXHR );\n\t\t// If we got redirected to another dataType\n\t\t// we try there if executing only and not done already\n\t\tif ( typeof selection === \"string\" ) {\n\t\t\tif ( !executeOnly || inspected[ selection ] ) {\n\t\t\t\tselection = undefined;\n\t\t\t} else {\n\t\t\t\toptions.dataTypes.unshift( selection );\n\t\t\t\tselection = inspectPrefiltersOrTransports(\n\t\t\t\t\t\tstructure, options, originalOptions, jqXHR, selection, inspected );\n\t\t\t}\n\t\t}\n\t}\n\t// If we're only executing or nothing was selected\n\t// we try the catchall dataType if not done already\n\tif ( ( executeOnly || !selection ) && !inspected[ \"*\" ] ) {\n\t\tselection = inspectPrefiltersOrTransports(\n\t\t\t\tstructure, options, originalOptions, jqXHR, \"*\", inspected );\n\t}\n\t// unnecessary when only executing (prefilters)\n\t// but it'll be ignored by the caller in that case\n\treturn selection;\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n}\n\njQuery.fn.load = function( url, params, callback ) {\n\tif ( typeof url !== \"string\" && _load ) {\n\t\treturn _load.apply( this, arguments );\n\t}\n\n\t// Don't do a request if no elements are being requested\n\tif ( !this.length ) {\n\t\treturn this;\n\t}\n\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf(\" \");\n\n\tif ( off >= 0 ) {\n\t\tselector = url.slice( off, url.length );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( jQuery.isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// Request the remote document\n\tjQuery.ajax({\n\t\turl: url,\n\n\t\t// if \"type\" variable is undefined, then \"GET\" method will be used\n\t\ttype: type,\n\t\tdataType: \"html\",\n\t\tdata: params,\n\t\tcomplete: function( jqXHR, status ) {\n\t\t\tif ( callback ) {\n\t\t\t\tself.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t}\n\t\t}\n\t}).done(function( responseText ) {\n\n\t\t// Save response for use in complete callback\n\t\tresponse = arguments;\n\n\t\t// See if a selector was specified\n\t\tself.html( selector ?\n\n\t\t\t// Create a dummy div to hold the results\n\t\t\tjQuery(\"<div>\")\n\n\t\t\t\t// inject the contents of the document in, removing the scripts\n\t\t\t\t// to avoid any 'Permission Denied' errors in IE\n\t\t\t\t.append( responseText.replace( rscript, \"\" ) )\n\n\t\t\t\t// Locate the specified elements\n\t\t\t\t.find( selector ) :\n\n\t\t\t// If not, just inject the full result\n\t\t\tresponseText );\n\n\t});\n\n\treturn this;\n};\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( \"ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend\".split( \" \" ), function( i, o ){\n\tjQuery.fn[ o ] = function( f ){\n\t\treturn this.on( o, f );\n\t};\n});\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\t\t// shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\treturn jQuery.ajax({\n\t\t\ttype: method,\n\t\t\turl: url,\n\t\t\tdata: data,\n\t\t\tsuccess: callback,\n\t\t\tdataType: type\n\t\t});\n\t};\n});\n\njQuery.extend({\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\tif ( settings ) {\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( target, jQuery.ajaxSettings );\n\t\t} else {\n\t\t\t// Extending ajaxSettings\n\t\t\tsettings = target;\n\t\t\ttarget = jQuery.ajaxSettings;\n\t\t}\n\t\tajaxExtend( target, settings );\n\t\treturn target;\n\t},\n\n\tajaxSettings: {\n\t\turl: ajaxLocation,\n\t\tisLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\n\t\tglobal: true,\n\t\ttype: \"GET\",\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\t\tprocessData: true,\n\t\tasync: true,\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\thtml: \"text/html\",\n\t\t\ttext: \"text/plain\",\n\t\t\tjson: \"application/json, text/javascript\",\n\t\t\t\"*\": allTypes\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /xml/,\n\t\t\thtml: /html/,\n\t\t\tjson: /json/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\"\n\t\t},\n\n\t\t// List of data converters\n\t\t// 1) key format is \"source_type destination_type\" (a single space in-between)\n\t\t// 2) the catchall symbol \"*\" can be used for source_type\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": window.String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": jQuery.parseJSON,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\tcontext: true,\n\t\t\turl: true\n\t\t}\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar // ifModified key\n\t\t\tifModifiedKey,\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\t\t\t// transport\n\t\t\ttransport,\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\t\t\t// Cross-domain detection vars\n\t\t\tparts,\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\t\t\t// Loop variable\n\t\t\ti,\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\t\t\t// Context for global events\n\t\t\t// It's the callbackContext if one was provided in the options\n\t\t\t// and if it's a DOM node or a jQuery collection\n\t\t\tglobalEventContext = callbackContext !== s &&\n\t\t\t\t( callbackContext.nodeType || callbackContext instanceof jQuery ) ?\n\t\t\t\t\t\tjQuery( callbackContext ) : jQuery.event,\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\t\t\t// The jqXHR state\n\t\t\tstate = 0,\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\tvar lname = name.toLowerCase();\n\t\t\t\t\t\tname = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn state === 2 ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( state === 2 ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match === undefined ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tstatusText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( statusText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, statusText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Callback for when everything is done\n\t\t// It is defined here because jslint complains if it is declared\n\t\t// at the end of the function (which would be more logical and readable)\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Called once\n\t\t\tif ( state === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// State is \"done\" now\n\t\t\tstate = 2;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\tclearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( status >= 200 && status < 300 || status === 304 ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"Last-Modified\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ ifModifiedKey ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"Etag\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ ifModifiedKey ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If not modified\n\t\t\t\tif ( status === 304 ) {\n\n\t\t\t\t\tstatusText = \"notmodified\";\n\t\t\t\t\tisSuccess = true;\n\n\t\t\t\t// If we have data\n\t\t\t\t} else {\n\n\t\t\t\t\tisSuccess = ajaxConvert( s, response );\n\t\t\t\t\tstatusText = isSuccess.state;\n\t\t\t\t\tsuccess = isSuccess.data;\n\t\t\t\t\terror = isSuccess.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We extract error from statusText\n\t\t\t\t// then normalize statusText and status for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( !statusText || status ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = \"\" + ( nativeStatusText || statusText );\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajax\" + ( isSuccess ? \"Success\" : \"Error\" ),\n\t\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR );\n\t\tjqXHR.success = jqXHR.done;\n\t\tjqXHR.error = jqXHR.fail;\n\t\tjqXHR.complete = completeDeferred.add;\n\n\t\t// Status-dependent callbacks\n\t\tjqXHR.statusCode = function( map ) {\n\t\t\tif ( map ) {\n\t\t\t\tvar tmp;\n\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\tfor ( tmp in map ) {\n\t\t\t\t\t\tstatusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttmp = map[ jqXHR.status ];\n\t\t\t\t\tjqXHR.always( tmp );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t};\n\n\t\t// Remove hash character (#7531: and string promotion)\n\t\t// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url ) + \"\" ).replace( rhash, \"\" ).replace( rprotocol, ajaxLocParts[ 1 ] + \"//\" );\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = jQuery.trim( s.dataType || \"*\" ).toLowerCase().split( core_rspace );\n\n\t\t// Determine if a cross-domain request is in order\n\t\tif ( s.crossDomain == null ) {\n\t\t\tparts = rurl.exec( s.url.toLowerCase() );\n\t\t\ts.crossDomain = !!( parts &&\n\t\t\t\t( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||\n\t\t\t\t\t( parts[ 3 ] || ( parts[ 1 ] === \"http:\" ? 80 : 443 ) ) !=\n\t\t\t\t\t\t( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === \"http:\" ? 80 : 443 ) ) )\n\t\t\t);\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( state === 2 ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\tfireGlobals = s.global;\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t}\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.data;\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Get ifModifiedKey before adding the anti-cache parameter\n\t\t\tifModifiedKey = s.url;\n\n\t\t\t// Add anti-cache in url if needed\n\t\t\tif ( s.cache === false ) {\n\n\t\t\t\tvar ts = jQuery.now(),\n\t\t\t\t\t// try replacing _= if it is there\n\t\t\t\t\tret = s.url.replace( rts, \"$1_=\" + ts );\n\n\t\t\t\t// if nothing was replaced, add timestamp to the end\n\t\t\t\ts.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? \"&\" : \"?\" ) + \"_=\" + ts : \"\" );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tifModifiedKey = ifModifiedKey || s.url;\n\t\t\tif ( jQuery.lastModified[ ifModifiedKey ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ ifModifiedKey ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ ifModifiedKey ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ ifModifiedKey ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n\t\t\t\t// Abort if not done already and return\n\t\t\t\treturn jqXHR.abort();\n\n\t\t}\n\n\t\t// aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tfor ( i in { success: 1, error: 1, complete: 1 } ) {\n\t\t\tjqXHR[ i ]( s[ i ] );\n\t\t}\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = setTimeout( function(){\n\t\t\t\t\tjqXHR.abort( \"timeout\" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tstate = 1;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch (e) {\n\t\t\t\t// Propagate exception as error if not done\n\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\tdone( -1, e );\n\t\t\t\t// Simply rethrow otherwise\n\t\t\t\t} else {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {}\n\n});\n\n/* Handles responses to an ajax request:\n * - sets all responseXXX fields accordingly\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes,\n\t\tresponseFields = s.responseFields;\n\n\t// Fill responseXXX fields\n\tfor ( type in responseFields ) {\n\t\tif ( type in responses ) {\n\t\t\tjqXHR[ responseFields[type] ] = responses[ type ];\n\t\t}\n\t}\n\n\t// Remove auto dataType and get content-type in the process\n\twhile( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"content-type\" );\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[0] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n// Chain conversions given the request and the original response\nfunction ajaxConvert( s, response ) {\n\n\tvar conv, conv2, current, tmp,\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice(),\n\t\tprev = dataTypes[ 0 ],\n\t\tconverters = {},\n\t\ti = 0;\n\n\t// Apply the dataFilter if provided\n\tif ( s.dataFilter ) {\n\t\tresponse = s.dataFilter( response, s.dataType );\n\t}\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\t// Convert to each sequential dataType, tolerating list modification\n\tfor ( ; (current = dataTypes[++i]); ) {\n\n\t\t// There's only work to do if current dataType is non-auto\n\t\tif ( current !== \"*\" ) {\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\tif ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split(\" \");\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.splice( i--, 0, current );\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s[\"throws\"] ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn { state: \"parsererror\", error: conv ? e : \"No conversion from \" + prev + \" to \" + current };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update prev for next iteration\n\t\t\tprev = current;\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\nvar oldCallbacks = [],\n\trquestion = /\\?/,\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/,\n\tnonce = jQuery.now();\n\n// Default jsonp settings\njQuery.ajaxSetup({\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n});\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tdata = s.data,\n\t\turl = s.url,\n\t\thasCallback = s.jsonp !== false,\n\t\treplaceInUrl = hasCallback && rjsonp.test( url ),\n\t\treplaceInData = hasCallback && !replaceInUrl && typeof data === \"string\" &&\n\t\t\t!( s.contentType || \"\" ).indexOf(\"application/x-www-form-urlencoded\") &&\n\t\t\trjsonp.test( data );\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( s.dataTypes[ 0 ] === \"jsonp\" || replaceInUrl || replaceInData ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\t\toverwritten = window[ callbackName ];\n\n\t\t// Insert callback into url or form data\n\t\tif ( replaceInUrl ) {\n\t\t\ts.url = url.replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( replaceInData ) {\n\t\t\ts.data = data.replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( hasCallback ) {\n\t\t\ts.url += ( rquestion.test( url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[\"script json\"] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always(function() {\n\t\t\t// Restore preexisting value\n\t\t\twindow[ callbackName ] = overwritten;\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\t\t\t\t// make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t});\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n});\n// Install script dataType\njQuery.ajaxSetup({\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /javascript|ecmascript/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n});\n\n// Handle cache's special case and global\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t\ts.global = false;\n\t}\n});\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function(s) {\n\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\n\t\tvar script,\n\t\t\thead = document.head || document.getElementsByTagName( \"head\" )[0] || document.documentElement;\n\n\t\treturn {\n\n\t\t\tsend: function( _, callback ) {\n\n\t\t\t\tscript = document.createElement( \"script\" );\n\n\t\t\t\tscript.async = \"async\";\n\n\t\t\t\tif ( s.scriptCharset ) {\n\t\t\t\t\tscript.charset = s.scriptCharset;\n\t\t\t\t}\n\n\t\t\t\tscript.src = s.url;\n\n\t\t\t\t// Attach handlers for all browsers\n\t\t\t\tscript.onload = script.onreadystatechange = function( _, isAbort ) {\n\n\t\t\t\t\tif ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {\n\n\t\t\t\t\t\t// Handle memory leak in IE\n\t\t\t\t\t\tscript.onload = script.onreadystatechange = null;\n\n\t\t\t\t\t\t// Remove the script\n\t\t\t\t\t\tif ( head && script.parentNode ) {\n\t\t\t\t\t\t\thead.removeChild( script );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Dereference the script\n\t\t\t\t\t\tscript = undefined;\n\n\t\t\t\t\t\t// Callback if not abort\n\t\t\t\t\t\tif ( !isAbort ) {\n\t\t\t\t\t\t\tcallback( 200, \"success\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\t// Use insertBefore instead of appendChild  to circumvent an IE6 bug.\n\t\t\t\t// This arises when a base node is used (#2709 and #4378).\n\t\t\t\thead.insertBefore( script, head.firstChild );\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( script ) {\n\t\t\t\t\tscript.onload( 0, 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\nvar xhrCallbacks,\n\t// #5280: Internet Explorer will keep connections alive if we don't abort on unload\n\txhrOnUnloadAbort = window.ActiveXObject ? function() {\n\t\t// Abort all pending requests\n\t\tfor ( var key in xhrCallbacks ) {\n\t\t\txhrCallbacks[ key ]( 0, 1 );\n\t\t}\n\t} : false,\n\txhrId = 0;\n\n// Functions to create xhrs\nfunction createStandardXHR() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch( e ) {}\n}\n\nfunction createActiveXHR() {\n\ttry {\n\t\treturn new window.ActiveXObject( \"Microsoft.XMLHTTP\" );\n\t} catch( e ) {}\n}\n\n// Create the request object\n// (This is still attached to ajaxSettings for backward compatibility)\njQuery.ajaxSettings.xhr = window.ActiveXObject ?\n\t/* Microsoft failed to properly\n\t * implement the XMLHttpRequest in IE7 (can't request local files),\n\t * so we use the ActiveXObject when it is available\n\t * Additionally XMLHttpRequest can be disabled in IE7/IE8 so\n\t * we need a fallback.\n\t */\n\tfunction() {\n\t\treturn !this.isLocal && createStandardXHR() || createActiveXHR();\n\t} :\n\t// For all other browsers, use the standard XMLHttpRequest object\n\tcreateStandardXHR;\n\n// Determine support properties\n(function( xhr ) {\n\tjQuery.extend( jQuery.support, {\n\t\tajax: !!xhr,\n\t\tcors: !!xhr && ( \"withCredentials\" in xhr )\n\t});\n})( jQuery.ajaxSettings.xhr() );\n\n// Create transport if the browser can provide an xhr\nif ( jQuery.support.ajax ) {\n\n\tjQuery.ajaxTransport(function( s ) {\n\t\t// Cross domain only allowed if supported through XMLHttpRequest\n\t\tif ( !s.crossDomain || jQuery.support.cors ) {\n\n\t\t\tvar callback;\n\n\t\t\treturn {\n\t\t\t\tsend: function( headers, complete ) {\n\n\t\t\t\t\t// Get a new xhr\n\t\t\t\t\tvar handle, i,\n\t\t\t\t\t\txhr = s.xhr();\n\n\t\t\t\t\t// Open the socket\n\t\t\t\t\t// Passing null username, generates a login popup on Opera (#2865)\n\t\t\t\t\tif ( s.username ) {\n\t\t\t\t\t\txhr.open( s.type, s.url, s.async, s.username, s.password );\n\t\t\t\t\t} else {\n\t\t\t\t\t\txhr.open( s.type, s.url, s.async );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Apply custom fields if provided\n\t\t\t\t\tif ( s.xhrFields ) {\n\t\t\t\t\t\tfor ( i in s.xhrFields ) {\n\t\t\t\t\t\t\txhr[ i ] = s.xhrFields[ i ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Override mime type if needed\n\t\t\t\t\tif ( s.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\t\txhr.overrideMimeType( s.mimeType );\n\t\t\t\t\t}\n\n\t\t\t\t\t// X-Requested-With header\n\t\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\t\tif ( !s.crossDomain && !headers[\"X-Requested-With\"] ) {\n\t\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n\t\t\t\t\t}\n\n\t\t\t\t\t// Need an extra try/catch for cross domain requests in Firefox 3\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch( _ ) {}\n\n\t\t\t\t\t// Do send the request\n\t\t\t\t\t// This may raise an exception which is actually\n\t\t\t\t\t// handled in jQuery.ajax (so no try/catch here)\n\t\t\t\t\txhr.send( ( s.hasContent && s.data ) || null );\n\n\t\t\t\t\t// Listener\n\t\t\t\t\tcallback = function( _, isAbort ) {\n\n\t\t\t\t\t\tvar status,\n\t\t\t\t\t\t\tstatusText,\n\t\t\t\t\t\t\tresponseHeaders,\n\t\t\t\t\t\t\tresponses,\n\t\t\t\t\t\t\txml;\n\n\t\t\t\t\t\t// Firefox throws exceptions when accessing properties\n\t\t\t\t\t\t// of an xhr when a network error occurred\n\t\t\t\t\t\t// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)\n\t\t\t\t\t\ttry {\n\n\t\t\t\t\t\t\t// Was never called and is aborted or complete\n\t\t\t\t\t\t\tif ( callback && ( isAbort || xhr.readyState === 4 ) ) {\n\n\t\t\t\t\t\t\t\t// Only called once\n\t\t\t\t\t\t\t\tcallback = undefined;\n\n\t\t\t\t\t\t\t\t// Do not keep as active anymore\n\t\t\t\t\t\t\t\tif ( handle ) {\n\t\t\t\t\t\t\t\t\txhr.onreadystatechange = jQuery.noop;\n\t\t\t\t\t\t\t\t\tif ( xhrOnUnloadAbort ) {\n\t\t\t\t\t\t\t\t\t\tdelete xhrCallbacks[ handle ];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// If it's an abort\n\t\t\t\t\t\t\t\tif ( isAbort ) {\n\t\t\t\t\t\t\t\t\t// Abort it manually if needed\n\t\t\t\t\t\t\t\t\tif ( xhr.readyState !== 4 ) {\n\t\t\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tstatus = xhr.status;\n\t\t\t\t\t\t\t\t\tresponseHeaders = xhr.getAllResponseHeaders();\n\t\t\t\t\t\t\t\t\tresponses = {};\n\t\t\t\t\t\t\t\t\txml = xhr.responseXML;\n\n\t\t\t\t\t\t\t\t\t// Construct response list\n\t\t\t\t\t\t\t\t\tif ( xml && xml.documentElement /* #4958 */ ) {\n\t\t\t\t\t\t\t\t\t\tresponses.xml = xml;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// When requesting binary data, IE6-9 will throw an exception\n\t\t\t\t\t\t\t\t\t// on any attempt to access responseText (#11426)\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tresponses.text = xhr.responseText;\n\t\t\t\t\t\t\t\t\t} catch( _ ) {\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Firefox throws an exception when accessing\n\t\t\t\t\t\t\t\t\t// statusText for faulty cross-domain requests\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tstatusText = xhr.statusText;\n\t\t\t\t\t\t\t\t\t} catch( e ) {\n\t\t\t\t\t\t\t\t\t\t// We normalize with Webkit giving an empty statusText\n\t\t\t\t\t\t\t\t\t\tstatusText = \"\";\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Filter status for non standard behaviors\n\n\t\t\t\t\t\t\t\t\t// If the request is local and we have data: assume a success\n\t\t\t\t\t\t\t\t\t// (success with no data won't get notified, that's the best we\n\t\t\t\t\t\t\t\t\t// can do given current implementations)\n\t\t\t\t\t\t\t\t\tif ( !status && s.isLocal && !s.crossDomain ) {\n\t\t\t\t\t\t\t\t\t\tstatus = responses.text ? 200 : 404;\n\t\t\t\t\t\t\t\t\t// IE - #1450: sometimes returns 1223 when it should be 204\n\t\t\t\t\t\t\t\t\t} else if ( status === 1223 ) {\n\t\t\t\t\t\t\t\t\t\tstatus = 204;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch( firefoxAccessException ) {\n\t\t\t\t\t\t\tif ( !isAbort ) {\n\t\t\t\t\t\t\t\tcomplete( -1, firefoxAccessException );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Call complete if needed\n\t\t\t\t\t\tif ( responses ) {\n\t\t\t\t\t\t\tcomplete( status, statusText, responses, responseHeaders );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( !s.async ) {\n\t\t\t\t\t\t// if we're in sync mode we fire the callback\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t} else if ( xhr.readyState === 4 ) {\n\t\t\t\t\t\t// (IE6 & IE7) if it's in cache and has been\n\t\t\t\t\t\t// retrieved directly we need to fire the callback\n\t\t\t\t\t\tsetTimeout( callback, 0 );\n\t\t\t\t\t} else {\n\t\t\t\t\t\thandle = ++xhrId;\n\t\t\t\t\t\tif ( xhrOnUnloadAbort ) {\n\t\t\t\t\t\t\t// Create the active xhrs callbacks list if needed\n\t\t\t\t\t\t\t// and attach the unload handler\n\t\t\t\t\t\t\tif ( !xhrCallbacks ) {\n\t\t\t\t\t\t\t\txhrCallbacks = {};\n\t\t\t\t\t\t\t\tjQuery( window ).unload( xhrOnUnloadAbort );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Add to list of active xhrs callbacks\n\t\t\t\t\t\t\txhrCallbacks[ handle ] = callback;\n\t\t\t\t\t\t}\n\t\t\t\t\t\txhr.onreadystatechange = callback;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tabort: function() {\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tcallback(0,1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t});\n}\nvar fxNow, timerId,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trfxnum = new RegExp( \"^(?:([-+])=|)(\" + core_pnum + \")([a-z%]*)$\", \"i\" ),\n\trrun = /queueHooks$/,\n\tanimationPrefilters = [ defaultPrefilter ],\n\ttweeners = {\n\t\t\"*\": [function( prop, value ) {\n\t\t\tvar end, unit, prevScale,\n\t\t\t\ttween = this.createTween( prop, value ),\n\t\t\t\tparts = rfxnum.exec( value ),\n\t\t\t\ttarget = tween.cur(),\n\t\t\t\tstart = +target || 0,\n\t\t\t\tscale = 1;\n\n\t\t\tif ( parts ) {\n\t\t\t\tend = +parts[2];\n\t\t\t\tunit = parts[3] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\n\t\t\t\t// We need to compute starting value\n\t\t\t\tif ( unit !== \"px\" && start ) {\n\t\t\t\t\t// Iteratively approximate from a nonzero starting point\n\t\t\t\t\t// Prefer the current property, because this process will be trivial if it uses the same units\n\t\t\t\t\t// Fallback to end or a simple constant\n\t\t\t\t\tstart = jQuery.css( tween.elem, prop, true ) || end || 1;\n\n\t\t\t\t\tdo {\n\t\t\t\t\t\t// If previous iteration zeroed out, double until we get *something*\n\t\t\t\t\t\t// Use a string for doubling factor so we don't accidentally see scale as unchanged below\n\t\t\t\t\t\tprevScale = scale = scale || \".5\";\n\n\t\t\t\t\t\t// Adjust and apply\n\t\t\t\t\t\tstart = start / scale;\n\t\t\t\t\t\tjQuery.style( tween.elem, prop, start + unit );\n\n\t\t\t\t\t\t// Update scale, tolerating zeroes from tween.cur()\n\t\t\t\t\t\tscale = tween.cur() / target;\n\n\t\t\t\t\t// Stop looping if we've hit the mark or scale is unchanged\n\t\t\t\t\t} while ( scale !== 1 && scale !== prevScale );\n\t\t\t\t}\n\n\t\t\t\ttween.unit = unit;\n\t\t\t\ttween.start = start;\n\t\t\t\t// If a +=/-= token was provided, we're doing a relative animation\n\t\t\t\ttween.end = parts[1] ? start + ( parts[1] + 1 ) * end : end;\n\t\t\t}\n\t\t\treturn tween;\n\t\t}]\n\t};\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\tsetTimeout(function() {\n\t\tfxNow = undefined;\n\t}, 0 );\n\treturn ( fxNow = jQuery.now() );\n}\n\nfunction createTweens( animation, props ) {\n\tjQuery.each( props, function( prop, value ) {\n\t\tvar collection = ( tweeners[ prop ] || [] ).concat( tweeners[ \"*\" ] ),\n\t\t\tindex = 0,\n\t\t\tlength = collection.length;\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tif ( collection[ index ].call( animation, prop, value ) ) {\n\n\t\t\t\t// we're done with this property\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tindex = 0,\n\t\ttweenerIndex = 0,\n\t\tlength = animationPrefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\t\t\t// don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t}),\n\t\ttick = function() {\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\t\t\t\tpercent = 1 - ( remaining / animation.duration || 0 ),\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ]);\n\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t} else {\n\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tanimation = deferred.promise({\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, { specialEasing: {} }, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end, easing ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\t\t\t\t\t// if we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\n\t\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// resolve when we played the last frame\n\t\t\t\t// otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length ; index++ ) {\n\t\tresult = animationPrefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tcreateTweens( animation, props );\n\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue,\n\t\t\telem: elem\n\t\t})\n\t);\n\n\t// attach callbacks from options\n\treturn animation.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = jQuery.camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( jQuery.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// not quite $.extend, this wont overwrite keys already present.\n\t\t\t// also - reusing 'index' from above because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweener: function( props, callback ) {\n\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.split(\" \");\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length ; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\ttweeners[ prop ] = tweeners[ prop ] || [];\n\t\t\ttweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tanimationPrefilters.unshift( callback );\n\t\t} else {\n\t\t\tanimationPrefilters.push( callback );\n\t\t}\n\t}\n});\n\nfunction defaultPrefilter( elem, props, opts ) {\n\tvar index, prop, value, length, dataShow, tween, hooks, oldfire,\n\t\tanim = this,\n\t\tstyle = elem.style,\n\t\torig = {},\n\t\thandled = [],\n\t\thidden = elem.nodeType && isHidden( elem );\n\n\t// handle queue: false promises\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always(function() {\n\t\t\t// doing this makes sure that the complete handler will be called\n\t\t\t// before this completes\n\t\t\tanim.always(function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t// height/width overflow pass\n\tif ( elem.nodeType === 1 && ( \"height\" in props || \"width\" in props ) ) {\n\t\t// Make sure that nothing sneaks out\n\t\t// Record all 3 overflow attributes because IE does not\n\t\t// change the overflow attribute when overflowX and\n\t\t// overflowY are set to the same value\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Set display property to inline-block for height/width\n\t\t// animations on inline elements that are having width/height animated\n\t\tif ( jQuery.css( elem, \"display\" ) === \"inline\" &&\n\t\t\t\tjQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\t// inline-level elements accept inline-block;\n\t\t\t// block-level elements need to be inline with layout\n\t\t\tif ( !jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay( elem.nodeName ) === \"inline\" ) {\n\t\t\t\tstyle.display = \"inline-block\";\n\n\t\t\t} else {\n\t\t\t\tstyle.zoom = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tif ( !jQuery.support.shrinkWrapBlocks ) {\n\t\t\tanim.done(function() {\n\t\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t\t});\n\t\t}\n\t}\n\n\n\t// show/hide pass\n\tfor ( index in props ) {\n\t\tvalue = props[ index ];\n\t\tif ( rfxtypes.exec( value ) ) {\n\t\t\tdelete props[ index ];\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\thandled.push( index );\n\t\t}\n\t}\n\n\tlength = handled.length;\n\tif ( length ) {\n\t\tdataShow = jQuery._data( elem, \"fxshow\" ) || jQuery._data( elem, \"fxshow\", {} );\n\t\tif ( hidden ) {\n\t\t\tjQuery( elem ).show();\n\t\t} else {\n\t\t\tanim.done(function() {\n\t\t\t\tjQuery( elem ).hide();\n\t\t\t});\n\t\t}\n\t\tanim.done(function() {\n\t\t\tvar prop;\n\t\t\tjQuery.removeData( elem, \"fxshow\", true );\n\t\t\tfor ( prop in orig ) {\n\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t}\n\t\t});\n\t\tfor ( index = 0 ; index < length ; index++ ) {\n\t\t\tprop = handled[ index ];\n\t\t\ttween = anim.createTween( prop, hidden ? dataShow[ prop ] : 0 );\n\t\t\torig[ prop ] = dataShow[ prop ] || jQuery.style( elem, prop );\n\n\t\t\tif ( !( prop in dataShow ) ) {\n\t\t\t\tdataShow[ prop ] = tween.start;\n\t\t\t\tif ( hidden ) {\n\t\t\t\t\ttween.end = tween.start;\n\t\t\t\t\ttween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || \"swing\";\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\tif ( tween.elem[ tween.prop ] != null &&\n\t\t\t\t(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// passing any value as a 4th parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails\n\t\t\t// so, simple values such as \"10px\" are parsed to Float.\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, false, \"\" );\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\t\t\t// use step hook for back compat - use cssHook if its there - use .style if its\n\t\t\t// available and use plain properties where available\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Remove in 2.0 - this supports IE8's panic based approach\n// to setting things on disconnected nodes\n\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.each([ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ||\n\t\t\t// special check for .toggle( handler, handler, ... )\n\t\t\t( !i && jQuery.isFunction( speed ) && jQuery.isFunction( easing ) ) ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n});\n\njQuery.fn.extend({\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHidden ).css( \"opacity\", 0 ).show()\n\n\t\t\t// animate to the value specified\n\t\t\t.end().animate({ opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations resolve immediately\n\t\t\t\tif ( empty ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = jQuery._data( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// start the next in the queue if the last step wasn't forced\n\t\t\t// timers currently will call their complete callbacks, which will dequeue\n\t\t\t// but only if they were gotoEnd\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t});\n\t}\n});\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\tattrs = { height: type },\n\t\ti = 0;\n\n\t// if we include width, step value is 1 to do all cssExpand values,\n\t// if we don't include width, step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth? 1 : 0;\n\tfor( ; i < 4 ; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\n// Generate shortcuts for custom animations\njQuery.each({\n\tslideDown: genFx(\"show\"),\n\tslideUp: genFx(\"hide\"),\n\tslideToggle: genFx(\"toggle\"),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n});\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tjQuery.isFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t};\n\n\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration :\n\t\topt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n\n\t// normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p*Math.PI ) / 2;\n\t}\n};\n\njQuery.timers = [];\njQuery.fx = Tween.prototype.init;\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ttimers = jQuery.timers,\n\t\ti = 0;\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\t\t// Checks the timer has not already been removed\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n};\n\njQuery.fx.timer = function( timer ) {\n\tif ( timer() && jQuery.timers.push( timer ) && !timerId ) {\n\t\ttimerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t}\n};\n\njQuery.fx.interval = 13;\n\njQuery.fx.stop = function() {\n\tclearInterval( timerId );\n\ttimerId = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\t// Default speed\n\t_default: 400\n};\n\n// Back Compat <1.8 extension point\njQuery.fx.step = {};\n\nif ( jQuery.expr && jQuery.expr.filters ) {\n\tjQuery.expr.filters.animated = function( elem ) {\n\t\treturn jQuery.grep(jQuery.timers, function( fn ) {\n\t\t\treturn elem === fn.elem;\n\t\t}).length;\n\t};\n}\nvar rroot = /^(?:body|html)$/i;\n\njQuery.fn.offset = function( options ) {\n\tif ( arguments.length ) {\n\t\treturn options === undefined ?\n\t\t\tthis :\n\t\t\tthis.each(function( i ) {\n\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t});\n\t}\n\n\tvar box, docElem, body, win, clientTop, clientLeft, scrollTop, scrollLeft, top, left,\n\t\telem = this[ 0 ],\n\t\tdoc = elem && elem.ownerDocument;\n\n\tif ( !doc ) {\n\t\treturn;\n\t}\n\n\tif ( (body = doc.body) === elem ) {\n\t\treturn jQuery.offset.bodyOffset( elem );\n\t}\n\n\tdocElem = doc.documentElement;\n\n\t// Make sure we're not dealing with a disconnected DOM node\n\tif ( !jQuery.contains( docElem, elem ) ) {\n\t\treturn { top: 0, left: 0 };\n\t}\n\n\tbox = elem.getBoundingClientRect();\n\twin = getWindow( doc );\n\tclientTop  = docElem.clientTop  || body.clientTop  || 0;\n\tclientLeft = docElem.clientLeft || body.clientLeft || 0;\n\tscrollTop  = win.pageYOffset || docElem.scrollTop;\n\tscrollLeft = win.pageXOffset || docElem.scrollLeft;\n\ttop  = box.top  + scrollTop  - clientTop;\n\tleft = box.left + scrollLeft - clientLeft;\n\n\treturn { top: top, left: left };\n};\n\njQuery.offset = {\n\n\tbodyOffset: function( body ) {\n\t\tvar top = body.offsetTop,\n\t\t\tleft = body.offsetLeft;\n\n\t\tif ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {\n\t\t\ttop  += parseFloat( jQuery.css(body, \"marginTop\") ) || 0;\n\t\t\tleft += parseFloat( jQuery.css(body, \"marginLeft\") ) || 0;\n\t\t}\n\n\t\treturn { top: top, left: left };\n\t},\n\n\tsetOffset: function( elem, options, i ) {\n\t\tvar position = jQuery.css( elem, \"position\" );\n\n\t\t// set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tvar curElem = jQuery( elem ),\n\t\t\tcurOffset = curElem.offset(),\n\t\t\tcurCSSTop = jQuery.css( elem, \"top\" ),\n\t\t\tcurCSSLeft = jQuery.css( elem, \"left\" ),\n\t\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) && jQuery.inArray(\"auto\", [curCSSTop, curCSSLeft]) > -1,\n\t\t\tprops = {}, curPosition = {}, curTop, curLeft;\n\n\t\t// need to be able to calculate position if either top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( jQuery.isFunction( options ) ) {\n\t\t\toptions = options.call( elem, i, curOffset );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\n\njQuery.fn.extend({\n\n\tposition: function() {\n\t\tif ( !this[0] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar elem = this[0],\n\n\t\t// Get *real* offsetParent\n\t\toffsetParent = this.offsetParent(),\n\n\t\t// Get correct offsets\n\t\toffset       = this.offset(),\n\t\tparentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();\n\n\t\t// Subtract element margins\n\t\t// note: when an element has margin: auto the offsetLeft and marginLeft\n\t\t// are the same in Safari causing offset.left to incorrectly be 0\n\t\toffset.top  -= parseFloat( jQuery.css(elem, \"marginTop\") ) || 0;\n\t\toffset.left -= parseFloat( jQuery.css(elem, \"marginLeft\") ) || 0;\n\n\t\t// Add offsetParent borders\n\t\tparentOffset.top  += parseFloat( jQuery.css(offsetParent[0], \"borderTopWidth\") ) || 0;\n\t\tparentOffset.left += parseFloat( jQuery.css(offsetParent[0], \"borderLeftWidth\") ) || 0;\n\n\t\t// Subtract the two offsets\n\t\treturn {\n\t\t\ttop:  offset.top  - parentOffset.top,\n\t\t\tleft: offset.left - parentOffset.left\n\t\t};\n\t},\n\n\toffsetParent: function() {\n\t\treturn this.map(function() {\n\t\t\tvar offsetParent = this.offsetParent || document.body;\n\t\t\twhile ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, \"position\") === \"static\") ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\t\t\treturn offsetParent || document.body;\n\t\t});\n\t}\n});\n\n\n// Create scrollLeft and scrollTop methods\njQuery.each( {scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\"}, function( method, prop ) {\n\tvar top = /Y/.test( prop );\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn jQuery.access( this, function( elem, method, val ) {\n\t\t\tvar win = getWindow( elem );\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? (prop in win) ? win[ prop ] :\n\t\t\t\t\twin.document.documentElement[ method ] :\n\t\t\t\t\telem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : jQuery( win ).scrollLeft(),\n\t\t\t\t\t top ? val : jQuery( win ).scrollTop()\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length, null );\n\t};\n});\n\nfunction getWindow( elem ) {\n\treturn jQuery.isWindow( elem ) ?\n\t\telem :\n\t\telem.nodeType === 9 ?\n\t\t\telem.defaultView || elem.parentWindow :\n\t\t\tfalse;\n}\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name }, function( defaultExtra, funcName ) {\n\t\t// margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn jQuery.access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\t\t\t\t\t// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n\t\t\t\t\t// isn't a whole lot we can do. See pull request at this URL for discussion:\n\t\t\t\t\t// https://github.com/jquery/jquery/pull/764\n\t\t\t\t\treturn elem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest\n\t\t\t\t\t// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, value, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable, null );\n\t\t};\n\t});\n});\n// Expose jQuery to the global object\nwindow.jQuery = window.$ = jQuery;\n\n// Expose jQuery as an AMD module, but only for AMD loaders that\n// understand the issues with loading multiple versions of jQuery\n// in a page that all might call define(). The loader will indicate\n// they have special allowances for multiple jQuery versions by\n// specifying define.amd.jQuery = true. Register as a named module,\n// since jQuery can be concatenated with other files that may use define,\n// but not use a proper concatenation script that understands anonymous\n// AMD modules. A named AMD is safest and most robust way to register.\n// Lowercase jquery is used because AMD module names are derived from\n// file names, and jQuery is normally delivered in a lowercase file name.\n// Do this after creating the global so that if an AMD module wants to call\n// noConflict to hide this version of jQuery, it will work.\nif ( typeof define === \"function\" && define.amd && define.amd.jQuery ) {\n\tdefine( \"jquery\", [], function () { return jQuery; } );\n}\n\nreturn jQuery;\n\n})( window ); }));\n\n//@ sourceURL=/node_modules/sortable/node_modules/jquery-browserify/lib/jquery.js"
));

require.define("/client.js",Function(['require','module','exports','__dirname','__filename','process','global'],"\nvar Rumours    = require('rumours')\nvar hashchange = require('hash-change')\nvar o          = require('observable')\nvar u          = require('./utils')\nvar h          = require('hyperscript')\nvar jsonp      = require('jsonp')\nvar YouTubePlayer \n               = require('youtube-player')\nvar Sortable   = require('sortable')\n\nvar rumours = Rumours({\n  db: 'dj'\n})\n\nvar playlist, ctrl, doc\n\nhashchange.on('change', onChange)\nonChange()\n\nfunction onChange() {\n\n  var name = hashchange.hash() || '_'\n\n  if(playlist) playlist.dispose()\n  if(ctrl)     ctrl.dispose()\n\n  //PLAYLIST global, so can interact with the player from console.\n  PLAYLIST =\n  playlist = rumours.open('r-array!playlist!'+name, function () {})\n  ctrl     = rumours.open('model!ctrl!'+name   , function () {\n    if('number' !== typeof ctrl.get('current'))\n      ctrl.set('current', 0)\n  })\n\n  //TODO validate playlist. MUST NOT CONTAIN strings, etc.\n\n  playlist.on('update', function () {\n    var splices = []\n    playlist.forEach(function (e, i) {\n      if(!(e && e.thumbnail)) {\n        playlist.splice(i, 1)\n      }\n    })\n    var l = playlist.length\n    var c = ctrl.get('current')\n    if('number' !== typeof c || l > c || c < 0)\n      ctrl.set('current', 0)      \n  })\n\n  var state   = o.property(ctrl, 'state')\n  var current = o.property(ctrl, 'current')\n  var show    = o()\n  var part = PART = o(); part(true)\n  var _part = o.not(part)\n  var button  = o.boolean (state, '[stop]', '[play>')\n  var button2  = o.boolean (state, '[]', '>>')\n  \n  show(true)\n\n  var list = h('table#playlist')\n\n  var list2 = h('table#searchlist')\n  \n  var plist = u.rArray(playlist)\n  var player, input, search, list2\n\n  var item\n  document.body.innerHTML = ''\n\n  var plEl, sEl\n\n  var list = Sortable(playlist, function (e, i) {\n    return h('tr', \n      {className:\n        o.compute([current, button], function (s) {\n          return s == i ? \n            'track_playing' : 'track_notplaying'\n        })\n      },\n\n      h('td.thumb', \n        h('img', {src: e.thumbnail.sqDefault})\n      ),\n\n      h('td.trackname', e.title),\n      h('td.del',\n        h('a', {\n          href: '#',\n          onclick: function (e) {\n            list.splice(i, 1)\n            e.preventDefault()\n          }}, 'X'\n        )\n      )\n    )\n  })\n\n  playlist.on('update', function () {\n    list._reset(playlist.toJSON())\n  })\n\n  document.body.appendChild(\n    h('div#content',\n      plEl = h('div#playlist', \n        h('h1',\n          h('a', {onclick: function (e) {\n              show(!show());\n            }}, o.boolean(show, 'hide', 'show')\n          ),\n          h('a', {\n            onclick: function (e) {\n              var c = current() || 0\n              current(c <= 0 ? playlist.length - 1 : --c)\n              e.preventDefault()\n            }},\n            '<<'\n          ),\n          h('a', {\n            onclick: function (e) {\n              state(!state())\n              if(!current) current(0)\n              e.preventDefault()\n            }},\n            button\n          ),\n          h('a', {\n            onclick: function (e) {\n              var c = current() || 0\n              current(c >= playlist.length ? 0 : ++c)\n              e.preventDefault()\n            }},\n            '>>'\n          ),\n          o.compute([current, plist], function (c, list) {\n            var t = list[c]\n            return t ? t.title : ''\n          })\n        ),\n        list.element\n      ),\n      h('div#search',\n        input = h('input', {onkeydown: function (e) {\n          if(e.keyCode == 13 && this.value) {            \n            list.push(search()[item()])\n            this.select()\n          } else {\n            if('number' !== typeof item()) item(0)\n            if(e.keyCode == 38) {\n              item(item() - 1)\n              e.preventDefault()\n            }\n            if(e.keyCode == 40) {\n              item(item() + 1)\n              e.preventDefault()\n            }\n          }\n        }}),\n        sEl = h('div#search', list2)\n      ),\n      h('div#player',\n        h('div', {className: \n            o.boolean(show, 'showplayer', 'hideplayer') \n          },\n          h('div#yt_player')\n        )\n      )\n    )\n  )\n  \n\n  o.hover(plEl)(part)\n\n  search = \n  u.query(u.debounce(o.input(input)), function (v, cb) {\n    jsonp(\n      'http://gdata.youtube.com/feeds/api/videos?q='\n      + v\n      + '&format=5&max-results=20&v=2&alt=jsonc',\n      function (err, data) {\n        cb(err, data && data.data.items)\n      })\n  }, [])\n\n  item = u.index(search)\n\n  u.list(search, function (e, i) {\n    var t\n    return t = h('tr', {className:\n        o.compute([item, search], function (j) {\n          //very confused why this is not working.\n          //but the other compute below is,\n          //and the other cursor does work...!?!??\n          process.nextTick(function () {\n            t.className = j == i ? 'current' :'notcurrent'            \n          })\n          return j == i ? 'current' :'notcurrent'\n        }),\n        onclick: function () {\n          console.log('PUSH', e)\n          list.push(e)\n        }\n      },\n      h('td', \n        o.compute([item], function (s) {\n          return s == i ? \n            '*' : '-'\n        })\n      ),\n      h('td', h('img', {src: e.thumbnail.sqDefault})),\n      h('td', e.title))\n  }, list2)\n\n  //PLAYER global, so can interact with the player from console.\n  player = PLAYER = new YouTubePlayer({id: 'yt_player'})\n\n  var cur = \n  o.compute([state, show, current, plist], function (play, show, i, list) {\n    return play && show ? list[i || 0].id : null\n  })\n\n  var ended = false\n  var prev\n  cur(function (id) {\n    if(ended) {\n      ended = false\n      return current(current() + 1)\n    }\n    id ? \n      prev !== id && player.play(prev = id)\n    : player.pause(), prev = null\n  })\n\n  player.on('end', function () {\n    //if the last track has ended, move to the next one.\n    if(current() + 1 == plist().length)\n      return current(0)\n    current(current() + 1)\n  })\n\n}\n\n\n//@ sourceURL=/client.js"
));
require("/client.js");

</script></html>
